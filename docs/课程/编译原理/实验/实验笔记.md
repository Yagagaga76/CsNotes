## 实验一：词法分析与语法分析
### 词法分析程序 Flex
- 在 `.l` 文件中变下 Flex 程序，通过 `Flex lexical.l` 来编译得到 C 语言程序，这个程序有一个 `yylex()` 函数
- Flex 也需要一个 main 函数
```c
int main(int argc, char** argv) {
	if (argc > 1) {
		if (!(yyin = fopen(argv[1], "r"))) {
			perror(argv[1]);
			return 1;
		}
	}
	while (yylex() != 0);
	return 0;
}
```
- 这个 main 可以直接写在 `.l` 文件内，或者在单独的 `main.c`
	- 其中 `yyin` 是 Flex 内部变量，可能需要 `extern FILE* yyin`
- 编译得到可执行文件 `gcc main.c lex.yy.c -lfl -o scanner`
- 使用可执行文件进行词法分析 `./scanner test.cmm`
#### 编写 Flex 程序
- Flex 程序的基本结构
```c
{definitions}
%%
{rules}
%%
{user subroutines}
```
##### definitions 定义部分
- 为后面常用的正则表达式取一个别名 `name definition`
```c
digit [0-9]
letter [_a-zA-Z]
%%
...
```

##### rules 规则部分
- 绑定正则表达式和响应函数 `pattern {action}` 进行具体操作
- Flex 会按照顺序依次尝试每一个规则，尽可能匹配最长的输入，如果都不匹配就将内容复制到标准输出
	- 或者添加 `.` 匹配任何输入，并进行自定义处理
```c
digit [0-9]
%%
{digit}+ {printf("Integer value %d\n"),atoi(yytext)}
%%
```
- 将数字字符串转化为整数并进行打印

##### user subroutines 用户自定义代码
- 这部分代码会被复制到生成的 `lex.yy.c` 用于执行用户自定义所需的函数
- 如果用户想要对这部分所用到的变量、函数或者头文件**进行声明**，可以在前面的第一部分之前使用 `%{}%` 来提那家，这部分内容会被复制到 `lex.yy.c` 的最前面
```c
%{
/* 此处省略#include 部分 */
int chars = 0;
int words = 0;
int lines = 0;
%}
letter [a-zA-Z]
%%
{letter} { words++; chars+= yyleng; }
\n { chars++; lines++; }
. { chars++; }
%%
int main(int argc, char** argv) {
	if (argc > 1) {
		if (!(yyin = fopen(argv[1], "r"))) {
			perror(argv[1]);
			return 1;
		}
	}
	yylex();//读取文件并进行分析
	printf("%8d%8d%8d\n", lines, words, chars);
	return 0;
}
```
- 注意引用上面定义的正则一定要添加花括号 `{INT} { printf("INT:%s\n",yytext); }`
- 支持多文件（多参数）的 main 版本
```c
int main(int argc, char** argv) {
    int i, totchars = 0, totwords = 0, totlines = 0;
    if (argc < 2) { /* just read stdin */
        yylex();
        printf("%8d%8d%8d\n", lines, words, chars);
        return 0;
    }
    for (i = 1; i < argc; i++) {
        FILE *f = fopen(argv[i], "r");
        if (!f) {
            perror(argv[i]);
            return 1;
        }
        yyrestart(f);
        yylex();
        fclose(f);
        printf("%8d%8d%8d %s\n", lines, words, chars, argv[i]);
        totchars += chars; chars = 0;
        totwords += words; words = 0;
        totlines += lines; lines = 0;
    }
    if (argc > 1)
        printf("%8d%8d%8d total\n", totlines, totwords, totchars);
    return 0;
}
```
#### Flex 书写正则表达式
- 符号“.”匹配除换行符“\\n”之外的任何一个字符。
- [[正则表达式]]
#### [[Project_1.pdf#page=43&selection=117,0,118,5|Flex高级特征]]
### 语法分析 Bison
- 读入词法单元流，判断输入程序是否符合程序设计语言的语法规范，并在匹配规范的情况下构建输入程序的静态结构
- Bison 使用自底向上的 LALR (1)分析技术
- 编译写好的 Bison 源程序 `bison syntax.y` 生成 `syntax.yy.c`，程序内有一个 `yyparse()` 方法用于对输入文件进行**语法分析**
	- 没有分析错误则返回 0，否则非 0
- Bison 程序的运行还依赖于词法单元，需要再提供 flex 的 `yylex` 函数
	- 在 Bision 源代码添加 `#include "lex.yy.c"
	- 在编译时使用  `bison -d syntax.y` 会自动拆分 c 和 h
	- 最后在 Flex 中添加 `#include "syntax.tab.h"`
- 由于 Bison 会在需要时自动调用 yylex ()，我们在 main 函数中也就不需要调用它了。不过，Bison 是不会自己调用 yyparse ()和 yyrestart ()的，因此仍需要在 main 函数中显式地调用这两个函数
```c
int main(int argc, char** argv) { 
    if (argc > 1) 
    { 
        if (!(yyin = fopen(argv[1], "r"))) 
        { 
            perror(argv[1]); 
                return 1; 
        }
    }
    yyrestart(yyin);
    yyparse();
    return 0; 
} 
```
- 联合编译 `gcc main.c syntax.tab.c -lfl -ly -o parser`
	- 执行测试 ``
#### 编写 Bison 程序
- 