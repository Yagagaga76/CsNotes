## 实验一：词法分析与语法分析
### 词法分析程序 Flex
- 在 `.l` 文件中变下 Flex 程序，通过 `Flex lexical.l` 来编译得到 C 语言程序，这个程序有一个 `yylex()` 函数
- Flex 也需要一个 main 函数
```c
int main(int argc, char** argv) {
	if (argc > 1) {
		if (!(yyin = fopen(argv[1], "r"))) {
			perror(argv[1]);
			return 1;
		}
	}
	while (yylex() != 0);
	return 0;
}
```
- 这个 main 可以直接写在 `.l` 文件内，或者在单独的 `main.c`
	- 其中 `yyin` 是 Flex 内部变量，可能需要 `extern FILE* yyin`
- 编译得到可执行文件 `gcc main.c lex.yy.c -lfl -o scanner`
- 使用可执行文件进行词法分析 `./scanner test.cmm`
#### 编写 Flex 程序
- Flex 程序的基本结构
```c
{definitions}
%%
{rules}
%%
{user subroutines}
```
##### definitions 定义部分
- 为后面常用的正则表达式取一个别名 `name definition`
```c
digit [0-9]
letter [_a-zA-Z]
%%
...
```

##### rules 规则部分
- 绑定正则表达式和响应函数 `pattern {action}` 进行具体操作
- Flex 会按照顺序依次尝试每一个规则，尽可能匹配最长的输入，如果都不匹配就将内容复制到标准输出
	- 或者添加 `.` 匹配任何输入，并进行自定义处理
```c
digit [0-9]
%%
{digit}+ {printf("Integer value %d\n"),atoi(yytext)}
%%
```
- 将数字字符串转化为整数并进行打印

##### user subroutines 用户自定义代码
- 这部分代码会被复制到生成的 `lex.yy.c` 用于执行用户自定义所需的函数
- 如果用户想要对这部分所用到的变量、函数或者头文件**进行声明**，可以在前面的第一部分之前使用 `%{}%` 来提那家，这部分内容会被复制到 `lex.yy.c` 的最前面
```c
%{
/* 此处省略#include 部分 */
int chars = 0;
int words = 0;
int lines = 0;
%}
letter [a-zA-Z]
%%
{letter} { words++; chars+= yyleng; }
\n { chars++; lines++; }
. { chars++; }
%%
int main(int argc, char** argv) {
	if (argc > 1) {
		if (!(yyin = fopen(argv[1], "r"))) {
			perror(argv[1]);
			return 1;
		}
	}
	yylex();//读取文件并进行分析
	printf("%8d%8d%8d\n", lines, words, chars);
	return 0;
}
```
- 注意引用上面定义的正则一定要添加花括号 `{INT} { printf("INT:%s\n",yytext); }`
- 支持多文件（多参数）的 main 版本
```c
int main(int argc, char** argv) {
    int i, totchars = 0, totwords = 0, totlines = 0;
    if (argc < 2) { /* just read stdin */
        yylex();
        printf("%8d%8d%8d\n", lines, words, chars);
        return 0;
    }
    for (i = 1; i < argc; i++) {
        FILE *f = fopen(argv[i], "r");
        if (!f) {
            perror(argv[i]);
            return 1;
        }
        yyrestart(f);
        yylex();
        fclose(f);
        printf("%8d%8d%8d %s\n", lines, words, chars, argv[i]);
        totchars += chars; chars = 0;
        totwords += words; words = 0;
        totlines += lines; lines = 0;
    }
    if (argc > 1)
        printf("%8d%8d%8d total\n", totlines, totwords, totchars);
    return 0;
}
```
#### Flex 书写正则表达式
- 符号“.”匹配除换行符“\\n”之外的任何一个字符。
- [[正则表达式]]
#### [[Project_1.pdf#page=43&selection=117,0,118,5|Flex高级特征]]
### 语法分析 Bison
- 读入词法单元流，判断输入程序是否符合程序设计语言的语法规范，并在匹配规范的情况下构建输入程序的静态结构
- Bison 使用自底向上的 LALR (1)分析技术
- 编译写好的 Bison 源程序 `bison syntax.y` 生成 `syntax.yy.c`，程序内有一个 `yyparse()` 方法用于对输入文件进行**语法分析**
	- 没有分析错误则返回 0，否则非 0
- Bison 程序的运行还依赖于词法单元，需要再提供 flex 的 `yylex` 函数
	- 在 Bision 源代码添加 `#include "lex.yy.c"
	- 在编译时使用  `bison -d syntax.y` 会自动拆分 c 和 h
	- 最后在 Flex 中添加 `#include "syntax.tab.h"`
- 由于 Bison 会在需要时自动调用 yylex ()，我们在 main 函数中也就不需要调用它了。不过，Bison 是不会自己调用 yyparse ()和 yyrestart ()的，因此仍需要在 main 函数中显式地调用这两个函数
```c
int main(int argc, char** argv) { 
    if (argc > 1) 
    { 
        if (!(yyin = fopen(argv[1], "r"))) 
        { 
            perror(argv[1]); 
                return 1; 
        }
    }
    yyrestart(yyin);
    yyparse();
    return 0; 
} 
```
- 联合编译 `gcc main.c syntax.tab.c -lfl -ly -o parser`
	- 执行测试 `./parser test.cmm`
#### 编写 Bison 程序
- 同样分为三部分：
	- 定义部分：词法单元的定义
	- 规则部分：具体语法和相应的语义动作
	-  用户函数部分
- 对于文法：![image.png|198](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240324195255.png)
```c
%{
    #include <stdio.h>
%}
/* declared tokens */
%token INT
%token ADD SUB MUL DIV

%%
Calc : /* empty */
	| Exp { printf("= %d\n", $1); }
;
Exp : Factor
    | Exp ADD Factor { $$ = $1 + $3; }
	| Exp SUB Factor { $$ = $1 - $3; }
;
Factor : Term
    | Factor MUL Term { $$ = $1 * $3; }
	| Factor DIV Term { $$ = $1 / $3; }
;
Term : INT
;
%%
#include "lex.yy.c"
int main() {
    yyparse();
}
//每发现一个语法错误时被调用
yyerror(char* msg) {
    fprintf(stderr, "error: %s\n", msg);
}
```
- %token 开头定义**终结符号**（词法单元）
	- 不在这里的为非终结符号（至少在任意产生式的左边出现一次）
	- 如果需要采用 Flex 生成的 yylex()的话，那么在这里定义的词法单元都可以作为 Flex 源代码里的返回值
- 第一个生产式左边的非终结符号默认为初始符号（或者在开头定义使用 `%start X` 手动指定 X 为初始符号）
	- `:` 表示箭头。不同生产式用 `;` 分开。
	- 左边的非终结符的属性值用 `$$` 获取，右侧按照顺序为 `$i`
	- 动作使用花括号包住（默认为  `$$=S1`）
- 在 **Flex** 传递属性
```c
{digit}* {
	yylval = atoi(yytext);//属性
	return INT;//类型
}
```
##### 属性值的类型
- 不同符号对应的属性值可以为不同类型
- Bison 用 `YYSTYPE` 表示属性值的类型，用于全局（批量）的修改属性值的类型 `#define YYSTYPE float`，如果定义为一个联合体就可以实现访问不同类型的属性值
- 
##### 词法单元位置
- 
##### 二义性与冲突处理
- 
##### 错误恢复
- 
## 实验二：语义分析