- 目标：
	- 在目标代码中**消除不必要**的指令
	- 把一个指令序列替换为一个完成相同功能的**更快**的指令序列
- 优化的主要来源：通过一些相对**低层的语义等价**转换来优化代码
	- 公共子表达式消除
	- 复制传播
	- 死代码消除
	- 常量折叠
### 代码优化常见方法
>以快速排序为例进行说明
- 公共子表达式
	- 一个表达式在某次出现之前**必然被计算过**，并且在计算之后就**没有再改变过**
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240511230721.png)
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240511230838.png)
- 复制传播
	- 形如 u = v 的复制语句使得语句后面的程序点上，u 的值等于 v 的值
	- 如果在某个位置上一定有 u=v 那么就可以直接把 u 替换为 v。有时甚至可以完全消除对 u 的使用
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240511231300.png)
- 死代码消除
	- 如果一个变量在某个程序点上的值可能会在之后被使用，那么这个变量在这个点上活跃的；否则这个变量就是死的，此时对该变量的赋值就是没有用的死代码（死代码多半是因为前面的**优化而形成**的）
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240511231418.png)
- 代码移动
	- 循环中的代码会被执行很多次，如果循环内一个表达式在**不同迭代中值始终不变**，那么这就是一个循环不变表达式
	- 可以把循环不变表达式移动到循环入口之前
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240511231541.png)
- 归纳变量和强度
	- 每次对 x 赋值都使 x 增加 c，则可以把赋值改为**增量操作**，可消减计算强度
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240511231652.png)

### 数据流分析
- 用于获取数据沿着程序执行路径流动信息的相关技术
- 程序点：三地址语句之前/之后的位置；一个语句之后的程序点就是下一个语句之前的程序点
	- 构成一条执行路径 $P_{1},\dots,P_{n}$
	- 程序点的程序状态：指令指针指向这个程序点时各个变量和动态内存中存放的值
	- 程序点的特性：不管程序怎么运行，到达某个点时总是满足的状态
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240511232722.png)
#### 数据流分析模式
- **数据流值**表示了程序点具有的性质
	- 和某个程序点关联的数据流值就是程序运行中经过这个点时**必然满足的条件**
	- 某个数据流所有可能值的集合称为该数据流值的域
- 对一组约束求解，得到各个点上的数据流值
	- 基于**语句语义的约束**：一个语句之前和之后的数据流值受到其语义的约束；语句语义通常用传递函数表示，它把一个数据流值映射为另一个数据流值
	- 基于**控制流的约束**：在基本块内部，一个语句的输出 = 下一语句的输入
	- 使用 $OUR[s]$ 表示一个程序点的输出数据；$IN[s]$ 表示程序点的输入数据
- 一个基本块的控制流很简单：无分支，不会中断
- 传递函数：程序执行过程中的数据流关系 $OUT[s]=f_{s}(IN[s])$
	- 对于基本块语句 $s_{1},\dots s_{n}$ 有 $f_B=f_{s_n}\circ...\circ f_{s_2}\circ f_{s_1}$
- 前向数据流：
	- B 的传递函数根据 $IN[B]$ 计算得到 $OUT[B]$
	- $IN[B]$ 和 B 的各前驱基本块的 $OUT$ 值之间具有约束关系
	- ![image.png|275](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240512000257.png)
- 逆向数据流：
	- B 的传递函数根据 $OUT[B]$ 计算得到 $IN[B]$
	- $OUT[B]$ 和 B 的各后继基本块的 $IN$ 值之间具有约束关系
- 数据流方程通常没有唯一解, 目标是寻找一个最“精确”且**满足约束**的解 (在保证安全的同时保证代码的安全性)

- **到达定值**：只要一个定值能够沿某条路径到达一个程序点，这个定值就是到达定值
	- 假定 x 有定值 d，如果存在一个路径，从紧随 d 的点到达某点 p，并且此路径上面没有 x 的其他定值点（变量被赋值的语句），则称 x 的定值 d **到达 p**
	- 如果在这条路径上有对 x 的其它定值，我们说变量 x 的这个定值 d 被杀死了
	- 如果某个变量 x 的一个定值 d 到达了点 p，在 p 点使用变量 x 的时候，x 的值是由 d 最后定值的
- 为了保证安全：分析得到的到达定值**可能**实际上**不会到达**但是实际到达的**一定被分析出来**，否则不安全
- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240512001957.png)

- 对于定值 $d:u=v+w$
	- **生成**了对变量 $u$ 的定值 $d$，**杀死其它**对 $u$ 的定值
	- 生成-杀死：$f_{d}(x)=gen_{d}\bigcup (x-kill_{d})$
		- $gen_{d}$ 为新生成的定值 $d$
		- $x-kill_{d}$ 为旧的定值移除被（d）杀死的其他定值
	- 嵌套公式 $f_2(f_1(x))=gen_2\:\cup\:(gen_1\:\cup\:(x-kill_1)-kill_2)$
		- 生成的定值：由第二部分生成、以及由第一部分生成且没有被第二部分杀死
		- 杀死的定值：被第一部分杀死、以及被第二部分杀死的定值
	- 对于有 $n$ 个语句的 $B$，$f_{B}(x)=gen_{B}\:\cup\:(x-kill_{B})$
	- $\begin{aligned}&gen_{B}=gen_{n}\:\cup\:(gen_{n-1}-kill_{n})\:\cup\:...\:\cup\:(gen_{1}-kill_{2}-\\&kill_{3}-...-kill_{n})\end{aligned}$
	- $kill_B=kill_1\:\cup\:kill_2\:\cup\:...\:\cup\:kill_n$

- 控制流方程的迭代解法
	- $\mathrm{IN}[B]=\cup_{P\text{是}B\text{的前驱基本块}}\mathrm{OUT}[P]$
		- 如果从基本块 P 到 B 有一条控制流边，那么 $OUT[P]$ 在 $IN[B]$ 中
	- $\mathrm{OUT}[B]=gen_{B}\cup (\mathrm{IN}[B]-kill_{B})$
	- 先根据公式求解 $gen_{B}$ 和 $kill_{B}$ （块内）；令所有 $OUT[B]$ 为空集，不停迭代直到得到最小不动点的解
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240512005152.png)

### 部分冗余消除
### 循环的优化
- 