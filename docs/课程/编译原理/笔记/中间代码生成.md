### 中间代码表示
#### 表达式的 DAG
- 语法树中，**公共子表达式**每出现一次，就有一颗对应的子树
- 表达式的有向无环图能够**指出表达式中的公共子表达式**，更简洁地表示表达式
	- ![image.png|325](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240410010624.png)
- DAG 的构造
	- 用和构造抽象语法树一样的 SDD 来构造
	- 在函数 Leaf 和 Node 每次被调用时，构造新节点前先检查**是否存在同样的结点** (值编码+散列表)，如果**已存在，则返回这个已有结点**
[[docs/课程/编译原理/作业/p6#^f11a36|6.1.2]]
#### 三地址指令表示
- 三地址码
	- 每条指令右侧最多有一个运算符，即 `x=y op z`
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240410012128.png)
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240410012328.png)
- 对于 `do i = i + 1; while (a[i] < v);`
	- [![image.png|450](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240410012552.png)
- 在实现时，可使用**四元式/三元式/间接三元式/静态单赋值**来表示三地址指令
- 三元式 `op arg1 arg2`
	- x = y op z 需要拆分为两个式子 ![image.png|350](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240410013210.png)
	- ![image.png|475](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240410013233.png)
	- 优化时经常需要移动/删除/添加三元式，导致三元式运算**结果的位置变化**

- 四元式
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240410012858.png)
	- 单目运算符不使用 arg2；
	- param 运算不使用 arg 2 和 result
	- 条件/非条件**转移**将**目标**标号放在 result 字段
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240410012956.png)

- 间接三元式：解决三元式位置失效的问题
	- 包含了一个**指向三元式**的**指针的列表**，可对该列表进行操作 (**重新排序**)，完成优化功能，操作时**不影响三元式本身**
	- ![image.png|400](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240410013424.png)

- 静态单赋值
	- 所有赋值都是针对**具有不同名字的变量**
	- ![image.png|425](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240410013544.png)
	- 对于同一个变量在**不同路径**中定值的情况，可以使用**φ函数来合并**不同的定值
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240410013852.png)

[[docs/课程/编译原理/作业/p6#^a55c5f|6.2.2]]
### 类型和声明
- 利用一组规则来检查运算分量的类型和运算符的预期类型是否匹配
- 使用类型信息进行差错、确定内存空间、计算数组元素地址、类型转换、选择正确运算符等
#### 类型的表示
- 类型表达式
	- 基本类型+类型构造算子
	- 数组表示： `array(2, array(3, integer))` array 就是一个构造算子
	- 基本类型是一个类型表达式 `boolean,chair,...`
- 记录 `record` 包含名字段和数据结构，用于**将字段名和类型构造得到记录表达式**
- 如果 s 和 t 是类型表达式，其笛卡尔积 s × t 也是类型表达式 (描述**列表或元组**，如函数参数)
- `struct { int a[10]; float f; } ` 表示为 `record((a × array(0..9, int)) × (f × real))`

- 类型等价
	- 结构等价：由相同基本类型；相同构造算子用于结构等价的类型得到；类型别名
	- 名等价：类型名仅代表自身，两个类型如果**拥有相同的名称**，即被认为是名等价的。即使两个类型在结构上完全相同，如果它们的名称不同，它们在名等价的角度是不同的。
#### SDD 获取类型
- 变量的类型信息保存在符号表中
- 变量的类型确定了变量使用的内存（类型的宽度）
- 计算类型和宽度的 SDT
	- ![image.png|475](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240416223734.png)
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240416223758.png)

- 在处理一个过程/函数时，**局部变量应该放到单独的符号表中去**
- 这些变量的内存布局独立（**相对地址**即函数开始地址的距离从 0 开始，变量的放置和声明的顺序相同）
	- 使用 offset 记录当前可用相对地址，当分配变量后 offset 增加相应的值
	- ![image.png|475](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240416224114.png)

- 类型中的字段
	- 一个记录中各个字段的名字必须互不相同
	- 记录类型使用一个专用的符号表，对其各个字段的**类型和相对地址进行编码**
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240416224606.png)
	- 首先进入之前保存 top 指向的已有的符号表，然后创建新的符号表，并保存 offset，再重置为 0
	- 结束之后通过顾浩表 top 构建记录，并通过 offset 获取宽度，之后恢复环境
#### 类型转化和检查
- 
### 中间代码生成/翻译
- 将表达式翻译为三地址代码
	- code 表示代码
	- addr 表示存放表达式结果的地址
	- newTemp 生成临时变量
	- gen 生成指令
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240416225108.png)
- 增量式翻译方案
	- 不需要 code 指令保存已有的代码，而是对 gen 的连续调用生成一个**指令序列**
	- gen 不仅构造新的三地址指令，还要将它**添加到至今为止已生成的指令序列之后**
- 数组引用的翻译
	- 