### 中间代码表示
#### 表达式的 DAG
- 语法树中，**公共子表达式**每出现一次，就有一颗对应的子树
- 表达式的有向无环图能够**指出表达式中的公共子表达式**，更简洁地表示表达式
	- ![image.png|325](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240410010624.png)
- DAG 的构造
	- 用和构造抽象语法树一样的 SDD 来构造
	- 在函数 Leaf 和 Node 每次被调用时，构造新节点前先检查**是否存在同样的结点** (值编码+散列表)，如果**已存在，则返回这个已有结点**
[[docs/课程/编译原理/作业/p6#^f11a36|6.1.2]]
#### 三地址指令表示
- 三地址码
	- 每条指令右侧最多有一个运算符，即 `x=y op z`
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240410012128.png)
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240410012328.png)
- 对于 `do i = i + 1; while (a[i] < v);`
	- [![image.png|450](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240410012552.png)
- 在实现时，可使用**四元式/三元式/间接三元式/静态单赋值**来表示三地址指令
- 三元式 `op arg1 arg2`
	- x = y op z 需要拆分为两个式子 ![image.png|350](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240410013210.png)
	- ![image.png|475](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240410013233.png)
	- 优化时经常需要移动/删除/添加三元式，导致三元式运算**结果的位置变化**

- 四元式
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240410012858.png)
	- 单目运算符不使用 arg2；
	- param 运算不使用 arg 2 和 result
	- 条件/非条件**转移**将**目标**标号放在 result 字段
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240410012956.png)

- 间接三元式：解决三元式位置失效的问题
	- 包含了一个**指向三元式**的**指针的列表**，可对该列表进行操作 (**重新排序**)，完成优化功能，操作时**不影响三元式本身**
	- ![image.png|400](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240410013424.png)

- 静态单赋值
	- 所有赋值都是针对**具有不同名字的变量**
	- ![image.png|425](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240410013544.png)
	- 对于同一个变量在**不同路径**中定值的情况，可以使用**φ函数来合并**不同的定值
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240410013852.png)

[[docs/课程/编译原理/作业/p6#^a55c5f|6.2.2]]
### 类型检查

### 中间代码生成