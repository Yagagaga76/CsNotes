### 语法分析器
- 从词法分析器获得词法单元的序列，确认该序列是否可以由语言的文法生成
	- 对于语法错误的程序，报告错误信息
	- 对于语法正确的程序，生成语法分析树 (简称**语法树**)

- ![image.png|525](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240304153900.png)

### 上下文无关文法
- 程序设计语言构造的语法可使用上下文无关文法 (CFG) 或 BNF 表示法来描述
- **终结符号**： 这些是文法中的基本符号（**不能被进一步分解**），它们**直接对应**于语言的基本单位，即词法单元。
	- 在编程语言中，终结符号可以是**关键字、操作符、标识符、字面量等**。
- **非终结符号**： 非终结符号是文法中的**变量**，可以应用规则被替换为一系列终结符或非终结符的组合，代表字符串的集合。
- **开始符号**： 开始符号是一个**特别指定的非终结符号**，它代表整个文法的起点。
	- 开始符号是我们用来生成所有有效字符串的起点。
- **产生式**： 产生式定义了如何将终结符和非终结符组合成字符串。（定义了如何**将非终结符替换为终结符或其他非终结符的序列**）
	- 产生式有一个头部（左部），头部是一个非终结符号；有一个体部（右部），体部是由终结符和非终结符组成的符号串。产生式表达了非终结符通过替换能变成什么样的符号串。
	- 例如，产生式`expression → expression + term`意味着非终结符`expression`可以被替换为由`expression`、加号`+`和`term`组成的序列。
- ![image.png|450](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240304151542.png)
	- 简化表示 ![image.png|275](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240304151825.png)

- 推导：将待处理的串中的某个非终结符号**替换**为这个非终结符号的某个产生式的体。从开始符号出发，不断进行上面的替换，就可以得到文法的不同句型
- ![image.png|450](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240304152014.png)
- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240304152220.png)
	- 最左推导：**替换最左边的非终结符**。这意味着在每一步中，所有非终结符中最靠左的一个会被选中并用它的一个产生式进行替换。最左推导对应于**自顶向下解析**

- **句型**: 如果 S =>\* α，那么α就是文法 S 的句型. 可能既包含非终结符号，又包含终结符号，也可以是空串
- **句子**：不包含非终结符号的句型
- **语言**：文法 G 的语言就是 G 的**句子的集合**，记为 L(G)
	- ![image.png](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240306103527.png)
- 如何验证文法 G 所确定的语言 L
	- 证明 G 生成的每个串都在 L 中
	- 证明 L 中的每个串都能被 G 生成

#### 语法分析树
- 根结点的标号是文法的开始符号；叶子结点的标号是非终结符号、终结符号或ε；内部结点的标号是非终结符号，每个内部结点表示某个产生式的一次应用
- 树的叶子组成的序列是根的文法符号的一个**句型**，一棵语法分析树可对应多个推导序列
- ![image.png|400](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240304152840.png)

- 从推导序列构造分析树
	- ![image.png|475](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240304153301.png)

- 二义性：如果一个文法可以为某个句子生成多棵语法分析树，这个文法就是二义的
-  ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240304153225.png)
- 程序设计语言的文法通常是**无二义**的，否则就会导致一个程序有多种“正确”的解释
- 需要消二义性规则来剔除不要的语法分析树，需要更严格的文法限制
- [[docs/课程/编译原理/作业/p2#^7e4ebf|4.2.1]]
#### 上下文无关文法与正则表达式
- 上下文无关文法比正则表达式的**能力更强**
	- 所有的正则语言都可以使用文法描述
		- ![image.png|475](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240306102819.png)
		- ![image.png|475](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240306103004.png)
	- 但有一些用文法描述的语言不能用正则表达式描述
		- ![image.png|475](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240304154844.png)
		- 有穷自动机**只能有限计数**
#### 设计文法
- 文法能描述程序设计语言的**大部分语法**，但是有部分无法描述，因此语法分析器接受的语言是程序设计语言的超集，还需要通过语义分析来剔除一些不合法的程序
- 文法的**预处理**：
	- **消除二义性**
	- **消除左递归**：文法中一个非终结符号 A 使得对某个串α 存在推导 $A\overset{+}\rightarrow A\alpha$
		- 立即左递归 $A\to A\alpha$
	- **提取左公因子**

- 二义性的消除
	- 一些二义性文法可被改成等价的无二义性的文法，二义性的消除方法没有规律可循
	- 存在二义性的文法：![image.png|475](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240306110758.png)
	- ![image.png|475](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240306111005.png)
		- 这里拆分为了两种类型，使得 ifthen **只能出现在末尾**

- 左递归的消除
	- **自顶向下**的语法分析技术不能处理左递归的情况，因此需要消除左递归，但是自底向上的技术可以处理左递归
- 消除立即左递归：将左递归替换为右递归 ![image.png|425](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240306105532.png)
	- ![image.png|400](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240306105656.png)
- 消除（多步）左递归 ![image.png|300](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240306105753.png)
	- 更加通用的左递归消除
	![[Chapter_4.pdf#page=31&selection=0,0,0,10|Chapter_4, page 31]]
	- 基本思路是展开（**合并多步骤**）产生式，得到立即左递归式，再进行删除
- 预测分析法
	- 从开始符号**推导**出输入符号串，为**最左边**的非终结符号选择适当的产生式
	- 当两个产生式具有相同前缀时（有多个可能的产生式）无法预测
		- ![image.png|475](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240306112445.png)
- 提取左公因子: 用于**解决预测分析法的冲突**问题（**提取前缀**）
	- 输入：文法 G；输出：等价的提取了左公因子的文法
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240306112601.png)

### 语法分析技术

#### 自顶向下
- 从语法分析树的**根部**按照先根次序开始构造语法分析树
- 通常用于处理 LL 文法
- 对应于最左推导

- 基本步骤：
	- 确定对句型中最左边的非终结符号应用**哪个产生式**
	- 后对该产生式与输入符号进行匹配
- ![image.png|575](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240306112749.png)
##### 递归下降语法分析
- 递归下降语法分析：
	- 每个非终结符号对应于一个过程，该过程负责**扫描**此非终结符号对应的**结构**
	- ![image.png|450](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240306113213.png)
	- 这个过程是可能失败的，比如第 7 行（为终结符但是并不匹配）；第 4 行也可能出错。
	- 出现错误可能是由于**之前的选择错误**，也就是说 A 可能失败 (不是意味着输入一定不是句子)
		-  [[docs/课程/编译原理/作业/p2#^1afc12|例子]]
	- 在第 1 行保存当前的扫描指针，并把第 7/4 行改成 
		- 回退到保存的指针，并 GOTO 1) 去选择下一个产生式 
		- 如果没有下一个产生式可选，则报告错误
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240306113627.png) 

- 递归下降分析并不是完备的，因为 A 成功就退出了，没有尝试后面，这可能导致后面的 B 无法成功
- ![image.png|450](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240306114442.png)
- 在自顶向下的分析技术中，使用向前看几个符号来确定产生式 (通常只看一个符号)
  ##### FIRST 和 FOLLOW
- FIRST(a)
    - 可以从 a **推导得到**的串的**首符号**的集合
    - ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240306114616.png)
- 计算方法
    - ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240306114822.png)
    - ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240306115523.png)
- FOLLOW（A）
    - 可能在某些句型中紧跟在 A 右边的**终结符号**的集合
    - 如果 `A` 可以出现在句子的末尾，则还包括文法的结束符号 `EOF`（通常表示为 `$`）。
    - ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240306115150.png)
- 计算方法：按照下面两个规则不断**迭代**，直到所有的 FOLLOW 集合都**不再增长为止**（由于规则二产生的迭代）；将右端结束标记$加入 FOLLOW (S)中
    - ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240317214651.png)
        - 这里**计算的目标**是 $B$ 而不是 $A$
    - ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240306115544.png)
- [[docs/课程/编译原理/作业/p2#^cc87a2|4.4.4]]
##### 预测分析算法
- LL(1) 文法：
	- 可以构造出**预测分析器**，即不需要回溯的递归下降语法分析器。(可以根据当前输入的符号确定使用的产生式)
	- 条件：
		- $FIRST(\alpha)\bigcap FIRST(\beta)=\Phi$
		- 若 $\varepsilon \in FIRST(\beta)$ 则 $FIRST(\alpha)\bigcap FOLLOW(A)=\Phi$
	- LL(1)文法的名称中的 "LL" 表示这是一种 "从左到右扫描，最左推导" 的文法，而 "1" 表示解析器在做决策时最多只需要查看输入的下一个符号。

- 预测分析表构造算法：
	- 输入：文法 G；输出：**预测分析表**；
	- 对于每个生产式 $A\to \alpha$
		- 对 $FIRST(\alpha)$ 中的每个终结符 $a$ ，将 $A\to \alpha$ 加入到 $M[A,a]$
		- 若 $\varepsilon \in FIRST(\alpha)$，那么还要将 $FOLLOW(A)$ 中的 $b$ 将 $A\to \alpha$ 加入到 $M[A,b]$
	-  表示对于非终结符 $A$ 以及下一输入 $a$ 应该使用 $M[A,a]$ 中的生产式
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240317224244.png)
		- LL (1)文法是无二义性的，因此一个格子内只会有一个生产式
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240317224943.png)

- 非递归预测分析（只适用于 LL (1)语法）
	- 自顶向下分析中：
		- 先**匹配掉**句型中左边的所有**终结符号**；
		- 对于最左边的**非终结符号**选择适当的产生式**展开**
		- 匹配成功的终结符号不会再被考虑，只需要记住**句型余下的部分以及尚未匹配的输入终结符号串**
	- 使用栈来处理
		- ![image.png|300](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240317230537.png)
		- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240317230555.png)
		- 注意是将产生式的**右部按倒序压入**栈中
		- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240317230605.png)
##### 例题
-  [[docs/课程/编译原理/作业/p3#^4d0474|4.4.1]]
- [[docs/课程/编译原理/作业/p3#^8d3c9c|4.4.2]] 
#### 自底向上
- 从语法分析树的叶子开始构造语法分析树
- 使用移入-规约框架，通常用于处理 LR 文法（简单 LR 技术及 LR 技术）
- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240318094059.png)

- 自底向上语法分析的过程就可以看做从串**归约到文法开始符号**的过程
>规约：一个与某产生式体相匹配的特定子串被替换为该产生式**头部的非终结符号**
- 如何规约到正确的开始符号？可能会规约到**非句型**
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240318094546.png)

- 句柄
	- 最右句型（句子经过一系列最右推导得到）中能够匹配某个生产式右侧的式子，并且这个匹配代表了从这个最右句型回到其**直接前趋**的最右推导的**最后一步**。
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240318095956.png)
	- 在一个最右句型中，句柄右边只有终结符号
	- 如果文法没有二义性，那么每个句型有且只有一个句柄
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240318100206.png)
##### 移入-归约分析技术
- ![image.png|575](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240318100619.png)
	- **移入** (shift)：将下一个输入符号移入到栈顶
	- **归约** (reduce)：将句柄归约为相应的非终结符号
		- 句柄总是在栈顶
		- 弹出句柄，压入被归约到的非终结符号
	- **接受** (accept)：宣布分析过程成功完成
	- **报错** (error)：发现语法错误，调用错误恢复子程序

- 冲突
	- 对于有些不能使用移入-归约分析的文法，不管用什么样的移入-归约分析器都会到达这样的格局：即使知道了栈中所有内容、以及下面 k 个输入符号，人们仍然无法知道**是否该**进行归约 (**移入-归约冲突**)，或者不知道**按照什么产生式**进行归约 (**归约-归约冲突**)
	- ![image.png|475](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240318102111.png)
	- ![image.png|475](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240318102122.png)
##### LR 语法
- LR (k)语法：
	- L 表示最左扫描，R 表示反向构造出的最右推导，k 表示最多向前看 k 个字符
	- 当 k 增大时，相应的语法分析器的规模急剧增大：当 k = 0, 1 时，已经可以解决很多语法分析问题，因此具有实践意义
- 优点：
	- 表格驱动，可以自动生成
	- 对于几乎所有程序设计语言只要写出上下文无关文法就能构造出识别语言的 LR 语法分析器
	- 最通用的**无回溯移入-规约分析技术**
	- 可以比 LL (k)分析更多的文法

- LR（0）项
	- 项：文法的一个产生式加上在其中某处的 **一个点**
		- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240318103104.png)
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240318103125.png)
	- 点的前面是已经解析了的部分，后面是还没内有解析的部分
- **增广文法**
	- G 的 G‘增广文法是在 G 中增加了新开始符号 S'，并加入生产式 $S'\to S$
- **项集闭包** CLOSURE：如果 I 是文法 G 的一个项集，CLOSURE (I)就是根据下列两条规则从 I 构造得到的项集
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240318104636.png)
	- 之所以加入 $B\to \cdot r$ 是因为想匹配 $A\to \alpha \cdot B \beta$ 就需要 $B$ 而新加入的式子给出了一种得到 $B$ 的方法
	- ![image.png|475](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240318104946.png)
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240318104955.png)
- **GOTO 函数**
	- $I$ 是一个项集，$X$ 是一个文法符号，则 $GOTO(I,X)$ 定义为 $I$ 中所有形如 $[A\to \alpha \cdot X \beta]$ 的项**所对应的项**$[A\to \alpha X \cdot \beta]$ 的**集合闭包**
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240318105421.png)

- 求 LR (0)项集的规范族算法：从初始项集开始，不断计算各种可能的后继，直到生成所有的项集
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240318105733.png)
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240318105756.png)

##### LR (0)自动机
- 构造
	- 
- 作用
	- 
### 语法分析器生成工具