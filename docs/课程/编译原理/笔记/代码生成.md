- 任务
	- 指令选择：选择适当的指令实现 IR 语句
	- 寄存器的分配和指派
	- 指令排序：按照什么顺序安排指令的执行
- 输出 RISC、CISC 等
### 对目标机的约定（本实验中）
- 指令：
	- 加载：`LD dst, addr` (把地址 addr **中的内容**加载到 dst 所指的寄存器) 相当于进行了**解引用**
	- 保存：`ST x, r` (把寄存器 r 中的内容保存到 x 中)
	- 计算：`OP dst, src 1, src 2` (把 src 1 和 src 2 中的值运算后将结果存放到 dst 中)
	- 无条件跳转：`BR L` (控制流转向标号 L 的指令)
	- 条件跳转：`Bcond r, L` (对 r 中的值进行测试，如果为真则转向 L)
- 寻址模式
	- 变量 `x`：指向分配 x 的内存位置
	- `a (r)`：地址是 a 的左值加上寄存器 r 中的值
	- `constant (r) `：寄存器 r 中内容加上前面的常数即其地址
	- `*r `：寄存器 r 的内容所表示的位置上存放的内容位置
	- `*constant (r) `：寄存器 r 中内容加上常数所代表的位置上的内容所表示的位置
	- 常数 `#constant `
- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240511134033.png)
- ![|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240511130727.png)
- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240511130740.png)
- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240511130750.png)
- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240511130757.png)
- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240511134052.png)

#### 过程调用与返回
- 静态分配：
	- call：先 `ST callee.staticArea, #here + 20` 存储返回地址；然后 `BR callee.codeArea` 跳转到过程调用
	- return：`BR *callee.staticArea`
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240511132456.png)

- 栈式分配：
	- call：`ADD SP, SP, #caller.recordSize` 增大栈指针；`ST 0(SP), #here + 16` 保存返回地址；`BR callee.codeArea` 转移到被调用者
	- return：`BR *0(SP) ` 被调用者执行，返回调用者（返回地址）；`SUB SP, SP, #caller.recordSize` 调用者减小栈指针
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240511133136.png)
[[docs/课程/编译原理/作业/p10#^ae41a5|8.2.2&8.2.4]]
### 基本块和流图
- 将中间代码划分为**基本块**，控制流只能从基本块的第一条指令进入，除了基本块的最后一条指令，控制流不会进行跳转/停机
- **流图**的节点就是基本块，流图的边说明了基本块之间的运行关系
	- 指出了基本块之间的控制流，可以确认一个值是否会被使用
	- 是进行优化的基础
- 基本块的划分：三地址指令序列->基本块的列表
	- 首先找到首指令：**第一个三地址指令；转移指令的目标指令；转移指令之后的指令**
	- 每个首指令就对应一个基本块，块的范围就是从一个首指令开始到下一个首指令之前
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240511140045.png)
- 流图的构造
	- 两个节点之间存在一条边 $A\to B\iff$ B 的第一个指令可能在 A 的最后一个指令之后执行；称 A 为 B 的前驱；B 为 A 的后驱
	-  入（出）口节点：**入口到第一条指令**有一条边；任何可能**最后执行的基本块到出口**有一条边
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240511142213.png)

- 循环
	- **循环入口**：唯一的**前驱可以在循环 L 之外**的结点，到达其余结点的路径必然先经过这个入口结点；其余结点都存在到达入口结点的非空路径，且**路径都在 L 中**
	- 一个循环是流图中一个结点集合
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240511143636.png)

#### 优化
- 活跃性与后续使用
	- 设在语句 i 对 x 进行了赋值，若存在从 i 到 j 的路径并且路径上没有对 x 进行赋值、j 使用了 x 的值，就称 j 使用了 i 处计算得到的 x 的值
	- 即变量 x 在语句 i 后的程序点上**活跃**（x 在 i 时存放的**值**会被使用）
	- 可以用于寄存器优化等（即数据是否还需要存储，还有用吗）
- 确定基本块中的活跃性与后序使用
	- 对于基本块 𝐵 中的每个**非临时变量**，初始时认为它们在块的末尾是**活跃的**。
	- 从基本块 𝐵 的末尾开始，逐条**反向检查**每条语句。
	- 对于每个语句 i：x = y + z：
		- **更新 𝑥**：将 𝑥 设置为“不活跃”，因为 𝑥 的旧值在此语句之后不再被使用；
		- **更新 𝑦 和 𝑧**：将 𝑦 和 𝑧 设置为“活跃”，此更新反映了在当前语句中使用了 𝑦 和 𝑧 的值。
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240511141312.png)
##### DAG 优化
- DAG 图可反映变量及其值对其他变量的依赖关系 (各变量的值之间的关系)
- 使用 DAG 可以实现
	- 寻找局部公共子表达式
	- 消除死代码
	- 代数恒等式的使用
	- 数组引用的表示
	- 指针赋值和过程调用

- DAG 图的建立
	- **每个变量**都有一个对应的 DAG 结点表示其**初始值**
	- **每个语句** s 有一个相关的结点 N，代表此计算得到的值；节点 𝑁 的子节点是构成该语句的运算分量的当前值。在 `x = y + z` 的例子中，𝑦 和 𝑧 将是 𝑁 的子节点。
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240511170459.png)
	- 扫描结束后，对所有在出口处活跃的变量 x，将 x 所关联的结点设置为输出结点
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240511170942.png)

- 局部公共子表达式
	- 建立某个结点 M 之前，检查是否存在一个结点 N，它和 M **具有相同的运算符和子结点**
	- 如果存在则可以直接使用 N 来代表 M，不再需要生成新的节点
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240511171224.png)
	- （b+c）不是，因为 b 的值改变了
- 消除死代码
	- 在 DAG 图上**消除没有附加活跃变量**（未来使用如作为返回值或输出等）的**根结点**，即消除死代码
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240511171500.png)
- 代数恒等式优化
	- 恒等式：$x + 0 = 0 + x = x, x – 0 = x$ 等
	- 简化运算 $x^2=x*x,x/2=x*0.5$ 等
	- 常量编译时计算、合并
	- 利用代数规则（交换律、结合律）
- 数组引用
	- 数组有两种操作：
		- 取数：`=[]` 左子节点为数组（起始）地址 $a$，右子节点为下标 $i$
		- 存数：`[]=`
- 指针赋值和过程调用
	- 

- 从 DAG 到基本块的重组
	- 
### 代码生成算法
- 根据三地址指令序列生成机器指令