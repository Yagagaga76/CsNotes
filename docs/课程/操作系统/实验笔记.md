## AbstractMachine
- 一个抽象层，为 c 语言提供运行环境，简化了系统的开发方式，使得可以用编写 c 语言的方式来编写操作系统
- 提供 5 组 (15 个) 主要 API，可以实现各类系统软件 (如操作系统)：
	- (TRM) `putch` / `halt` - 最基础的**计算、显示和停机**
	- (IOE) `ioe_read/ioe_write` - **I/O** 设备管理
	- (CTE) `ienabled` / `iset` / `yield` / `kcontext` - **中断和异常**
	- (VME) `protect`/`unprotect`/`map`/`ucontext` - **虚存管理**
	- (MPE) `cpu_count` / `cpu_current` / `atomic_xchg` - **多处理器**
### 什么是裸机 bare-metal 编程
```c
// say.c
void putch(char ch);
int putchar(int ch);

void say(const char *s) {
  for (; *s; s++) {
#ifdef __ARCH__
    putch(*s); // AbstractMachine，没有 libc，调用 TRM API 打印字符
#else
    putchar(*s); // 操作系统，调用 libc 打印字符
#endif
  }
}
```
#### c 程序如何运行起来
- 在**操作系统**上
- 在程序连接时 gcc 替我们完成了很多事情 `gcc main.o say.o`
```
$ ld -dynamic-linker /lib64/ld-linux-x86-64.so.2 \
  /usr/lib/x86_64-linux-gnu/crt1.o \
  /usr/lib/x86_64-linux-gnu/crti.o \
  main.o say.o -lc \
  /usr/lib/x86_64-linux-gnu/crtn.o
```
- `ld-linux-x86-64.so` 负责动态链接库的加载；- `crt*.o` 是 C Runtime 的缩写，即 C 程序运行所必须的一些环境，例如程序的入口函数 `_start` (二进制文件并不是从 `main` 开始执行的！)、`atexit` 注册回调函数的执行等；- `-lc` 表示链接 glibc。**链接后得到一个 ELF 格式的可执行文件**
- 加载与执行：
	- Shell 接收到命令后，在操作系统中使用 `fork()` 创建一个**新的进程**。
	- 在子进程中使用 `execve()` 加载 `a.out`。操作系统内核中的加载器识别出 `a.out` 是一个动态链接文件，做出必要的内存映射
	- 程序运行过程中，如需进行输入/输出等操作 (如 libc 中的 `putchar`)，则会使用特殊的指令 (例如 x86 系统上的 `int` 或`syscall`) 发出系统调用请求操作系统执行。

- 在 **AbstractMachine** 上
- 只链接了 `main.o`, `say.o` 和必要的库函数 (AbstractMachine 和 klib；
	- 创建了 `hello-x86_64-qemu` 的镜像文件，镜像文件是由 512 字节的 “MBR”、1024 字节的空白 (用于存放 `main` 函数的参数) 和 `hello-x86_64-qemu.o` 组成的。用 `file` 类型可以识别出它：
- 生成后的程序不能直接在操作系统上运行，需要在 bare-metal 上加载它
- ``
### 设计概述
- 
### 规约
- 
### 封装库函数 klib
- klib：自定义的 glib 库，用于打包常用 API，如用 printf 打包系统的 putch，要注意多线程安全等问题，使用 assertion 多加检查