### 操作系统的进程管理
- 操作系统初始化阶段加载了**第一个进程**
- 操作系统是状态机的管理者
- fork-exevce-exit 构成了 unix 中的进程世界
#### 进程的创建 -fork
- `pid_t fork(void);` 创建**当前线程的完整克隆**
	- 是对当前进程（状态机）的完整复制（内存、寄存器现场等）
	- 父进程会收到返回值为子进程的进程号
	- 子进程收到返回值 0
	- 返回值（RAX）就是两个线程的唯一区别
- ![image.png|475](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240422160834.png)

```c
pid_t x = fork();
pid_t y = fork();
printf("%d %d\n", x, y);
```
- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240422162713.png)

#### 执行可执行文件-execve
- `int execve(const char *filename,char * const argv[], char * const envp[]);`
	- “重置“状态机，将当前进程重置为一个可执行文件描述的状态机的初始状态（**一个可执行文件实际就描述了一个状态机的初始状态**）
- 应用程序的执行环境 `env`
	- `PATH`: 可执行文件搜索路径
	- `PWD`: 当前路径
	- `HOME`: home 目录
	- `DISPLAY`: 图形输出
	- `PS1`: shell 的提示符
```c
int main() {
    char *const argv[] = {
        "/bin/bash",
        "-c",
        "env",
        NULL,
    };

    char *const envp[] = {
        "HELLO=WORLD",
        NULL,
    };

    // Reset the state machine to "/bin/bash"
    execve(argv[0], argv, envp);

    // We are here only on error.
    printf("Hello, World!\n");
}

```

- fork+execve
	- 执行新程序的常见使用方式
	- fork 创建子进程，使用 execve 将子进程初始化为目标可执行文件对应的状态机
```c
int pid = fork();
if (pid == -1) {
    perror("fork"); goto fail;
} else if (pid == 0) {
    // Child
    execve(...);
    perror("execve"); goto fail;
} else {
    // Parent
    ...
}
```
#### 退出程序-\_exec
- **主动**销毁进程
- `void _exit(int status);`
	- 立即摧毁状态机，允许有一个返回值 (子进程会通知父进程)
	- 会终止进程中的所有线程
- C 语言提供的退出方式
	- return main 函数
	- exit (num)
	- 这两种否会调用 atexit，可以做一些退出之前的处理
- 操作系统提供的退出方式
	- `_exit(num)`
	- `syscall(SYS_exit,0)`
	- 会直接终止进程，buhu 8 i 调用 atexit
```c
void func() {
    printf("Goodbye, Cruel OS World!\n");
}

int main(int argc, char *argv[]) {
    // This is a convenient mechanism for 
    atexit(func);
	//c语言提供的方式
    if (argc < 2) {
        return EXIT_FAILURE;
    }
    if (strcmp(argv[1], "exit") == 0) {
        exit(0);
    }
	//操作系统提供的方式
    if (strcmp(argv[1], "_exit") == 0) {
        _exit(0);
    }
    if (strcmp(argv[1], "__exit") == 0) {
        syscall(SYS_exit, 0);
    }
}
```
### 进程地址空间
- 查看进程的地址空间及权限 `/proc/[pid]/maps
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240422175406.png)
#### \*vdso
- 一段运行在用户空间的代码，允许一些特定的系统调用（如获取时间）避免进行上下文切换到内核态，可以调高执行的效率
- vDSO通过将一小段代码**映射到用户进程的地址空间**来工作。这段代码实现了一些系统调用的功能。当应用程序需要执行某些系统调用时，它可以直接调用这些已映射到用户空间的函数，而无需执行完整的系统调用过程。