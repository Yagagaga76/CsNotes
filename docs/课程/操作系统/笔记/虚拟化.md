### 操作系统的进程管理
- 操作系统初始化阶段加载了**第一个进程**
- 操作系统是状态机的管理者
- fork-exevce-exit 构成了 unix 中的进程世界
#### 进程的创建 -fork
- `pid_t fork(void);` 创建**当前线程的完整克隆**
	- 是对当前进程（状态机）的完整复制（内存、寄存器现场等）
	- 父进程会收到返回值为子进程的进程号
	- 子进程收到返回值 0
	- 返回值（RAX）就是两个线程的唯一区别
- ![image.png|475](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240422160834.png)

```c
pid_t x = fork();
pid_t y = fork();
printf("%d %d\n", x, y);
```
- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240422162713.png)

#### 执行可执行文件-execve
- `int execve(const char *filename,char * const argv[], char * const envp[]);`
	- “重置“状态机，将当前进程重置为一个可执行文件描述的状态机的初始状态（**一个可执行文件实际就描述了一个状态机的初始状态**）
- 应用程序的执行环境 `env`
	- `PATH`: 可执行文件搜索路径
	- `PWD`: 当前路径
	- `HOME`: home 目录
	- `DISPLAY`: 图形输出
	- `PS1`: shell 的提示符
```c
int main() {
    char *const argv[] = {
        "/bin/bash",
        "-c",
        "env",
        NULL,
    };

    char *const envp[] = {
        "HELLO=WORLD",
        NULL,
    };

    // Reset the state machine to "/bin/bash"
    execve(argv[0], argv, envp);

    // We are here only on error.
    printf("Hello, World!\n");
}

```

- fork+execve
	- 执行新程序的常见使用方式
	- fork 创建子进程，使用 execve 将子进程初始化为目标可执行文件对应的状态机
```c
int pid = fork();
if (pid == -1) {
    perror("fork"); goto fail;
} else if (pid == 0) {
    // Child
    execve(...);
    perror("execve"); goto fail;
} else {
    // Parent
    ...
}
```
#### 退出程序-\_exec
- **主动**销毁进程
- `void _exit(int status);`
	- 立即摧毁状态机，允许有一个返回值 (子进程会通知父进程)
	- 会终止进程中的所有线程
- C 语言提供的退出方式
	- return main 函数
	- exit (num)
	- 这两种否会调用 atexit，可以做一些退出之前的处理
- 操作系统提供的退出方式
	- `_exit(num)`
	- `syscall(SYS_exit,0)`
	- 会直接终止进程，buhu 8 i 调用 atexit
```c
void func() {
    printf("Goodbye, Cruel OS World!\n");
}

int main(int argc, char *argv[]) {
    // This is a convenient mechanism for 
    atexit(func);
	//c语言提供的方式
    if (argc < 2) {
        return EXIT_FAILURE;
    }
    if (strcmp(argv[1], "exit") == 0) {
        exit(0);
    }
	//操作系统提供的方式
    if (strcmp(argv[1], "_exit") == 0) {
        _exit(0);
    }
    if (strcmp(argv[1], "__exit") == 0) {
        syscall(SYS_exit, 0);
    }
}
```
### 进程地址空间
- 查看进程的地址空间及权限 `/proc/[pid]/maps
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240422175406.png)
	- 地址范围|权限|偏移量|设备|innode（对应文件）|路径名或标记
#### \*vdso
- 一段运行在用户空间的代码，允许一些特定的系统调用（如获取时间）避免进行上下文切换到内核态，可以调高执行的效率（尤其是调用频繁的系统调用）
- vDSO 通过将一小段代码**映射到用户进程的地址空间**来工作。这段代码实现了一些系统调用的功能。当应用程序需要执行某些系统调用时，它可以直接调用这些已映射到用户空间的函数，而无需执行完整的系统调用过程。
#### 管理进程的地址空间
- 增加、删除、修改可访问的内存，进行内存申请等工作
- `mmap` 系统调用用于将设备或文件映射到内存中，从而**创建**一块可以直接通过指针访问的内存区域。
	- `void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);`
	- `addr`: 希望映射区域的首选起始地址。通常设为 NULL，由系统选择映射区域的地址。
	- `length`: 映射区域的长度。
	- `prot`: 映射区域的保护权限。可以是以下几个值的组合：
	    - `PROT_READ`: 可读。
	    - `PROT_WRITE`: 可写。
	    - `PROT_EXEC`: 可执行。
	    - `PROT_NONE`: 不可访问。
	- `flags`: 控制映射的行为。常见的标志包括：
	    - `MAP_FIXED`: 使用指定的`addr`精确地址；如果地址已被使用，会替换原有的映射。
	    - `MAP_SHARED`: 对映射的修改会反映到底层文件上，并且对其他所有映射同一文件的进程可见。
	    - `MAP_PRIVATE`: 对映射区域的写入不会写回到原文件，而是创建一个写时复制的私有副本。
	- `fd`: 要映射的文件的文件描述符。若是创建匿名映射，则设为-1。
	- `offset`: 文件中的偏移，映射从文件的这个偏移开始。
```c
volatile uint8_t *p = mmap(
        NULL,
        8 GiB,//宏定义的
        PROT_READ | PROT_WRITE,
        MAP_ANONYMOUS | MAP_PRIVATE,
        -1, 0
    );
```

- `munmap` 函数用于**取消**映射的内存区域，释放这部分区域。
	- `int munmap(void *addr, size_t length);`
	- `addr`: 映射区域的起始地址。
	- `length`: 映射区域的长度。

- `mprotect` 函数用于**修**改现有内存区域的保护权限。
	- `int mprotect(void *addr, size_t length, int prot);`
	- `addr`: 需要修改权限的内存区域的起始地址。
	- `length`: 需要修改权限的内存区域的长度。
	- `prot`: 新的保护权限，同 `mmap` 中的保护权限。
#### 入侵进程的地址空间
- 一个进程对其他的地址进行访问，就可以任意改变另一个程序的行为
- 如何查找变量的存储空间（金山游侠）
	- 让目标变量发生变化，查找发生了相同变化的内存，直至能唯一确定
	- 之后直接对内存的数据进行修改
- 给进程发送虚假信号（按键精灵）
	- 如发送 gui 事件（鼠标键盘）
- 改变进程对时间的感知（变速齿轮）
	- syscall：gettimeofday，sleep（用于等待时间）
	- 将 syscall 链接到自定义的方法（hook 函数的执行）
	- 应用：软件动态更新
### 系统调用和 UNIX Shell
#### 操作系统对象
- everything is a file
- 操作系统中的对象要么是**一个文件**要么是**一个字节流**，通过指针（windows 中称为 handle）访问一切
	- 定义（重要）：**文件描述符是指向操作系统对象的指针**

##### 管道与匿名管道
- 一种进程间同步机制 IPC

- 管道：**特殊文件流**
	- 由读者和写者共享
	- 读口支持 read；写口支持 write
```c
#define PIPE_NAME "/tmp/my_pipe"
void pipe_read() {
    int fd = open(PIPE_NAME, O_RDONLY);
    char buffer[1024];
    if (fd == -1) {
        perror("open");
        exit(1);
    }
    // Read from the pipe
    int num_read = read(fd, buffer, sizeof(buffer));
    if (num_read > 0) {
        printf("Received: %s\n", buffer);
    } else {
        printf("No data received.\n");
    }
    close(fd);
}
void pipe_write(const char *content) {
    // Open the pipe for writing
    int fd = open(PIPE_NAME, O_WRONLY);
    if (fd == -1) {
        perror("open");
        exit(1);
    }
    // Write the message to the pipe
    write(fd, content, strlen(content) + 1);
    close(fd);
}
int main(int argc, char *argv[]) {
    if (argc < 2) {
        fprintf(stderr, "Usage: %s read|write [message]\n", argv[0]);
        return 1;
    }
    // Create the named pipe if it does not exist
    if (mkfifo(PIPE_NAME, 0666) == -1) {
        if (errno != EEXIST) {
            perror("mkfifo");
            return 1;
        }
    }
    if (strcmp(argv[1], "read") == 0) {
        pipe_read();
    } else if (strcmp(argv[1], "write") == 0) {
        pipe_write(argv[2]);
    } else {
        fprintf(stderr, "Invalid command. Use 'read' or 'write'.\n");
        return 1;
    }
    return 0;
}

```
- 匿名管道 `int pipe (int pipefd[2]);`
	- 返回两个文件描述符
	- 适用于父子进程通信（如 fork 的），根据 fork 的返回值决定使用哪一个口
	- ![image.png|350](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240423104933.png)
```c
void do_parent(int fd) {
    const char *msg = "Hello, world!";
    printf("[%d] Write: '%s'\n", getpid(), msg);
    write(fd, msg, strlen(msg) + 1);
    close(fd);
    // Wait for the child to finish
    wait(NULL);
    printf("[%d] Done.\n", getpid());
}

void do_child(int fd) {
    static char buf[1024];
    ssize_t num_read = read(fd, buf, sizeof(buf));
    if (num_read == -1) {
        perror("read");
        exit(EXIT_FAILURE);
    }
    printf("[%d] Got: '%s'\n", getpid(), buf);
    // Close the read end of the pipe
    close(fd);
}

int main() {
    int pipefd[2];
    // Create a pipe
    if (pipe(pipefd) == -1) {
        perror("pipe");
        exit(EXIT_FAILURE);
    }
    // Fork the current process
    pid_t pid = fork();
    if (pid == -1) {
        perror("fork");
        exit(EXIT_FAILURE);
    }
    if (pid == 0) {
        // Child
        close(pipefd[1]); // Close unused write end
        do_child(pipefd[0]);
    } else {
        // Parent
        close(pipefd[0]); // Close unused read end
        do_parent(pipefd[1]);
    }
    return 0;
}
```
### Unix Shell
