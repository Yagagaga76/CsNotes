### 操作系统的进程管理
- 操作系统初始化阶段加载了**第一个进程**
- 操作系统是状态机的管理者
- fork-exevce-exit 构成了 unix 中的进程世界
#### 进程的创建 -fork
- `pid_t fork(void);` 创建**当前线程的完整克隆**
	- 是对当前进程（状态机）的完整复制（内存、寄存器现场等）
	- 父进程会收到返回值为子进程的进程号
	- 子进程收到返回值 0
	- 返回值（RAX）就是两个线程的唯一区别
- ![image.png|475](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240422160834.png)

```c
pid_t x = fork();
pid_t y = fork();
printf("%d %d\n", x, y);
```
- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240422162713.png)

#### 执行可执行文件-execve
- `int execve(const char *filename,char * const argv[], char * const envp[]);`
	- “重置“状态机，将当前进程重置为一个可执行文件描述的状态机的初始状态（**一个可执行文件实际就描述了一个状态机的初始状态**）
- 应用程序的执行环境 `env`
	- `PATH`: 可执行文件搜索路径
	- `PWD`: 当前路径
	- `HOME`: home 目录
	- `DISPLAY`: 图形输出
	- `PS1`: shell 的提示符
```c
int main() {
    char *const argv[] = {
        "/bin/bash",
        "-c",
        "env",
        NULL,
    };

    char *const envp[] = {
        "HELLO=WORLD",
        NULL,
    };

    // Reset the state machine to "/bin/bash"
    execve(argv[0], argv, envp);

    // We are here only on error.
    printf("Hello, World!\n");
}

```

- fork+execve
	- 执行新程序的常见使用方式
	- fork 创建子进程，使用 execve 将子进程初始化为目标可执行文件对应的状态机
```c
int pid = fork();
if (pid == -1) {
    perror("fork"); goto fail;
} else if (pid == 0) {
    // Child
    execve(...);
    perror("execve"); goto fail;
} else {
    // Parent
    ...
}
```
#### 退出程序-\_exec
- **主动**销毁进程
- `void _exit(int status);`
	- 立即摧毁状态机，允许有一个返回值 (子进程会通知父进程)
	- 会终止进程中的所有线程
- C 语言提供的退出方式
	- return main 函数
	- exit (num)
	- 这两种否会调用 atexit，可以做一些退出之前的处理
- 操作系统提供的退出方式
	- `_exit(num)`
	- `syscall(SYS_exit,0)`
	- 会直接终止进程，buhu 8 i 调用 atexit
```c
void func() {
    printf("Goodbye, Cruel OS World!\n");
}

int main(int argc, char *argv[]) {
    // This is a convenient mechanism for 
    atexit(func);
	//c语言提供的方式
    if (argc < 2) {
        return EXIT_FAILURE;
    }
    if (strcmp(argv[1], "exit") == 0) {
        exit(0);
    }
	//操作系统提供的方式
    if (strcmp(argv[1], "_exit") == 0) {
        _exit(0);
    }
    if (strcmp(argv[1], "__exit") == 0) {
        syscall(SYS_exit, 0);
    }
}
```
### 进程地址空间
- 查看进程的地址空间及权限 `/proc/[pid]/maps
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240422175406.png)
	- 地址范围|权限|偏移量|设备|innode（对应文件）|路径名或标记
#### \*vdso
- 一段运行在用户空间的代码，允许一些特定的系统调用（如获取时间）避免进行上下文切换到内核态，可以调高执行的效率（尤其是调用频繁的系统调用）
- vDSO 通过将一小段代码**映射到用户进程的地址空间**来工作。这段代码实现了一些系统调用的功能。当应用程序需要执行某些系统调用时，它可以直接调用这些已映射到用户空间的函数，而无需执行完整的系统调用过程。
#### 管理进程的地址空间
- 增加、删除、修改可访问的内存，进行内存申请等工作
- `mmap` 系统调用用于将设备或文件映射到内存中，从而**创建**一块可以直接通过指针访问的内存区域。
	- `void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);`
	- `addr`: 希望映射区域的首选起始地址。通常设为 NULL，由系统选择映射区域的地址。
	- `length`: 映射区域的长度。
	- `prot`: 映射区域的保护权限。可以是以下几个值的组合：
	    - `PROT_READ`: 可读。
	    - `PROT_WRITE`: 可写。
	    - `PROT_EXEC`: 可执行。
	    - `PROT_NONE`: 不可访问。
	- `flags`: 控制映射的行为。常见的标志包括：
	    - `MAP_FIXED`: 使用指定的`addr`精确地址；如果地址已被使用，会替换原有的映射。
	    - `MAP_SHARED`: 对映射的修改会反映到底层文件上，并且对其他所有映射同一文件的进程可见。
	    - `MAP_PRIVATE`: 对映射区域的写入不会写回到原文件，而是创建一个写时复制的私有副本。
	- `fd`: 要映射的文件的文件描述符。若是创建匿名映射，则设为-1。
	- `offset`: 文件中的偏移，映射从文件的这个偏移开始。
```c
volatile uint8_t *p = mmap(
        NULL,
        8 GiB,//宏定义的
        PROT_READ | PROT_WRITE,
        MAP_ANONYMOUS | MAP_PRIVATE,
        -1, 0
    );
```

- `munmap` 函数用于**取消**映射的内存区域，释放这部分区域。
	- `int munmap(void *addr, size_t length);`
	- `addr`: 映射区域的起始地址。
	- `length`: 映射区域的长度。

- `mprotect` 函数用于**修**改现有内存区域的保护权限。
	- `int mprotect(void *addr, size_t length, int prot);`
	- `addr`: 需要修改权限的内存区域的起始地址。
	- `length`: 需要修改权限的内存区域的长度。
	- `prot`: 新的保护权限，同 `mmap` 中的保护权限。
#### 入侵进程的地址空间
- 一个进程对其他的地址进行访问，就可以任意改变另一个程序的行为
- 