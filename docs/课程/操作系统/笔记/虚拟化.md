### 什么是虚拟化
#### 共享 CPU
- 通过**虚拟化** CPU、内存等硬件，让一个进程只运行一个时间片（**分时共享**），然后切换到其他进程，操作系统提供了一个假象，使得较多的进程可以运行在有限的资源上
- 进程的组成（机器状态）：
	- 内存（地址空间）：指令+数据
	- 寄存器：程序计数器，栈指针等

- 进程的状态
	- 运行（running）：在运行状态下，进程正在处理器上运行。这意味着它**正在执行指令**。
	- 就绪（ready）：在就绪状态下，进程已**准备好**运行，但由于某种原因，操作系统选择不在此时运行。
	- 阻塞（blocked）：在阻塞状态下，一个进程执行了某种操作，直到发生其他事件时才会准备运行。一个常见的例子是，当进程向磁盘发起 I/O 请求时，它会被阻塞，因此其他进程可以使用处理器。
	- ![image.png|300](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240427140800.png)
#### 共享内存
- 地址空间：运行的程序看到的系统中的内存
- 操作系统通过虚拟内存，使得程序认为它被加载到特定地址的内存中，并且具有非常大的地址空间
- 虚拟内存系统的目标：
	- **透明**：操作系统实现虚拟内存的方式，应该让运行的程序看不见。（不应感知到内存被虚拟化）
	- 效率：时间&空间（不会更慢，不需要太多额外存储）
	- 保护：确保进程收到保护（不会受到其他进程的映像），操作系统本身更不应该受到进程的影响
### 操作系统的进程管理
- 操作系统初始化阶段加载了**第一个进程**
- 操作系统是状态机的管理者
- fork-exevce-exit 构成了 unix 中的进程世界
#### 进程的概念
- 进程由三部分组成：程序代码段、数据段、PCB（进程控制块）
- PCB：
	- 系统通过 PCB 了解进程的信息，在进程执行结束时回收 PCB
	- 主要包含了：进程描述信息（进程标识符、用户标识符等）、进程控制和管理信息（描述进程运行状态，作为 CPU 调度的依据）、资源分配信息、处理机相关信息（CPU 寄存器等上下文信息）
- 进程的状态：
	- 运行态：正在 CPU 上运行
	- 就绪态：获得了除了 CPU 以外的全部资源，得到 CPU 就可以开始运行了（这个时间通常很短  ）
	- 阻塞态：正在等待某一个事件而暂停（如 IO, 等待除了 CPU 之外的资源）
	- 创建态：正在被创建（步骤：创建 PCB，分配资源，转入就绪）
	- 终止态：正在消失，如运行结束，还需要进行资源释放回收等操作
- 进程的状态转换：
	- ![463e0d7ab0c39a28a579dd206f2a7a7.jpg|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/463e0d7ab0c39a28a579dd206f2a7a7.jpg)

- 进程的管理方式
	- 连接方式：将相同状态的 PCB 连接成一个队列
	- 索引方式：将同一状态的进程组织在一个索引表
#### 进程的创建 -fork
- `pid_t fork(void);` 创建**当前线程的完整克隆**
	- 是对当前进程（状态机）的完整复制（内存、寄存器现场等）
	- 父进程会收到返回值为子进程的进程号
	- 子进程收到返回值 0
	- 返回值（RAX）就是两个线程的唯一区别
- ![image.png|475](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240422160834.png)

- 具体过程
	- 分配进程标识号，申请空白 PCB
	- 分配其他资源，如内存，IO 设备等
	- 初始化 PCB，信息
	- 插入就绪队列等待调度

```c
pid_t x = fork();
pid_t y = fork();
printf("%d %d\n", x, y);
```
- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240422162713.png)

#### 执行可执行文件-execve
- `int execve(const char *filename,char * const argv[], char * const envp[]);`
	- “重置“状态机，将当前进程重置为一个可执行文件描述的状态机的初始状态（**一个可执行文件实际就描述了一个状态机的初始状态**）
- 应用程序的执行环境 `env`
	- `PATH`: 可执行文件搜索路径
	- `PWD`: 当前路径
	- `HOME`: home 目录
	- `DISPLAY`: 图形输出
	- `PS1`: shell 的提示符
```c
int main() {
    char *const argv[] = {
        "/bin/bash",
        "-c",
        "env",
        NULL,
    };

    char *const envp[] = {
        "HELLO=WORLD",
        NULL,
    };

    // Reset the state machine to "/bin/bash"
    execve(argv[0], argv, envp);

    // We are here only on error.
    printf("Hello, World!\n");
}

```

- fork+execve
	- 执行新程序的常见使用方式
	- fork 创建子进程，使用 execve 将子进程初始化为目标可执行文件对应的状态机
```c
int pid = fork();
if (pid == -1) {
    perror("fork"); goto fail;
} else if (pid == 0) {
    // Child
    execve(...);
    perror("execve"); goto fail;
} else {
    // Parent
    ...
}
```
#### 终止进程-\_exit
- **主动**销毁进程
- `void _exit(int status);`
	- 立即摧毁状态机，允许有一个返回值 (子进程会通知父进程)
	- 会终止进程中的所有线程
- C 语言提供的退出方式
	- return main 函数
	- exit (num)
	- 这两种否会调用 atexit，可以做一些退出之前的处理
- 操作系统提供的退出方式
	- `_exit(num)`
	- `syscall(SYS_exit,0)`
	- 会直接终止进程，buhu 8 i 调用 atexit

- 具体过程：
	- 根据标识符检索 PCB
	- 终止进程执行（如果在运行态）
	- 释放资源（归还给父进程或操作系统）
	- 将 PCB 从所在链表移除
```c
void func() {
    printf("Goodbye, Cruel OS World!\n");
}

int main(int argc, char *argv[]) {
    // This is a convenient mechanism for 
    atexit(func);
	//c语言提供的方式
    if (argc < 2) {
        return EXIT_FAILURE;
    }
    if (strcmp(argv[1], "exit") == 0) {
        exit(0);
    }
	//操作系统提供的方式
    if (strcmp(argv[1], "_exit") == 0) {
        _exit(0);
    }
    if (strcmp(argv[1], "__exit") == 0) {
        syscall(SYS_exit, 0);
    }
}
```
### 进程间通信方式
- 共享内存：区别于线程，默认下进程的地址空间是相互隔离的，因此需要通过特殊的系统调用获取
- 消息队列：操作系统提供的消息接受和发送方式
- 管道通信：特殊的共享文件，先进先出, 按照生产者消费者模式进行通讯
### 进程地址空间
- 查看进程的地址空间及权限 `/proc/[pid]/maps
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240422175406.png)
	- 地址范围|权限|偏移量|设备|innode（对应文件）|路径名或标记
- 或者使用 `pmap` 命令查看管局进程的内存使用信息
#### \*vdso
- 一段运行在用户空间的代码，允许一些特定的系统调用（如获取时间）避免进行上下文切换到内核态，可以调高执行的效率（尤其是调用频繁的系统调用）
- vDSO 通过将一小段代码**映射到用户进程的地址空间**来工作。这段代码实现了一些系统调用的功能。当应用程序需要执行某些系统调用时，它可以直接调用这些已映射到用户空间的函数，而无需执行完整的系统调用过程。
#### 管理进程的地址空间
- 增加、删除、修改可访问的内存，进行内存申请等工作
- `mmap` 系统调用用于将设备或文件映射到内存中，从而**创建**一块可以直接通过指针访问的内存区域。
	- `void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);`
	- `addr`: 希望映射区域的首选起始地址。通常设为 NULL，由系统选择映射区域的地址。
	- `length`: 映射区域的长度。
	- `prot`: 映射区域的保护权限。可以是以下几个值的组合：
	    - `PROT_READ`: 可读。
	    - `PROT_WRITE`: 可写。
	    - `PROT_EXEC`: 可执行。
	    - `PROT_NONE`: 不可访问。
	- `flags`: 控制映射的行为。常见的标志包括：
	    - `MAP_FIXED`: 使用指定的`addr`精确地址；如果地址已被使用，会替换原有的映射。
	    - `MAP_SHARED`: 对映射的修改会反映到底层文件上，并且对其他所有映射同一文件的进程可见。
	    - `MAP_PRIVATE`: 对映射区域的写入不会写回到原文件，而是创建一个写时复制的私有副本。
	- `fd`: 要映射的文件的文件描述符。若是创建匿名映射，则设为-1。
	- `offset`: 文件中的偏移，映射从文件的这个偏移开始。
```c
volatile uint8_t *p = mmap(
        NULL,
        8 GiB,//宏定义的
        PROT_READ | PROT_WRITE,
        MAP_ANONYMOUS | MAP_PRIVATE,
        -1, 0
    );
```

- `munmap` 函数用于**取消**映射的内存区域，释放这部分区域。
	- `int munmap(void *addr, size_t length);`
	- `addr`: 映射区域的起始地址。
	- `length`: 映射区域的长度。

- `mprotect` 函数用于**修**改现有内存区域的保护权限。
	- `int mprotect(void *addr, size_t length, int prot);`
	- `addr`: 需要修改权限的内存区域的起始地址。
	- `length`: 需要修改权限的内存区域的长度。
	- `prot`: 新的保护权限，同 `mmap` 中的保护权限。
#### 入侵进程的地址空间
- 一个进程**对其他进程的地址**进行访问，就可以任意改变另一个程序的行为
- 如何查找变量的存储空间（金山游侠）
	- 让目标变量发生变化，查找发生了相同变化的内存，直至能唯一确定
	- 之后直接对内存的数据进行修改
- 给进程发送虚假信号（按键精灵）
	- 如发送 gui 事件（鼠标键盘）
- 改变进程对时间的感知（变速齿轮）
	- syscall：gettimeofday，sleep（用于等待时间）
	- 将 syscall 链接到自定义的方法（hook 函数的执行）
	- 应用：软件动态更新
### CPU 调度
- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240512223729.png)
	- 使用三级调度：
	- 高级调度（作业调度）：从外存处于后备队列的作业中选一个来载入内存、创建相关的进程
	- 中级调度（内存调度）：将暂时不能运行的进程调入外村（挂起）具备运行条件并且内存空闲时再调回。主要是为了提高内存的利用率
	- 低级调度（进程调度）：从就绪队列中选取进程，分配 CPU，进程调度的进行频率很高，最基本的调度
- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240512223744.png)
	- 排队器：将系统中所有就绪进程按照一定策略排成一个或多个队列
	- 分配器：根据调度程序所选的进程，从队列中取出，并为其分配进程
	- 上下文切换器：保存就上下文、恢复新上下文

- 进程的调度方式
	- 非抢占式调度：只有一个进程运行完成或者进入阻塞态，才能将 CPU 分配给其他进程
	- 抢占式调度：更重要的进程需要使用 CPU 则允许调度程序暂停正在执行的进程，分配给紧急进程
- 两种线程调度
	- 用户级线程调度：
	- 内核级线程调度：

- 调度的目标
#### 典型调度算法
## 可执行文件和加载
### 可执行文件
- 可执行文件：一个操作系统中的对象 (文件)，描述了状态机初始状态的**数据结构**

### 动态链接
## 扩展
### 系统调用和 UNIX Shell
#### 操作系统对象
- everything is a file
- 操作系统中的对象要么是**一个文件**要么是**一个字节流**，通过指针（windows 中称为 handle）访问一切
	- 定义（重要）：**文件描述符是指向操作系统对象的指针**

##### 管道与匿名管道
- 一种进程间同步机制 IPC

- 管道：**特殊文件流**
	- 由读者和写者共享
	- 命名管道是一种特殊类型的文件（FIFO），它**存在于文件系统中**，可以被系统中任何知道其名字的进程访问。
	- 读口支持 read；写口支持 write
```c
#define PIPE_NAME "/tmp/my_pipe"
void pipe_read() {
    int fd = open(PIPE_NAME, O_RDONLY);
    char buffer[1024];
    if (fd == -1) {
        perror("open");
        exit(1);
    }
    // Read from the pipe
    int num_read = read(fd, buffer, sizeof(buffer));
    if (num_read > 0) {
        printf("Received: %s\n", buffer);
    } else {
        printf("No data received.\n");
    }
    close(fd);
}
void pipe_write(const char *content) {
    // Open the pipe for writing
    int fd = open(PIPE_NAME, O_WRONLY);
    if (fd == -1) {
        perror("open");
        exit(1);
    }
    // Write the message to the pipe
    write(fd, content, strlen(content) + 1);
    close(fd);
}
int main(int argc, char *argv[]) {
    if (argc < 2) {
        fprintf(stderr, "Usage: %s read|write [message]\n", argv[0]);
        return 1;
    }
    // Create the named pipe if it does not exist
    if (mkfifo(PIPE_NAME, 0666) == -1) {
        if (errno != EEXIST) {
            perror("mkfifo");
            return 1;
        }
    }
    if (strcmp(argv[1], "read") == 0) {
        pipe_read();
    } else if (strcmp(argv[1], "write") == 0) {
        pipe_write(argv[2]);
    } else {
        fprintf(stderr, "Invalid command. Use 'read' or 'write'.\n");
        return 1;
    }
    return 0;
}

```
- 匿名管道 `int pipe (int pipefd[2]);`
	- 返回两个文件描述符
	- 适用于父子进程通信（如 fork 的），根据 fork 的返回值决定使用哪一个口
	- 匿名管道通常是**单向的**，意味着数据只能在一个方向上流动（可以创建两个匿名管道实现双向通信）。
	- 匿名管道由于**不在文件系统中出现**，不易被其他不相关的进程访问。
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240427213515.png)

```c
void do_parent(int fd) {
    const char *msg = "Hello, world!";
    printf("[%d] Write: '%s'\n", getpid(), msg);
    write(fd, msg, strlen(msg) + 1);
    close(fd);
    // Wait for the child to finish
    wait(NULL);
    printf("[%d] Done.\n", getpid());
}

void do_child(int fd) {
    static char buf[1024];
    ssize_t num_read = read(fd, buf, sizeof(buf));
    if (num_read == -1) {
        perror("read");
        exit(EXIT_FAILURE);
    }
    printf("[%d] Got: '%s'\n", getpid(), buf);
    // Close the read end of the pipe
    close(fd);
}

int main() {
    int pipefd[2];
    // Create a pipe
    if (pipe(pipefd) == -1) {
        perror("pipe");
        exit(EXIT_FAILURE);
    }
    // Fork the current process
    pid_t pid = fork();
    if (pid == -1) {
        perror("fork");
        exit(EXIT_FAILURE);
    }
    if (pid == 0) {
        // Child
        close(pipefd[1]); // Close unused write end
        do_child(pipefd[0]);
    } else {
        // Parent
        close(pipefd[0]); // Close unused read end
        do_parent(pipefd[1]);
    }
    return 0;
}
```
- **匿名管道**通常用于**父子进程**或具有明确亲缘关系的进程之间的快速通信，如一个进程需要对另一个进程进行直接控制或频繁地传输数据。
- **命名管道**更适用于需要**跨多个不相关进程**进行长时间或复杂交互的场景，如不同组件或程序间需要交换信息但又不方便直接使用更复杂的通信机制（如套接字）的情况。

- pipe 用于连接两个应用程序：
	- pipe read 在没有数据时会等待
	- pipe write 在有读者打开时，写入缓冲区并返回
- 管道异常
	- 如果写者还在运行，但是读者被关闭，就会出现 SIGPIPE 信号
	- 如 `python3 -c 'while True: print(1)' | head -n 1`
#### Unix Shell
- 特殊的应用程序
	- 直接和用户进行交互
	- 配置操作系统，启动、管理其他应用程序
	- 负责把用户指令翻译成系统调用
- 高效简洁精确的自然语言
	- "自然**编程语言**"
	- 一行命令，即可协同多个程序执行

##### 实现 Freestanding shell
### C 语言标准库的实现 libc
- C 是一种 “高级汇编语言”，是系统调用的一层 “**浅封装**”
- 语言机制上的运行库大部分可以用 C 语言本身实现，少部分需要一些 “底层支持”（使用内联汇编）

- [musl](https://musl.libc.org/) 更适合阅读学习的 libc
- 一个 c 程序的完整执行过程
	- 首先在 $\_start$ 有汇编设置一些寄存器
	- $\_start\_c$ 获取参数指针，划分为 argc、argv 等调用 $\_\_libc\_start\_main$，进一步得到 env 等（还有多级初始化）再调用 $main$
	- 执行 $main$
	- 之后在 $exit$ 内再进行一些清理，最后通过 syscall 调用 exit
		- ![image.png|262](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240427113624.png)
#### 计算封装
- 不依赖于系统， Freestanding 环境下也可以使用的定义
- 如 `string.h` 以及 `stdlib.h` 等等都封装了很多使用方法
- 实现这部分库函数 = C 语言课程习题
#### 系统调用与环境抽象
- 如 `printf` 等操作，封装简化了系统调用的使用
#### 动态内存管理
- 操作系统可以分配大段的内存（甚至超过物理上限 ）；由程序自己负责更细致的分配小段内存，如使用 `malloc()free()`，在操作系统提供的 `[L,R)` 范围内**维护互不相交的区间集合**

- 多级内存管理：第一级由操作系统分配，操作系统将内存交给进程，在进程结束时进行回收；第二级在进程中，由进程在内部进行管理。

- 在实际系统中，我们通常不考虑“最坏情况“（现实中的应用是 “正常” 的，不是 “恶意” 的） ，应该结合实际的 workload 来进行设计和优化
- 实际的情况
	- 小对象：字符串、临时对象等；生存周期**可长可短**
	- 中对象：容器、复杂的对象；更长的生存周期
	- 大对象：巨大的容器、分配器；**很长的生存周期**
- 因此管理的**重点是小对象**，小对象分配/回收的 scalability 是主要瓶颈（多 CPU 上同时进行）

- 思想：设置两套系统
	- first path：性能极好、并行度极高、覆盖大部分情况，但有小概率会失败
	- slow path：不在乎那么快，但把困难的事情做好
- 具体到 malloc
	- first path：给所有线程事先分配“领地”, 线程**默认从自己的领地分配**（线程**本地**完成），如果自己的领地不足再从全局借用：为了实现更好的性能浪费一点是可以接受的（比如内存对齐）
		- 针对不同大小的空间需求，使用不同的特定分配器（不同细粒度，像棋盘一样直接分配一个格子）
	- slow path：pgalloc()
#TODO
### linux 操作系统

