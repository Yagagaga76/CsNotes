### 简化的线程模型 (课程中用于演示)
- heap 表示共享内存
- 两个线程操作 API（[[docs/课程/操作系统/代码/thread-lib/thread.h|thread.h]]）
	- `create(fn)`：创建一个入口是 ` fn ` 的入口函数并立即执行
	- `join()` 等待所有运行线程的返回
### 并发编程中要"放弃"的习惯假设
- **状态迁移原子性**：
	- 共享内存推翻了"原子性"假设
	- 比如 `i++` 就不再具有原子性

- 程序**顺序执行**假设：
```python
def T_sum():
    for _ in range(3):
        t = heap.sum
        sys_sched()
        t = t + 1
        heap.sum = t
        sys_sched()
    sys_write(f'sum = {heap.sum}\n')

def main():
    heap.sum = 0
    sys_spawn(T_sum)
    sys_spawn(T_sum)
    sys_spawn(T_sum)

```
- sum 的最小输出结果为 2（无论多少个线程都是 2）
	- 要想为 2，则说明最后一步执行的是 $1\to2$
	- 也就是一个线程执行完成，一个还剩一次，一个第一次执行（拿的 sum=0）
	- 第一次执行的执行的执行之后 sum 为 1，还剩一次的拿到 1
	- 第一次执行的快速执行完成，还剩一次的执行一次得到 2

- **编译器的优化**可能带来不可预测的结果
	- `while (!flag);` 在优化之后并不会进行反复读取，而是会直接改为死循环，需要添加 `volatile` 组织优化

- **全局指令执行顺序**的假设
	- 处理器也是**编译器**，会对执行**优化**，只是使得指令 **"看起来"** 顺序完成（可能是针对自己的视角）
	- 比如可以同时执行两条不想关的指令
	- 实际的共享内存模型：不同处理器可能看到**不同的共享内存**
	-  ![image.png|400](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240322120710.png)
```python
def T1():
    heap.x = 1
    sys_sched()
    y_ = heap.y
    sys_sched()
    sys_write(f'{y_}')

def T2():
    heap.y = 1
    sys_sched()
    x_ = heap.x
    sys_sched()
    sys_write(f'{x_}')

def main():
    heap.x, heap.y = 0, 0
    sys_spawn(T1)
    sys_spawn(T2)
```
## 并发控制
### 互斥
- 互斥（互相排斥）：阻止并发
#### Peterson 算法 (用于两个线程)
- 每个人有一个变量（旗子）表示自己是否要使用临界区资源
- 如果要使用临界区资源：
	- 举起**自己的旗子**（先）
	- 把写有**对方名字**的字条贴在临界区上（后）
- 进入观察者模式：
	- 如果**对方没有举起**旗子或者**字条上是自己的名字**就可以使用临界区资源（手快的先进入）
- 释放：放下旗子
```python
def T1():
    while True:
        heap.x = '🏴'
        sys_sched()
        heap.turn = '❷'
        sys_sched()
        while True:
            t = heap.turn
            sys_sched()
            y = heap.y != ''
            sys_sched()
            if not y or t == '❶':
                break
        sys_sched()
        heap.cs += '❶'
        sys_sched()
        heap.cs = heap.cs.replace('❶', '')
        sys_sched()
        heap.x = ''
        sys_sched()
 
def T2():
    while True:
        heap.y = '🏁'
        sys_sched()
        heap.turn = '❶'
        sys_sched()
        while True:
            t = heap.turn
            sys_sched()
            x = heap.x
            sys_sched()
            if not x or t == '❷':
                break
            sys_sched()
        sys_sched()
        heap.cs += '❷'
        sys_sched()
        heap.cs = heap.cs.replace('❷', '')
        sys_sched()
        heap.y = ''
        sys_sched()

def main():
    heap.x = ''
    heap.y = ''
    heap.turn = ''
    heap.cs = ''
    sys_spawn(T1)
    sys_spawn(T2)

```
#### 多处理器上的互斥
- 
### 同步