### 简化的线程模型 (课程中用于演示)
- heap 表示共享内存
- 两个线程操作 API（[[docs/课程/操作系统/代码/thread-lib/thread.h|thread.h]]）
	- `create(fn)`：创建一个入口是 ` fn ` 的入口函数并立即执行
	- `join()` 等待所有运行线程的返回
### 并发编程中要"放弃"的习惯假设
- **状态迁移原子性**：
	- 共享内存推翻了"原子性"假设
	- 比如 `i++` 就不再具有原子性

- 程序**顺序执行**假设：
```python
def T_sum():
    for _ in range(3):
        t = heap.sum
        sys_sched()
        t = t + 1
        heap.sum = t
        sys_sched()
    sys_write(f'sum = {heap.sum}\n')

def main():
    heap.sum = 0
    sys_spawn(T_sum)
    sys_spawn(T_sum)
    sys_spawn(T_sum)

```
- sum 的最小输出结果为 2（无论多少个线程都是 2）
	- 要想为 2，则说明最后一步执行的是 $1\to2$
	- 也就是一个线程执行完成，一个还剩一次，一个第一次执行（拿的 sum=0）
	- 第一次执行的执行的执行之后 sum 为 1，还剩一次的拿到 1
	- 第一次执行的快速执行完成，还剩一次的执行一次得到 2

- 编译器的优化可能