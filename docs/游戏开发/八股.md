- 对象池是什么：
	- 对象池维护了一组可重复使用的对象集合。当游戏需要一个新对象时，它首先检查对象池中是否有空闲的对象可用，如果有，则重新配置该对象并将其激活使用，而不是创建一个新的实例。当对象不再需要时，它不会被销毁，而是返回到池中，等待下次重用。
	- 优点：减少内存分配；提高性能；减少垃圾收集

- unity资源动态加载方式
	- Resources.Load：从 `Resources` 文件夹中加载资源。（缺点：所有放在 `Resources` 文件夹中的资源都会被打包进最终的游戏包中，可能会导致游戏包体积增大，且运行时管理较为复杂。）`Sprite sprite = Resources.Load<Sprite>("Sprites/MySprite");`
	- `AssetBundle` 是一种更为高级的资源打包和加载机制。通过这种方式，可以将多个资源打包成一个单独的文件，在运行时按需加载。

- NavMesh 寻路原理
	- 首先生成 NavMesh，根据角色大小、可爬坡的坡度等，生成可行走区域的导航网格（用简化的多边形网格覆盖所有可行走的表面）
	- 寻路：在导航网格上找到一系列连接两点的多边形，这些多边形的边缘构成了路径（为了更加自然，还需要对路径进行平滑处理）
	- A\*找不到路时的处理：如寻找近似路径，考虑寻找距离目标最近的可达点

- AI 状态机实现方式
	- 基本组成：
		- **状态（State）**：代表 AI 在特定时间点的行为或者状态。
		- **转换（Transition）**：定义了从一个状态转换到另一个状态的条件。
		- **事件（Event）**：触发状态转换的**外部输入。**
	- 通常使用枚举类型来表示所有可能的状态
	- 实现原理：
		- **初始化**：在 AI 启动时，初始化状态机，创建所有状态的实例，并填充状态字典。同时，设置一个变量来保存当前状态。
		- **状态更新**：在 AI 的更新循环中，根据当前状态执行对应的行为（例如，调用当前状态对象的 `Update` 方法）。
		- **状态转换**：当满足转换条件时（例如，在 `Update` 方法中检测到玩家进入追击范围），AI 将切换到新的状态。这通常涉及调用当前状态的 `Exit` 方法，更改当前状态变量，然后调用新状态的 `Enter` 方法。
		- **事件处理**：状态机可以订阅游戏事件（如玩家的行为、游戏环境变化等），并在事件发生时评估是否需要进行状态转换。
```csharp
//接口定义
public interface IState
{
    void OnEnter();
    void OnExit();
    void Update();
}
//状态类
public class PatrolState : IState
{
    private readonly EnemyController enemyController;

    public PatrolState(EnemyController enemyController)
    {
        this.enemyController = enemyController;
    }

    public void OnEnter()
    {
        // 初始化巡逻状态
        Debug.Log("Enter Patrol State");
    }

    public void OnExit()
    {
        // 清理状态
        Debug.Log("Exit Patrol State");
    }

    public void Update()
    {
        // 实现巡逻逻辑
        // 示例：简单转圈逻辑
        enemyController.transform.Rotate(0, enemyController.patrolRotateSpeed * Time.deltaTime, 0);
    }
}
//状态控制器
public class EnemyController : MonoBehaviour
{
    public float patrolRotateSpeed = 30f;
    private IState currentState;

    private void Start()
    {
        SetState(new PatrolState(this));
    }

    private void Update()
    {
        currentState?.Update();
    }

    public void SetState(IState newState)
    {
        currentState?.OnExit();
        currentState = newState;
        currentState.OnEnter();
    }
}

```

- AI 行为树的实现方式
	- 节点的分类：
		- **根节点（Root）**：行为树的起点，整个行为树只有一个根节点。
		- **组合节点（Composite Nodes）**：控制子节点的执行顺序。常见的组合节点包括序列节点（）、选择节点（Selector）和并行节点（Parallel）。
	- 工作原理：

- A\*算法的优化
	- 