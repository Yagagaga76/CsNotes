## 案例
### SLG 游戏（大地图，多单位）
- **空间分割**：对于大型地图，使用四叉树、八叉树或 BSP（二叉空间分割）树来管理空间和对象可以有效减少需要处理的单位数量，特别是在视野裁剪和碰撞检测中。
- **按需加载和卸载**：不是一次性加载整个地图和所有单位，而是根据玩家的视野和位置**动态加载**周边区域的资源。
	- 资源共享、对象池等复用
	- 后台数据处理、异步加载、并行处理
	- 视野加载（进入视野再加载），根据位置和移动速度进行预测，动态加载和卸载
	- 事件触发加载（结合空间分割）
- 网络优化
	- 状态压缩（减少数据包大小）
	- 增量更新
	- 预测与差值
- 渲染优化
	- 分级渲染（远处的渲染细节低）
	- 视野剔除（不渲染视野之外）
	- 批处理渲染
- UI 优化
	- 合并绘制，减少渲染开销
	- 动态更新，数据变化 ui 才变化
- 事件驱动模型：
	- 适用于需要处理大量实体和交互的游戏：**基于事件的响应**，而**不是**在每一帧中**轮询**所有对象的状态。这可以显著减少不必要的计算，提高游戏的性能和响应速度。
	- **定义事件**：首先，需要定义可能发生的事件类型。这些事件可以包括用户输入、游戏逻辑触发的事件（如单位死亡、资源耗尽）、定时事件等。（首先定义触发攻击检查的事件，例如“敌人进入范围”或“单位被选中为攻击目标”，而不是每一帧进行检查）
	- **注册监听器**：各个游戏组件注册对特定事件的监听。当这些事件被触发时，只有注册了监听的组件才会响应并处理这些事件。
	- **事件队列**：游戏维护一个事件队列，所有发生的事件都首先被放入这个队列。每一帧，游戏循环都会处理这个队列中的事件，并调用相应的事件处理器。
	- **处理事件**：当事件被处理时，相关的游戏逻辑被执行，如移动单位、更改游戏状态或更新用户界面。
>对比-传统模型
	- **持续检查**：每个对象需要在**每一帧中检查**是否满足攻击条件。这包括计算距离、可能的目标检查和其他条件。
	- **重复计算**：如果游戏中有很多对象，这种方法会导致大量的重复计算和资源浪费，特别是当大部分时间这些检查的结果是“不攻击”时。
