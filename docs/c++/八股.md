- 建立别名的两种方式
	- define 预处理器 `#define byte char` 预处理器会在**编译程序时**使用 char 替换所有 byte
	- 使用关键字 `typedef` 如 `typedef char byte`
- 由于 define 只是简单的字符串替换而并不是真正的定义别名，可能存在问题
```c++
#define FLOAT_POINTER float*
FLOAT_POINTER pa, pb;
float* pa, pb;
//并没有得到两个指针对象
```

- 右值引用
	- 使用&&定义 `int&& rvalueRef = 5;`
	- 右值引用允许你安全地绑定到一个**临时对象**(左值引用不允许)，从而可以修改它们（专门用来绑定到右值上）
	- **移动语义**允许将一个对象的资源（如动态分配的内存）从一个对象**转移**到另一个对象，这样可以**避免不必要的复制**，提高性能。
	- 将左值转化为右值并进行绑定 `int&& rvalueRef2 = std::move(variable);`
- 使用移动构造函数
```cpp
std::vector<int> source;
std::vector<int> destination = std::move(source);  // 使用移动语义，避免数据拷贝
```

- 函数指针
	- 通过函数名就可以直接获得函数的地址
	- 函数指针的声明 `double (*pf)(int);` (返回值为 double、有一个参数 int)
	- 使用函数指针 `double y=(*pf)(5);`

- 左值引用
	- const 引用：禁止对引用的值进行赋值
	- 数组只能使用指针
	- 结构可以使用指针或引用
	- 类对象使用引用

- 函数重载
	- 函数重载的关键是函数的参数列表——也称为**函数特征标**(unction signature)，如果两个函数的参数数数目和类型相同，同时参数的排列顺序也相同，则它们的特征标相同（相同类型的引用和本身为相同特征标）
	- 特征标不同才能进行重载

- 模板像宏定义，它**不能节省空间**，如果使用了 int 和 double 版本的 swap，则最终的代码段会包含两个 swap 函数：最终仍将由两个独立的函数定义，就像以手工方式定义了这些函数一样。**最终的代码不包含任何模板**，而只包含了为程序生成的实际函数。使用模板的好处是，它使生成多个函数定义更**简单**、更可靠。

- 头文件的内容
	- 函数原型
	- \# define 、const 定义的符号常量
	- 结构、类声明
	- 内联函数

- 变量只能一次定义，但是可以多次声明 extern
	- 如果在 `a.h` 或者 `a.cpp` 中定义了一个全局变量 `(extern) int a=10`，那么在其他文件中需要使用 `extern int a` 来**声明**这个全局变量已经在其他地方定义过了。
	- 如果一个全局变量定义在头文件 `a.h` 中，就不能在**多个源文件**中引用 `a.h`，否则会造成**多重定义错误**。更一般的做法是，在 `a.h` 中**声明**，而在 `a.cpp` 中定义，然后其他源文件**引用**`a.h`。

- mutable：即使类变量为 const，其某个成员也可以被修改

- 名空间
- 创建名空间
```cpp
namespace Jill{
    double bucket{double n}{...};
    double fetch;
    int pal;
    struct Hill{...};
}
```
- using ：将名空间引入当前作用域
	- using 声明 `using Jill::fetch`
	- using 编译 `using namespace Jack;
	- 如果某个名称已经在函数中**声明了**，则不能用 using**声明**导入相同的名称。
	- 如果使用 using **编译**指令导入一个已经在函数中声明的名称，则**局部名称将隐藏名称空间名**，就像隐藏同名的全局变量一样，不过仍可以使用作用域解析运算符。 

- static
	- 局部静态变量：程序执行期间只初始化一次，值在函数调用（多次调用）之间保持不变
	- 全局静态变量：全局变量默认是整个程序可见，但用 static 修饰之后编程文件作用域
	- 静态成员：类外初始化
	- 静态成员函数：静态成员函数只能访问静态成员（没有 this 指针）

- const
	- 声明常量变量
	- 成员函数中的应用
		- 不可修改的函数参数
		- 常量成员函数 `void myFunction() const {}` 表示不会修改成员变量状态
		- 常亮返回值
	- 常量对象：整你使用常量成员函数

- malloc 和 nwe
	- `malloc` 根据需要分配的**字节数**`size` 来分配内存，并返回一个指向分配的内存的指针。如果分配失败，返回 `NULL`。`malloc` 返回一个 `void*` 类型的指针，使用时通常需要将其**显式转换**为目标类型的指针。`malloc` 仅**仅分配内存**，不调用任何构造函数来初始化对象，也不会调用析构函数来清理对象。
	- `new` 分配足够的内存来存储特定类型的对象，并返回该类型的指针。`new` 还会调用对象的构造函数来**初始化对象。**`new` 不仅分配内存，还负责调用构造函数初始化对象。相对应地，`delete` 操作符会调用析构函数并释放内存。

- 内存 5 大区
	- **栈区**：局部变量、参数、返回地址
	- **堆区**：动态内存分配（生命周期较长）
	- **全局/静态存储区**：存储全局变量、静态变量、常亮（程序开始时分配，程序结束时释放）全局变量和静态局部变量放在一块，未初始化的放在另一块。
	- **文字常量区**：常量在统一运行被创建，常量区的内存是只读的，程序结束后由系统释放。
	- **程序代码区**：存放程序的二进制代码，内存由系统管理

- 类型转换
	- **静态转换**(static_cast)：静态转换可以在**编译时期**完成，一般用于基本数据类型的转化以及指针、引用的向上转化
	- **动态转换**(dynamic_cast)：动态转换可以在**运行时期**完成，可以安全的加你选哪个向下转化，会在运行时期检查对象实际类型，确保转化的有效性
	- **常量转换**(const_cast)：常量转换用于**去掉**表达式的const属性，使其变成非常量表达式。
	- **重解释转换**(reinterpret_cast)：重解释转换用于进行各种类型之间的**强制转换**，包括指针、引用、整数之间的转换。

- 智能指针
	- **share_ptr**：允许多个 `shared_ptr` 实例指向同一个对象。`shared_ptr` 使用引用**计数**来跟踪有多少个指针共享同一个资源，当最后一个这样的指针被销毁时，资源也会被自动释放。
	- **unique_ptr**：独占所有权的智能指针，确保同一时间内只有**一个**`unique_ptr` 可以指向给定的对象。当 `unique_ptr` 被销毁时（例如，离开作用域或被显式删除），它指向的对象也会被自动删除。
		- 独占所有权语义，不可复制，但可以移动。
		- `std::unique_ptr<int> ptr2 = std::move(ptr);`
		- 比 `shared_ptr` 轻量，没有引用计数的开销。

- 流和缓冲区
	- 
## 面向对象
- 类的声明
	- 通常在头文件中进行
	- 声明时可以直接加入成员方法，会被自动称为**内联函数**
	- 在类的外部定义成员函数时需要同时提供类名和函数名：`Stock::set_tot()`

- `return *this` 是对 this 指针的解引用。**它意味着将当前对象的引用返回。**

- 操作符重载：
```cpp
class Time
{
private:
    int hours;
    int minutes;
public:
    Time();
    Time (int h,int m=0);
    void AddMin(int m)
    void AddHr(int h):
    void Reset(int h=0,int m=0)
    Time operator+(const Time &t) const;
    void Show() const;
}

Time Time::operator+(const Time &t) const
{
    Time sum;
    sum.minutes = minutes+t.minutes;
    sum.hours=hours+t.hours+sum.minutes/60;
    sum.minutes %= 60:
    return sum;
}
```
- 只能重载已经存在的操作符
- 不改变优先级
- 有的操作符不能重载
- 一些操作符必须使用成员函数重载、一些必须使用外部函数
	- 涉及到对类成员进行访问、修改的重载通常为成员函数，如\[]\()->
```cpp
char & String::operator[](int i) { return str[i]; }
```
- <<的重载必须使用友元函数
	- 通常来说使用使用友元函数时有两个参数，使用成员函数时只有一个参数（this 隐含给出）
```cpp
ostream& operator<<(ostream& os,const Time t)
{
    os<<t.hours<<"hours,"<<t.minutes<<"minutes";
    return os;
}
```

- 友元：
	- 友元函数
	- 友元类
	- 友元成员函数
	- 需要在类声明中添加友元声明 `friend Time operator*(double m,const Time t);`

- 类的自动转化
	- 类可以**根据构造函数进行自动转换**（其他类型->本类型）
```cpp
Stonewt myCat;//create a Stonewt object
mycat=19.6;//use Stonewt(double)to convert 19.6 to Stonewt
```
- 添加 `explicit` 关键字在构造函数前面禁止利用构造函数进行自动转换
- 重载转换函数（本类型->其他类型）
```cpp
class Stonewt
{
private:
    ...
public:
    operator int() const;
    operator double() const;
}

//defination below
Stonewt::operator int() const
{
    return int(pounds+0.5);
}
Stonewt::operator double() const
{
    return pounds;
}
```

- 特殊成员函数
	- 默认构造函数
	- 默认析构函数
	- 复制构造函数（将一个对象复制到新创建的对象中）`Class_name(const Class_name &)`
		- 接受一个指向类对象的**常量引用**作为参数。
		- 默认的复制构造函数逐个复制非静态成员（成员复制也称为浅复制），复制的是成员的**值**（静态类成员不变）。
		- 使用场景：通过同类创建对象时使用；作为函数参数传递；作为函数返回值
	- 赋值运算符
		- 将己有的对象**赋**给另一个对象时，将使用重载的赋值运算符：`StringBad & StringBad::operator=(const StringBad &)`
		- 使用场景：对已经创建的对象进行赋值操作
	- 地址运算符
	- 移动构造函数
	- 移动赋值运算符

- 构造派生类时**必须先创建基类**对象，因此程序将使用默认的基类构造函数

- **函数重载**：同一作用域内存在多个同名函数，但这些函数的参数列表不同

- **函数重写**：多态是通过**虚函数**来实现的。如果一个基类定义了一个虚函数，那么派生类可以**重写**这个函数。然后，我们可以通过基类的指针或引用来调用这个函数，而实际执行的是派生类版本的函数。这就是所谓的**动态绑定**。（override 在派生类中用于显式地指明函数重写了基类中的虚函数, 仅用于编译检查）
```cpp
class Base {
public:
    virtual void show() {
        std::cout << "Base show" << std::endl;
    }
};

class Derived : public Base {
public:
    void show() override { // 明确标记重写
        std::cout << "Derived show" << std::endl;
    }
};
```
- 如果派生类中的函数和基类中的函数具有**相同的名称**，**但参数列表不同**，那么派生类中的函数将会隐藏基类中所有同名的函数，**无论参数列表是否相同。**（所以，应尽量避免这种情况。）

- 虚函数的工作原理
	- **虚函数表（vtable）**：当一个类中声明了虚函数，编译器会为这个类生成一个虚函数表。这个表是一个函数指针数组，数组中的每个元素都是**指向类的虚函数的指针**。每个类的虚函数表是唯一的，所有该类的对象都共享同一个虚函数表。
	- **虚指针（vptr）**：当一个类对象被创建时，如果该类中有虚函数，那么编译器会在对象内部添加一个虚指针。这个虚指针指向该类的虚函数表。如果有派生类对象，那么派生类对象的**虚指针会指向派生类的虚函数表。**
	- **动态绑定**：当我们通过基类指针或引用调用虚函数时，编译器会查找指针或引用所指向的对象的虚指针，然后通过虚指针找到对应的虚函数表，最后**在虚函数表中查找并调用相应的虚函数**。这个过程是在运行时进行的，因此称为动态绑定。
	- ![](https://thdlrt.oss-cn-beijing.aliyuncs.com/898333-20160609210418246-1188626035.png)
- 虚函数表在**编译**时期创建，为每个有虚函数的类生成一个虚函数表
- 虚函数指针在**对象构造**时进行初始化，在构造函数的代码中插入设置虚函数表指针的操作

- 纯虚函数 `virtual double Area() const=0;`
	- 不能创建包含纯虚函数的类的对象

- 如果派生类中定义了 new：则需要定义析构函数、复制构造函数以及赋值运算符

- 继承方式：public、private、protected
	- private 将所有权限改变为 private 指的是派生类对外，而不是针对派生类（对于派生类还是原先的 public、private...）

- 多重继承
	- 带来的问题：从两个不同的基类继承同名方法：从不同的直接基类中继承同一个类的多个实例
	- 对于同名方法可以使用作用域受限解决 `A::`
	- 对于菱形继承使用虚基类解决
- 虚基类
```cpp
class Singer:virtual public Worker{...};
class Waiter:public virtual Worker{...};
class SingingWaiter:public Singer, public Waiter{...};
```
- 继承的 Singer 和 Waiter 对象**共享**一个 Worker 对象。
- 在普通的继承关系中：派生类的构造函数只能通过**中间类的构造函数**来间接调用基类的构造函数。虚继承关系中派生类可以**直接调用**，不需要通过中间类

- 模版类的友元

## STL
- resize 和 reverse 的区别
	- `resize(n)` 操作调整容器的大小以使其能够容纳 `n` 个元素。如果当前大小小于 `n`，则在容器末尾**添加足够数量的元素**以达到指定的大小，新添加的元素将被初始化（对于基本类型，通常是零初始化；对于类类型，则调用默认构造函数）。如果当前大小大于 `n`，则容器末尾**多余的元素将被删除**。改变容器中**实际存储的元素数量时**
	- `reserve(n)`操作用于请求改变容器的**容量**至少足以容纳`n`个元素。这是一种优化操作，其目的是**减少**因后续插入操作而导致的**多次内存分配和复制**。
### 容器
#### vector
- 底层是一个动态数组，包含三个迭代器（空间头尾以及使用空间尾部）
- 底层为动态数组，空间不足时申请 1.5/2 倍空间并进行拷贝并释放原空间（旧迭代器会全部失效，删除元素时也会引起）
- size 返回元素数目，capacity 返回容量
- ![image.png|475](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240312160815.png)
#### list
- list 底层是双向链表
#### deque
- 底层通过多个固定大小的数组（块）来实现，从而可以实现在两端快速添加或删除元素。当在`deque`的任一端插入元素时，如果该端的当前块已满，容器会自动分配**一个新的块**并将其链接到现有的块序列中。
- queue、stack 底层都是借助 deque 实现的
#### priority_queue
- 堆实现
#### map 、set、multiset、multimap
- 红黑树实现
####  unordered_map、unordered_set
- 哈希表
### 迭代器
- 迭代器的分类：
	- **输入迭代器**：只读迭代器，在每个被遍历的位置上只能读取一次
	- **输出迭代器**：只写迭代器，在每个被遍历的位置上只能被写一次
	- **前向迭代器**：具输入和输出迭代器的能力，但是它可以对同一个位置重复进行读和写。但它不支持operator–，所以只能向前移动。
	- **双向迭代器**：很像前向迭代器，只是它向后移动和向前移动同样容易。
	- **随机访问迭代器**：有双向迭代器的所有功能。而且，它还提供了“迭代器算术”，即在一步内可以向前或向后跳跃任意位置， 包含指针的所有操作，可进行随机访问，随意移动指定的步数。