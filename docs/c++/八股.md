- 建立别名的两种方式
	- define 预处理器 `#define byte char` 预处理器会在**编译程序时**使用 char 替换所有 byte
	- 使用关键字 `typedef` 如 `typedef char byte`
- 由于 define 只是简单的字符串替换而并不是真正的定义别名，可能存在问题
```c++
#define FLOAT_POINTER float*
FLOAT_POINTER pa, pb;
float* pa, pb;
//并没有得到两个指针对象
```

- 右值引用
	- 使用&&定义 `int&& rvalueRef = 5;`
	- 右值引用允许你安全地绑定到一个**临时对象**(左值引用不允许)，从而可以修改它们（专门用来绑定到右值上）
	- **移动语义**允许将一个对象的资源（如动态分配的内存）从一个对象**转移**到另一个对象，这样可以**避免不必要的复制**，提高性能。
	- 将左值转化为右值并进行绑定 `int&& rvalueRef2 = std::move(variable);`
- 使用移动构造函数
```cpp
std::vector<int> source;
std::vector<int> destination = std::move(source);  // 使用移动语义，避免数据拷贝
```

- 函数指针
	- 通过函数名就可以直接获得函数的地址
	- 函数指针的声明 `double (*pf)(int);` (返回值为 double、有一个参数 int)
	- 使用函数指针 `double y=(*pf)(5);`

- 左值引用
	- const 引用：禁止对引用的值进行赋值
	- 数组只能使用指针
	- 结构可以使用指针或引用
	- 类对象使用引用

- 函数重载
	- 函数重载的关键是函数的参数列表——也称为**函数特征标**(unction signature)，如果两个函数的参数数数目和类型相同，同时参数的排列顺序也相同，则它们的特征标相同（相同类型的引用和本身为相同特征标）
	- 特征标不同才能进行重载

- 模板像宏定义，它**不能节省空间**，如果使用了 int 和 double 版本的 swap，则最终的代码段会包含两个 swap 函数：最终仍将由两个独立的函数定义，就像以手工方式定义了这些函数一样。**最终的代码不包含任何模板**，而只包含了为程序生成的实际函数。使用模板的好处是，它使生成多个函数定义更**简单**、更可靠。

- 头文件的内容
	- 函数原型
	- \# define 、const 定义的符号常量
	- 结构、类声明
	- 内联函数

- 变量只能一次定义，但是可以多次声明 extern
	- 如果在 `a.h` 或者 `a.cpp` 中定义了一个全局变量 `(extern) int a=10`，那么在其他文件中需要使用 `extern int a` 来**声明**这个全局变量已经在其他地方定义过了。
	- 如果一个全局变量定义在头文件 `a.h` 中，就不能在**多个源文件**中引用 `a.h`，否则会造成**多重定义错误**。更一般的做法是，在`a.h`中**声明**，而在`a.cpp`中定义，然后其他源文件**引用**`a.h`。