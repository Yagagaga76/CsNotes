- 建立别名的两种方式
	- define 预处理器 `#define byte char` 预处理器会在**编译程序时**使用 char 替换所有 byte
	- 使用关键字 `typedef` 如 `typedef char byte`
- 由于 define 只是简单的字符串替换而并不是真正的定义别名，可能存在问题
```c++
#define FLOAT_POINTER float*
FLOAT_POINTER pa, pb;
float* pa, pb;
//并没有得到两个指针对象
```

- 右值引用
	- 使用&&定义 `int&& rvalueRef = 5;`
	- 右值引用允许你安全地绑定到一个**临时对象**(左值引用不允许)，从而可以修改它们（专门用来绑定到右值上）
	- **移动语义**允许将一个对象的资源（如动态分配的内存）从一个对象**转移**到另一个对象，这样可以**避免不必要的复制**，提高性能。
	- 将左值转化为右值并进行绑定 `int&& rvalueRef2 = std::move(variable);`
- 使用移动构造函数
```cpp
std::vector<int> source;
std::vector<int> destination = std::move(source);  // 使用移动语义，避免数据拷贝
```

- 函数指针
	- 通过函数名就可以直接获得函数的地址
	- 函数指针的声明 `double (*pf)(int);` (返回值为 double、有一个参数 int)
	- 使用函数指针 `double y=(*pf)(5);`

- 左值引用
	- const 引用：禁止对引用的值进行赋值
	- 数组只能使用指针
	- 结构可以使用指针或引用
	- 类对象使用引用

- 函数重载
	- 函数重载的关键是函数的参数列表——也称为**函数特征标**(unction signature)，如果两个函数的参数数数目和类型相同，同时参数的排列顺序也相同，则它们的特征标相同（相同类型的引用和本身为相同特征标）
	- 特征标不同才能进行重载

- 模板像宏定义，它**不能节省空间**，如果使用了 int 和 double 版本的 swap，则最终的代码段会包含两个 swap 函数：最终仍将由两个独立的函数定义，就像以手工方式定义了这些函数一样。**最终的代码不包含任何模板**，而只包含了为程序生成的实际函数。使用模板的好处是，它使生成多个函数定义更**简单**、更可靠。

- 头文件的内容
	- 函数原型
	- \# define 、const 定义的符号常量
	- 结构、类声明
	- 内联函数

- 变量只能一次定义，但是可以多次声明 extern
	- 如果在 `a.h` 或者 `a.cpp` 中定义了一个全局变量 `(extern) int a=10`，那么在其他文件中需要使用 `extern int a` 来**声明**这个全局变量已经在其他地方定义过了。
	- 如果一个全局变量定义在头文件 `a.h` 中，就不能在**多个源文件**中引用 `a.h`，否则会造成**多重定义错误**。更一般的做法是，在 `a.h` 中**声明**，而在 `a.cpp` 中定义，然后其他源文件**引用**`a.h`。

- mutable：即使类变量为 const，其某个成员也可以被修改

- 名空间
- 创建名空间
```cpp
namespace Jill{
    double bucket{double n}{...};
    double fetch;
    int pal;
    struct Hill{...};
}
```
- using ：将名空间引入当前作用域
	- using 声明 `using Jill::fetch`
	- using 编译 `using namespace Jack;
	- 如果某个名称已经在函数中**声明了**，则不能用 using**声明**导入相同的名称。
	- 如果使用 using **编译**指令导入一个已经在函数中声明的名称，则**局部名称将隐藏名称空间名**，就像隐藏同名的全局变量一样，不过仍可以使用作用域解析运算符。 

- static
	- 局部静态变量：程序执行期间只初始化一次，值在函数调用（多次调用）之间保持不变
	- 全局静态变量：全局变量默认是整个程序可见，但用 static 修饰之后编程文件作用域
	- 静态成员：类外初始化
	- 静态成员函数：静态成员函数只能访问静态成员（没有 this 指针）

- const
	- 声明常量变量
	- 不可修改的函数参数
	- 常量成员函数 `void myFunction() const {}` 表示不会修改成员变量状态
	- 常亮对象：整你使用常量成员函数
## 面向对象
- 类的声明
	- 通常在头文件中进行
	- 声明时可以直接加入成员方法，会被自动称为**内联函数**
	- 在类的外部定义成员函数时需要同时提供类名和函数名：`Stock::set_tot()`

- `return *this` 是对 this 指针的解引用。**它意味着将当前对象的引用返回。**

- 操作符重载：
```cpp
class Time
{
private:
    int hours;
    int minutes;
public:
    Time();
    Time (int h,int m=0);
    void AddMin(int m)
    void AddHr(int h):
    void Reset(int h=0,int m=0)
    Time operator+(const Time &t) const;
    void Show() const;
}

Time Time::operator+(const Time &t) const
{
    Time sum;
    sum.minutes = minutes+t.minutes;
    sum.hours=hours+t.hours+sum.minutes/60;
    sum.minutes %= 60:
    return sum;
}
```
- 只能重载已经存在的操作符
- 不改变优先级
- 有的操作符不能重载
- 一些操作符必须使用成员函数重载、一些必须使用外部函数
	- 涉及到对类成员进行
```cpp

```