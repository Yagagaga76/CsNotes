- 建立别名的两种方式
	- define 预处理器 `#define byte char` 预处理器会在**编译程序时**使用 char 替换所有 byte
	- 使用关键字 `typedef` 如 `typedef char byte`
- 由于 define 只是简单的字符串替换而并不是真正的定义别名，可能存在问题
```c++
#define FLOAT_POINTER float*
FLOAT_POINTER pa, pb;
float* pa, pb;
//并没有得到两个指针对象
```

- 右值引用
	- 使用&&定义 `int&& rvalueRef = 5;`
	- 右值引用允许你安全地绑定到一个**临时对象**(左值引用不允许)，从而可以修改它们（专门用来绑定到右值上）
	- **移动语义**允许将一个对象的资源（如动态分配的内存）从一个对象**转移**到另一个对象，这样可以**避免不必要的复制**，提高性能。
	- 将左值转化为右值并进行绑定 `int&& rvalueRef2 = std::move(variable);`
- 使用移动构造函数
```cpp
std::vector<int> source;
std::vector<int> destination = std::move(source);  // 使用移动语义，避免数据拷贝
```

- 函数指针
	- 通过函数名就可以直接获得函数的地址
	- 函数指针的声明 `double (*pf)(int);` (返回值为 double、有一个参数 int)
	- 使用函数指针 `double y=(*pf)(5);`

- 左值引用
	- const 引用：禁止对引用的值进行赋值
	- 数组只能使用指针
	- 结构可以使用指针或引用
	- 类对象使用引用

- 函数重载
	- 函数重载的关键是函数的参数列表——也称为**函数特征标**(unction signature)，如果两个函数的参数数数目和类型相同，同时参数的排列顺序也相同，则它们的特征标相同（相同类型的引用和本身为相同特征标）
	- 特征标不同才能进行重载

- 模板像宏定义，它**不能节省空间**，如果使用了 int 和 double 版本的 swap，则最终的代码段会包含两个 swap 函数：最终仍将由两个独立的函数定义，就像以手工方式定义了这些函数一样。**最终的代码不包含任何模板**，而只包含了为程序生成的实际函数。使用模板的好处是，它使生成多个函数定义更**简单**、更可靠。

- 头文件的内容
	- 函数原型
	- \# define 、const 定义的符号常量
	- 结构、类声明
	- 内联函数

- 变量只能一次定义，但是可以多次声明 extern
	- 如果在 `a.h` 或者 `a.cpp` 中定义了一个全局变量 `(extern) int a=10`，那么在其他文件中需要使用 `extern int a` 来**声明**这个全局变量已经在其他地方定义过了。
	- 如果一个全局变量定义在头文件 `a.h` 中，就不能在**多个源文件**中引用 `a.h`，否则会造成**多重定义错误**。更一般的做法是，在 `a.h` 中**声明**，而在 `a.cpp` 中定义，然后其他源文件**引用**`a.h`。

- mutable：即使类变量为 const，其某个成员也可以被修改

- 名空间
- 创建名空间
```cpp
namespace Jill{
    double bucket{double n}{...};
    double fetch;
    int pal;
    struct Hill{...};
}
```
- using ：将名空间引入当前作用域
	- using 声明 `using Jill::fetch`
	- using 编译 `using namespace Jack;
	- 如果某个名称已经在函数中**声明了**，则不能用 using**声明**导入相同的名称。
	- 如果使用 using **编译**指令导入一个已经在函数中声明的名称，则**局部名称将隐藏名称空间名**，就像隐藏同名的全局变量一样，不过仍可以使用作用域解析运算符。 

- static
	- 局部静态变量：程序执行期间只初始化一次，值在函数调用（多次调用）之间保持不变
	- 全局静态变量：全局变量默认是整个程序可见，但用 static 修饰之后编程文件作用域
	- 静态成员：类外初始化
	- 静态成员函数：静态成员函数只能访问静态成员（没有 this 指针）

- const
	- 声明常量变量
	- 成员函数中的应用
		- 不可修改的函数参数
		- 常量成员函数 `void myFunction() const {}` 表示不会修改成员变量状态
		- 常亮返回值
	- 常量对象：整你使用常量成员函数

- malloc 和 nwe
	- `malloc` 根据需要分配的**字节数**`size` 来分配内存，并返回一个指向分配的内存的指针。如果分配失败，返回 `NULL`。`malloc` 返回一个 `void*` 类型的指针，使用时通常需要将其**显式转换**为目标类型的指针。`malloc` 仅**仅分配内存**，不调用任何构造函数来初始化对象，也不会调用析构函数来清理对象。
	- `new` 分配足够的内存来存储特定类型的对象，并返回该类型的指针。`new` 还会调用对象的构造函数来**初始化对象。**`new` 不仅分配内存，还负责调用构造函数初始化对象。相对应地，`delete` 操作符会调用析构函数并释放内存。
## 面向对象
- 类的声明
	- 通常在头文件中进行
	- 声明时可以直接加入成员方法，会被自动称为**内联函数**
	- 在类的外部定义成员函数时需要同时提供类名和函数名：`Stock::set_tot()`

- `return *this` 是对 this 指针的解引用。**它意味着将当前对象的引用返回。**

- 操作符重载：
```cpp
class Time
{
private:
    int hours;
    int minutes;
public:
    Time();
    Time (int h,int m=0);
    void AddMin(int m)
    void AddHr(int h):
    void Reset(int h=0,int m=0)
    Time operator+(const Time &t) const;
    void Show() const;
}

Time Time::operator+(const Time &t) const
{
    Time sum;
    sum.minutes = minutes+t.minutes;
    sum.hours=hours+t.hours+sum.minutes/60;
    sum.minutes %= 60:
    return sum;
}
```
- 只能重载已经存在的操作符
- 不改变优先级
- 有的操作符不能重载
- 一些操作符必须使用成员函数重载、一些必须使用外部函数
	- 涉及到对类成员进行访问、修改的重载通常为成员函数，如\[]\()->
```cpp
char & String::operator[](int i) { return str[i]; }
```
- <<的重载必须使用友元函数
	- 通常来说使用使用友元函数时有两个参数，使用成员函数时只有一个参数（this 隐含给出）
```cpp
ostream& operator<<(ostream& os,const Time t)
{
    os<<t.hours<<"hours,"<<t.minutes<<"minutes";
    return os;
}
```

- 友元：
	- 友元函数
	- 友元类
	- 友元成员函数
	- 需要在类声明中添加友元声明 `friend Time operator*(double m,const Time t);`

- 类的自动转化
	- 类可以**根据构造函数进行自动转换**（其他类型->本类型）
```cpp
Stonewt myCat;//create a Stonewt object
mycat=19.6;//use Stonewt(double)to convert 19.6 to Stonewt
```
- 添加 `explicit` 关键字在构造函数前面禁止利用构造函数进行自动转换
- 重载转换函数（本类型->其他类型）
```cpp
class Stonewt
{
private:
    ...
public:
    operator int() const;
    operator double() const;
}

//defination below
Stonewt::operator int() const
{
    return int(pounds+0.5);
}
Stonewt::operator double() const
{
    return pounds;
}
```

- 特殊成员函数
	- 默认构造函数
	- 默认析构函数
	- 复制构造函数（将一个对象复制到新创建的对象中）`Class_name(const Class_name &)`
		- 接受一个指向类对象的**常量引用**作为参数。
		- 默认的复制构造函数逐个复制非静态成员（成员复制也称为浅复制），复制的是成员的**值**（静态类成员不变）。
		- 使用场景：通过同类创建对象时使用；作为函数参数传递；作为函数返回值
	- 赋值运算符
		- 将己有的对象**赋**给另一个对象时，将使用重载的赋值运算符：`StringBad & StringBad::operator=(const StringBad &)`
		- 使用场景：对已经创建的对象进行赋值操作
	- 地址运算符
	- 移动构造函数
	- 移动赋值运算符

- 构造派生类时**必须先创建基类**对象，因此程序将使用默认的基类构造函数

- **函数重载**：同一作用域内存在多个同名函数，但这些函数的参数列表不同

- **函数重写**：多态是通过**虚函数**来实现的。如果一个基类定义了一个虚函数，那么派生类可以**重写**这个函数。然后，我们可以通过基类的指针或引用来调用这个函数，而实际执行的是派生类版本的函数。这就是所谓的**动态绑定**。（override 在派生类中用于显式地指明函数重写了基类中的虚函数, 仅用于编译检查）
```cpp
class Base {
public:
    virtual void show() {
        std::cout << "Base show" << std::endl;
    }
};

class Derived : public Base {
public:
    void show() override { // 明确标记重写
        std::cout << "Derived show" << std::endl;
    }
};
```
- 如果派生类中的函数和基类中的函数具有**相同的名称**，**但参数列表不同**，那么派生类中的函数将会隐藏基类中所有同名的函数，**无论参数列表是否相同。**（所以，应尽量避免这种情况。）

- 虚函数的工作原理
	- **虚函数表（vtable）**：当一个类中声明了虚函数，编译器会为这个类生成一个虚函数表。这个表是一个函数指针数组，数组中的每个元素都是**指向类的虚函数的指针**。每个类的虚函数表是唯一的，所有该类的对象都共享同一个虚函数表。
	- **虚指针（vptr）**：当一个类对象被创建时，如果该类中有虚函数，那么编译器会在对象内部添加一个虚指针。这个虚指针指向该类的虚函数表。如果有派生类对象，那么派生类对象的**虚指针会指向派生类的虚函数表。**
	- **动态绑定**：当我们通过基类指针或引用调用虚函数时，编译器会查找指针或引用所指向的对象的虚指针，然后通过虚指针找到对应的虚函数表，最后**在虚函数表中查找并调用相应的虚函数**。这个过程是在运行时进行的，因此称为动态绑定。
	- ![](https://thdlrt.oss-cn-beijing.aliyuncs.com/898333-20160609210418246-1188626035.png)

- 纯虚函数 `virtual double Area() const=0;`
	- 不能创建包含纯虚函数的类的对象

- 如果派生类中定义了 new：则需要定义析构函数、复制构造函数以及赋值运算符

- 继承方式：public、private、protected
	- private 将所有权限改变为 private 指的是派生类对外，而不是针对派生类（对于派生类还是原先的 public、private...）

- 多重继承
	- 带来的问题：从两个不同的基类继承同名方法：从不同的直接基类中继承同一个类的多个实例
	- 对于同名方法可以使用作用域受限解决 `A::`
	- 对于菱形继承使用虚基类解决
- 虚基类
```cpp
class Singer:virtual public Worker{...};
class Waiter:public virtual Worker{...};
class SingingWaiter:public Singer, public Waiter{...};
```
- 继承的 Singer 和 Waiter 对象**共享**一个 Worker 对象。
- 在普通的继承关系中：派生类的构造函数只能通过**中间类的构造函数**来间接调用基类的构造函数。虚继承关系中派生类可以**直接调用**，不需要通过中间类