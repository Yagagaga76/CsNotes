## 个人相关
### 自我介绍
Hi, my name is Tian Haodong, and I'm a student at Nanjing University, majoring in Computer Science and Finance. I enjoy learning new things and sharing my notes on my blog. I've kept good grades, ranking 3rd in my class, and I've won the Excellence Scholarship for two years in a row.

I've worked on many projects and joined several competitions. For example, I led a team in the Nanjing University-NetEase Game Competition, where we made an RTS game using C# and Unity. This made me very interested in the game industry and computer graphics.

I'm also good at data structures and algorithms. I won a gold medal[ˈmed(ə)l] in the Nanjing University Programming Contest and scored in the top 1.33% in the CCF-CSP exam. I taught myself computer graphics and completed projects like a rasterizer[ˈræs.tə.raɪz] and a simple ray tracer, which helped me understand graphics better.

I'm very interested in real-time rendering and hope to contribute to improving visuals and performance in future games or AR applications. I look forward to continuing my studies and growing in this field.
### 介绍家乡
I'm from Shenyang, the capital city of Liaoning Province in northeastern China. Shenyang is a city with a long history and lots of culture. It's famous for being the birthplace of the Qing Dynasty. You can visit the Shenyang Imperial[ɪmˈpɪriəl] Palace, which is a really cool historic site.

Shenyang is also a big industrial[ɪnˈdʌstriəl] city, known for its car and airplane factories. But it's not all factories  we have beautiful parks like Beiling Park and the Botanical[bəˈtænɪk(ə)l] Garden where people can relax and enjoy nature.

One of my favorite things about Shenyang is the food. We have amazing local dishes, like Shenyang dumplings and Laobian dumplings. The street food is also great, with lots of tasty snacks to try. One of the most famous street foods is "chicken rack" (鸡架), which is very popular among locals. 

Shenyang is a place where you can see both old traditions and modern life. It's a great city with a lot to offer, and I'm proud to call it my hometown.
### 最喜欢的课程
One of my favorite courses in computer science is Algorithm Design and Analysis. This course has significantly deepened my understanding of fundamental algorithms and their analysis. We started with sorting problems to introduce the divide-and-conquer strategy and heap data structures. As the course progressed, we delved[delvd] into more advanced data structures like disjoint sets, red-black trees, and hash tables. Later, we combined these concepts with graph theory to explain common algorithms such as minimum spanning trees. The course also covered greedy algorithms and dynamic programming, providing a comprehensive overview of essential algorithmic strategies.

In class, this theoretical[ˌθiəˈretɪk(ə)l] foundation helped me grasp the complexities of various algorithms. We also solved problems on online judges, which improved my coding and problem-solving skills.

Outside of class, I have been very active in self-study and competitions. Since my freshman year, I have been solving problems on LeetCode and participating in weekly contests. This has greatly enhanced my algorithm skills. From my junior year, I delved deeper into competitive programming and participated in various contests. Such as scoring in the top 1.33%（*one point three three percent*） in the CCF-CSP Certification exam and winning a gold medal in the Nanjing University Programming Contest. These experiences have solidified[səˈlɪdɪˌfaɪ] my interest and skills in algorithm.
### 优势

## 专业问题
### 二叉搜索树
A Binary Search Tree (BST) is a type of binary tree where each node has at most two children. The key rule is that the left child has a smaller value, and the right child has a larger value. This structure makes searching, inserting, and deleting values efficient.

To search, start at the root, compare the value, and move left or right accordingly until you find the value or reach a leaf. Inserting works the same way, and you place the new value where you find a suitable spot. Deletion involves replacing the node with its in-order successor[səkˈsesər] or predecessor[ˈpredəˌsesər] if it has two children.

In a balanced BST, search, insert, and delete operations take O(log n) time. In the worst case, if the tree is unbalanced, these operations take O(n) time.
### 死锁
Deadlock is a situation in computer systems where two or more processes cannot continue because each one is waiting for the other to release a resource. This happens when four conditions occur at the same time:
1. Processes must hold resources that others need.
2. Processes keep their resources while waiting for more.
3. Resources cannot be taken away; 
4. A cycle of processes exists, where each process waits for a resource held by the next process in the cycle.
### 快速排序
Quicksort is a fast sorting algorithm used to arrange numbers or other items in order. It works by selecting a "pivot[ˈpɪvət]" element from the array and then rearranging[ˌriəˈreɪndʒ] the other elements into two groups: those less than the pivot and those greater than the pivot. The pivot is then in its final position. This process is repeated for the two groups, recursively sorting the sub-arrays.
Quicksort is efficient with an average time complexity of O(n log n), but in the worst case, it can be O(n^2). However, with good pivot selection, it usually performs very well.
### 冒泡排序
Bubble Sort is a simple sorting algorithm that arranges items in order by repeatedly stepping through the list, comparing each pair of adjacent[əˈdʒeɪs(ə)nt] items, and swapping them if they are in the wrong order.  You then start again from the beginning and repeat the process until no swaps are needed, meaning the list is sorted. Bubble Sort has a time complexity of O(n^2), which makes it inefficient for large lists, but it is easy to understand and implement.
### 归并排序
Merge Sort is a sorting algorithm that uses a divide and conquer approach to sort items. It works by dividing the list into smaller sublists until each sublist has only one item. Then, it repeatedly merges these sublists to produce new sorted sublists until there is only one sorted list remaining. The main steps are to split the list into halves, sort each half, and then merge the sorted halves together. Merge Sort has a time complexity of O(n log n), making it efficient for large lists.
### 希尔排序
Shell Sort is an advanced version of insertion sort that improves efficiency by comparing and sorting elements that are far apart. It starts by sorting elements with a large gap between them, then progressively[prəʊˈɡresɪvli] reduces the gap and sorts the elements again. This process continues until the gap is 1, at which point it performs a final insertion sort. By starting with larger gaps, Shell Sort moves elements closer to their final position faster, which reduces the total number of movements needed. The time complexity of Shell Sort can vary, but it generally performs much better than O(n^2) for large lists.
### TCP/IP