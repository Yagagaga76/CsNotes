##  线性代数
## 概率论
## 编译原理
### 编译器的前端和后端都包含什么内容
- 前端：词法分析；语法分析；语义分析；中间代码生成
- 后端：中间代码优化；目标代码生成；目标代码优化
### gcc 与 llvm

-  gcc 传统编译器结构
	-  ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240522120214.png)
-  llvm 结构
	-  ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240522120223.png)
- llvm 模块化设计：
	- 使用统一的中间代码 llvm ir
	- 如果需要支持一种新的编程语言，那么只需要实现一个新的前端；如果需要支持一种新的硬件设备，那么只需要实现一个新的后端
	- 而优化是一个通用的针对 ir 的阶段
	- 相比之下，GCC 的前端和后端没分得太开，前端后端耦合在了一起。
- GCC 是**单体设计**的传统编译器，前端、优化器和后端紧密耦合。LLVM 则是**模块化设计**，前端、优化器和后端松散耦合，使用统一的 LLVM IR。GCC 扩展难度大，而 LLVM**易于扩展和修改**。GCC 提供独立开发的完整工具链，LLVM 则提供无缝协作的统一工具链。性能方面，LLVM 在处理高级语言特性和跨模块优化时表现更好。
## 程序设计语言&常识
### 面相对象程序设计
#### 抽象与封装
- 过程式程序设计：过程抽象与封装，数据公开缺乏保护，隐藏过程函数的实现方式
- 面相对象程序设计：数据抽象与封装，描述数据能进行哪些操作，只能通过对外接口进行访问
### C++
#### 内存分区
- 内存 5 大区
	- **栈区**：局部变量、参数、返回地址
	- **堆区**：动态内存分配（生命周期较长）
	- **全局/静态存储区**：存储全局变量、静态变量、常亮（程序开始时分配，程序结束时释放）全局变量和静态局部变量放在一块，未初始化的放在另一块。
	- **文字常量区**：常量在统一运行被创建，常量区的内存是只读的，程序结束后由系统释放。
	- **程序代码区**：存放程序的二进制代码，内存由系统管理
#### 虚函数与虚继承
- 虚函数的工作原理
	- **虚函数表（vtable）**：当一个类中声明了虚函数，编译器会为这个**类**生成一个虚函数表。这个表是一个函数指针数组，数组中的每个元素都是**指向类的虚函数的指针**。**每个类**的虚函数表是**唯一**的，所有该类的对象都共享同一个虚函数表。
	- **虚指针（vptr）**：当一个类对象被创建时，如果该类中有虚函数，那么编译器会在对象内部添加一个虚指针。这个**虚指针指向该类的虚函数表**。
	- **动态绑定**：当我们通过基类指针或引用调用虚函数时，编译器会查找指针或引用所指向的对象的虚指针，然后通过虚指针找到对应的虚函数表，最后**在虚函数表中查找并调用相应的虚函数**。这个过程是在运行时进行的，因此称为动态绑定。
	- ![](https://thdlrt.oss-cn-beijing.aliyuncs.com/898333-20160609210418246-1188626035.png)
- 虚函数表在**编译**时期创建，为每个有虚函数的类生成一个虚函数表虚函数指针在**对象构造**时进行初始化，在构造函数的代码中插入设置虚函数表指针的操作
- **构造函数一般不定义为虚函数**: 虚函数表指针是在创建对象之后才有的，因此不能定义成虚函数。
- **析构函数一般定义成虚函数**：析构函数定义成虚函数是为了防止内存泄漏

- 虚继承的实现原理
	- 使用一个虚基类表，虚基类指针
	- 虚表中记录了虚基类与本类的偏移地址
	- 通过**虚基类指针引用公共对象**，对象中**只保存一份**父类的对象，确保了无论通过哪个派生路径访问基类，都是**同一个实例。**
- 在普通的继承关系中：派生类的构造函数只能通过**中间类的构造函数**来间接调用基类的构造函数。虚继承关系中派生类可以**直接调用**，不需要通过中间类
#### 构造函数
- 拷贝构造函数使用时机：由同类对象创建对象；值传递作为函数参数；对象作为函数返回值
- 构造顺序：基类-成员对象（进入自身构造函数函数体之前进行）-对象自身
	- 析构时本身类析构函数的**函数体执行完之后**，再去调用成员对象类的析构函数。
- 
### JAVA
- 
### 杂项