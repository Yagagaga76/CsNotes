## 计算机系统概述
- 计算机系统包括：配套的硬件设备和软件系统
- 冯诺依曼结构：**运算器，控制器，存储器，输入输出设备**
	- ![image-20230215132410399](https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20230215132410399.png)
	- 基本工作方式是：**控制流驱动方式**
- 软件和硬件具有**逻辑上的等价性**，硬件的执行速度快，软件更灵活（频繁使用的应该考虑使用硬件实现），功能上可以相互替代
- 存储程序基本思想：将**事先编好的程序和原始数据送入主存**后才能执行程序，启动执行后，计算机能在不需要操作人员干预下自动完成逐条指令去除和执行的任务
	- 根据 PC 取指令（PC-MAR-M-MDR-IR）
	- 指令译码 (IR-CU)
	- 取操作数，执行指令 (IP-MAR-M)-MDR-ACC)
	- 回写结果，修改 PC 的值，执行下一指令
- ![image-20230215133038262](https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20230215133038262.png)
	- 存储器：主存储器，外存储器，MAR 存储器地址寄存器（cpu 送地址），MDR 存储器数据寄存器（收集来的信息），地址译码器，（实际上 MAR、MDR 通常集成在 CPU）
	- 控制器：IR 指令寄存器，PC 程序计数器，控制单元；IR 的数据来自 MDR，指令送往控制单元，地址码送往 MAR
- IR、MAR、MDR 对程序员透明（包含汇编程序员）
- 计算机软件的分类：
	- 按照功能分类：系统软件、应用软件
	- 三个级别语言：机器语言、汇编语言、高级语言
	- 翻译程序的分类：汇编程序（汇编-机器），编译程序（高级-汇编、机器），解释程序（逐条翻译，立即执行）
- 计算机的层次结构
	- ![image-20230216085237389](https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20230216085237389.png)
- 可执行文件的生成
	- ![image-20230215235043129](https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20230215235043129.png)
### 性能指标
- 机器字长：计算机进行一次整数运算，能处理的二进制数据的位数；此外字长一般等于通用**寄存器位数、ALU 宽度等**
	- 通常来说一个字的大小等于字长，是计算机处理数据的基本单位
	- 机器字长是 **CPU 一次性能处理**的最大数据位数，影响**运算精确度**
	- 存储字长是计算机**内存中一次可存取**的表示数据或指令的位数
	- 指令字长是每条指令的标准长度。
	- 字长足够时可以表示任何一个整数，但是仍然不能精确表示所有小数
- 主存容量：MAR 的位数反映存储单元数目，MDR 位数反映存储单元字长（如 64 K\*32 位）
- 计算机性能评估：**吞吐量/响应时间** 
- CPU 的**主频和时钟周期**呈倒数关系
- CPI 表示执行一条指令需要的时钟周期数（是所有指令的平均值）
	- IPS (IPC)每秒执行多少指令，IPS=主频/平均 CPI
	- MIPS：每秒执行多少百万条指令
- CPU **执行时间**=指令数目\*CPI/主频
- 浮点数的运算指标
	- ![](https://thdlrt.oss-cn-beijing.aliyuncs.com/16774890976414.jpg)
## 数据的表示和运算
### 定点数的编码表示
- 原码：表示浮点数的小数部分
	- 表示整数的范围是 $-(2^n-1)\to(2^n-1)$
	- 与真值的转化简单，但是难以实现加减法，并且存在两个 0
- 补码：表示整数
	- 正数的补码为其自身，负数各位取反末位加一（即模减去负数的绝对值）综合为 **$2^{n+1}+x$（补码的本质）**
	- 表示范围为 $-2^n\to 2^{n}-1$
	- 特殊值
		- 0:0000...
		- -1:1111...
		- -2147483648:1000...
		- 2147483647:0111...
	- 双符号位（模 4 补码）
		- 00：正数，无溢出
		- 01：正溢出
		- 10：负溢出
		- 11：负数无溢出
		- 更容易检查加减运算中的溢出问题
		- 存储时仍然只有一位，只是送到 ALU 计算时复制为了两份
- 移码：浮点数的阶码
	- 译码就是再真值上加一个偏置值 （通常是最大正数的一半） $[x]_{移}=2^n+x(-2^n\leq x<2^n)$ 使得包括负数在内的所有数值的**表示都是正的**
	- 移码和补码表示实际上只差了一个符号位（移码中 0 表示负数，1 表示正数）（移码实际上和补码差一个 $2^n$）
	- +5和-5分别表示为 `10000100`（132，即127+5）和 `01111000`（122，即127-5）
	- 使用移码作为阶码的好处：比较大小更为方便，检查特殊值（0，max）比较容易
- 无符号数与有符号数
	- C 语言中长变短直接截断；短变长对于无符号整数进行零扩展，有符号整数进行符号扩展
### 运算方法与电路
- 运算器由 ALU、移位器、多路选择器、状态寄存器和通用寄存器等组成
- 带标志加法器
	- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231105174629282.png" alt="image-20231105174629282" style="zoom:50%;" />
	- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231105174550051.png" alt="image-20231105174550051" style="zoom:33%;" />
	- **（有符号）溢出标志位**$OF=C_n\bigoplus C_{n-1}$
	- 符号标志 $SF=F_{n-1}$
	- 零标志位 $ZF=1 \ iff \ F=0$
	- **（无符号）进位、借位标志**$CF=Cout\bigoplus Cin$
    - $Cin=sub=1$（这里这个 1 的作用就是减法时的"**各位取反，末位加一**"）
- 移位操作
	- 逻辑移位：左移出 1 是发生溢出
	- 算术移位：右移补符号，移出 1 会损失精度；**左移前后符号位不同**，发生溢出
#### 加减法
$$
\displaylines{
[X+Y]_补=[X]_补+[Y]_补(mod \ 2^n)\\
    [X-Y]_补=[X]_补+[-Y]_补(mod \ 2^n)\\
}
$$
- 做加法直接补码相加，做减法**将被减数与减数的负数补码**相加，最终运算结果的高位丢弃。
- 发生溢出的判断：两个正数相加结果为负数，两个负数相加结果为正数
- 加减法电路
	- ![image.png|475](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231231160805.png)
	- sub 为 1 时可以实现 $X+\overline Y+1$
- 无符号数大小比较
	- ZF=1 表示 A=B
	- ZF=0 CF=0 表示 A>B
	- ZF=0 CF=1 表示 A\<B
- 有符号数大小比较
	- ZF=1 表示 A=B
	- OF^SF=0 ZF=0 表示 A>B
	- OF^SF=1 ZF=0 表示 A>B
- 对于原码加减法，分开处理符号位和数值位
#### 原码定点数乘除法
- 乘法原理
	-  <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231105182304501.png" alt="image-20231105182304501" style="zoom:33%;" />
	- 不溢出的条件（假设 32 位相乘）：无符号数高 32 位为 0，有符号数为符号位
- 乘法运算电路
	- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231105185939698.png" alt="image-20231105185939698" style="zoom:33%;" />
	- C 存储加法 p 的进位，每次根据 Y 的最低位决定是否进行加法
- 除法原理
	- 首先需要将 n 位的被除数扩展到 2 n 位，小数低位补 0，整数高位补 0
	- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231105230733853.png" alt="image-20231105230733853" style="zoom:33%;" />
	- 用 2n 的被除数除以 n 位除数得到的商位 n+1 位，如果第一次试商的结果为 1 则表示发生了溢出（无法用 n 位进行表示）
- 除法运算电路
	- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231105230954470.png" alt="image-20231105230954470" style="zoom:33%;" />
	- 每次在高位进行试减，根据结果对 Q 左移并上商
	- 最终 Q 中存储商，而 R 中存储余数
### 浮点数的运算与表示
- 使用浮点数表示法既扩大了数的表示范围，又保持了数的有效精度
- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/16774988380176.jpg" style="zoom: 50%;" />
	- 符号位为1/0，**尾数阶数全为0**表示0
	- 阶数为0，尾数不为0表示非规格化浮点数，即为了可以表示更小的浮点数，通过去掉前导的1来实现
	- **尾数为0，阶数全1**表示正负无穷 inf
	- **尾数不为零，阶数全为1**表示非数字 NaN
- **规格化尾数**的要求
	- 规格化的目的：可以多表示一位，增加数据的表示精度
	- 补码表示尾数要求第一位与补码符号位不同
	- 4 为基要求前两位不同
- 浮点数的规格化
	- 左规：当尾数的最高位不为 1 时，进行左规，左移 1 位阶码减 1
	- 右规：当尾数的**有效位进到了小数点前面**，需要进行右规，右规只会进行一次，尾数右移阶码加 1（尾数舍入可能导致右规，并且只有右规可能导致舍入，因为左规移出的都是 0）
- 单精度浮点数的偏置常数为 127 而不是 128（因为实际上移码只用了 154 个，剩下 2 个表示特殊含义）
- 浮点数的加减运算
	- **对阶**：使操作数小数点对齐（阶码相同），将小阶码向大的看齐（尾数右移一位阶码加一）对阶不会导致溢出
	- 尾数加减（注意还原隐藏位）
	- **尾数规格化**：右规/左规
	- **舍入**：在**对阶和右规**中需要对尾数右移，为了保证精度，一般先将移出的部分低位**保留下来**，参加中间过程的运算，最后再进行舍入（定点数不存在舍入）
		- 就近舍入：0 舍 1 入
		- 正向舍入：取右边最近可表示数
		- 负向舍入：取左边最近可表示数
		- 截断法：丢弃多余位（向原点舍入）
	- 溢出判断
		- 指数上溢：右规时发生
		- 指数下溢：左规可能导致
### 大端与小端存储
- lsb、msb 表示最低、高有效位
	- 如 int：01234567 H 的 MSB=01H LSB=67H
- 大端方式：msb 所在地址为数的地址
- 小端方式：lsb 所在地址为数的地址
- 如：`FF AF 00 23`
	- 从大端还原：`FF AF 00 23`
	- 从小端还原：`23 00 AF FF`
### 存储对齐
- CPU 访问主存时只能一次读取或写入若干特定位，因此如果数据的存储不满足这个规律则会导致对统一数据需要**多次存取**才能完整的到数据，会降低效率，因此需要进行对齐
	- ![image.png|450](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240404112730.png)
- 结构体对齐
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240404112819.png) 
## 层次存储系统
- 按照层次分类
	- 主存储器：内存，可以直接访问
	- 辅助存储器：外存，调入主存之后才能被 CPU 访问
	- 高速缓冲器（Cache）：位于主存和 CPU 之间，通常在 CPU 中
- 按照存取方式分类
	- 随机存储器 RAM：随机读取，并且时间物理位置无关，用作主存、高速缓冲器
	- 只读存储器 ROM：一旦写入就不能更改（断电也不会丢失）
	- 顺序存取存储器 SAM：数据按顺序从存储载体的始端读出或写入，因而存取时间的长短与信息所在位置有关。例如：磁带
	- 直接存取存储器 DAM：直接定位到读写数据块，在读写数据块时按顺序进行。如磁盘。
	- 相联存储器 CAM：按**内容检索**（而不是根据位置）到存储位置进行读写。例如：快表。
	- 串行访问寄存器：按照物理位置顺序寻址 (如硬盘，光盘)
- 信息的可保存性
	- 易失性：断电后存储内容消失如 RAM，Cache
	- 非易失性：如 ROM
-  ![image-20230507214759948](https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20230507214759948.png)
- 层次存储结构
	- ![image-20230507215120882|475](https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20230507215120882.png)
	- 将上一层的存储器作为低一层存储器的高速缓存，数据总是在相邻的两层之间传送 (除了 CPU 和主存)
	- **时间局部性**：刚被访问过的单元可能不久又被访问
	- **空间局部性**：刚被访问的单元的临近单元可能不久被访问
#### 性能指标
- 存储容量
	- 存储成本：每位加个=总成本/总容量
- 存储速度
	- 存取时间 $T_{a}$：从 CPU**送出内存单元的地址码**开始，到主存**读出** 数据并送到 CPU（或者是把 CPU 数据写入主存）所需要的时间，分**读取时间和写入时间**
	- 存取周期 $T_{m}$：连读**两次访问**存储器所需的最小时间间隔，即**存取时间+恢复时间**
	- 存储器带宽 $B_{m}$：每秒从主存进出信息的最大数量
### 主存储器
- RAM 的分类
	- SRAM：双稳态触发器，速度快，非破坏性读出，功耗大价格贵，用于 cache
	- DRAM：使用一个晶体管，密度高功耗低，速度慢，需要定时刷新以及读后再生，用于主存
- 二维地址译码系统：
	- ![image-20230507220410642|450](https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20230507220410642.png)
	- 通常来说 x y 共用地址线（分时复用），因此添加一条地址线寻址范围编程 4 倍（为了更好的进行地址复用，以及减少行刷新的次数，通常 $l\leq r$）
	- 对于 16 M_DRAM (4\*4 M)：$16M=2^{11}2^{11}4$，即 11 根地址线分时复用；需 4 个位平面，对相同行、列交叉点的 **4 位一起读/写**
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240410144203.png)

- DRAM 的电容只能维持 1-2 ms，并且独处后也需要再生，因此要进行刷新：每隔一段时间，将原内存的数据读出经过刷新放大器并重新写入，**占用一个存取周期**
	- 集中刷新：在集中刷新期间不能正常访问存储器
	- 分散刷新：将存储器系统的工作周期划分，前半部分读写，后半部分进行刷新，没有死区但是存取周期延长
	- **异步刷新**：将刷新时间除以行数，使得相邻两行之间刷新的时间间隔为他，使得死时间更加分散（这就是为什么 DRAM 要行刷新）
- 传统 DRAM 与 CPU 之间采用异步方式交换数据，CPU 发出地址和控制信号后，经过一段延迟时间，数据才读出或写入。在这段时间里，CPU 不断采样 DRAM 的完成信号，CPU 插入等待状态而**不能做其他工作**。而 SDRAM 芯片则不同，其读写受外部系统时控制，因此与 CPU 之间采用同步方式交换数据。它将 CPU 或其他主设备发出的地址和控制信息锁存起来，经过**确定的**几个时钟周期后给出响应。因此，主设备在这段时间内，可以**安全地进行其他操作**。
#### 内存的物理构成
- ![image-20230507223901570](https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20230507223901570.png)
	- 行缓冲是对某一行的所有列进行缓冲
	- 单个内存条由多个存储芯片共同构成（图中就是 16 个），不同芯片中同一个位置构成一个超元，同时进行读取
	- 轮流启动方式，一次只能读取一个芯片，假设模块的存取周期为 T，总线周期为 r，那么为了保证高效率的轮流启动，应该保证模块数目 $m\geq \frac{T}{r}$ 这样读取 m 个字（模块）需要的时间为 $T+(m-1)r$
- 为什么要进行内存对齐
	- 一次读取是对内存条中多个存储芯片进行读取，即只能是（1~16,17~32...）
	- 交叉编址<img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20230507231556356.png" alt="image-20230507231556356" style="zoom: 25%;" />
- 扩展存储
	- 位扩展和字扩展**都会增大**存储的容量
	- 位扩展：若干片位数较少的存储器芯片构成给定字长的存储器。如用 8 片 4 Kx 1 位的芯片构成 4 K x 8 位的存储器，需在位方向上扩展 8 倍，而字方向上无须扩展。不改变控制位的数目 (**只能同时读取**)
	- 字扩展：字扩展是**容量的扩充**，**位数不变**。例如，用 16 Kx 8 位的存储芯片在字方向上扩展 4 倍，构成一个 64 Kx 8 位的存储器。字扩展会增加控制位的数目（**可以不同时读取**）
- 
#### 主存储器的读取与写入
- 
### 外部存储器
- 
### 高速缓存
- 
### 虚拟存储器&地址转换
- 
## 指令系统
## 中央处理器
## 总线
## 输入输出 IO