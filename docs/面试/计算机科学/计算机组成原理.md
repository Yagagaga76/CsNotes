## 计算机系统概述
- 计算机系统包括：配套的硬件设备和软件系统
- 冯诺依曼结构：**运算器，控制器，存储器，输入输出设备**
	- ![image-20230215132410399](https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20230215132410399.png)
	- 基本工作方式是：**控制流驱动方式**
- 软件和硬件具有**逻辑上的等价性**，硬件的执行速度快，软件更灵活（频繁使用的应该考虑使用硬件实现），功能上可以相互替代
- 存储程序基本思想：将**事先编好的程序和原始数据送入主存**后才能执行程序，启动执行后，计算机能在不需要操作人员干预下自动完成逐条指令去除和执行的任务
	- 根据 PC 取指令（PC-MAR-M-MDR-IR）
	- 指令译码 (IR-CU)
	- 取操作数，执行指令 (IP-MAR-M)-MDR-ACC)
	- ，回写结果，修改 PC 的值，执行下一指令
- ![image-20230215133038262](https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20230215133038262.png)
	- 存储器：主存储器，外存储器，MAR 存储器地址寄存器（cpu 送地址），MDR 存储器数据寄存器（收集来的信息），地址译码器，（实际上 MAR、MDR 通常集成在 CPU）
	- 控制器：IR 指令寄存器，PC 程序计数器，控制单元；IR 的数据来自 MDR，指令送往控制单元，地址码送往 MAR
- IR、MAR、MDR 对程序员透明（包含汇编程序员）
- 计算机软件的分类：
	- 按照功能分类：系统软件、应用软件
	- 三个级别语言：机器语言、汇编语言、高级语言
	- 翻译程序的分类：汇编程序（汇编-机器），编译程序（高级-汇编、机器），解释程序（逐条翻译，立即执行）
- 计算机的层次结构
	- ![image-20230216085237389](https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20230216085237389.png)
- 可执行文件的生成
	- ![image-20230215235043129](https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20230215235043129.png)
### 性能指标
- 机器字长：计算机进行一次整数运算，能处理的二进制数据的位数；此外字长一般等于通用**寄存器位数、ALU 宽度等**
	- 通常来说一个字的大小等于字长，是计算机处理数据的基本单位
	- 机器字长是 **CPU 一次性能处理**的最大数据位数，影响**运算精确度**
	- 存储字长是计算机**内存中一次可存取**的表示数据或指令的位数
	- 指令字长是每条指令的标准长度。
	- 字长足够时可以表示任何一个整数，但是仍然不能精确表示所有小数
- 主存容量：MAR 的位数反映存储单元数目，MDR 位数反映存储单元字长（如 64 K\*32 位）
- 计算机性能评估：**吞吐量/响应时间** 
- CPU 的**主频和时钟周期**呈倒数关系
- CPI 表示执行一条指令需要的时钟周期数（是所有指令的平均值）
	- IPS 每秒执行多少指令，IPS=主频/平均 CPI
	- MIPS：每秒执行多少百万条指令
- CPU **执行时间**=指令数目\*CPI/主频
- 浮点数的运算指标
	- ![](https://thdlrt.oss-cn-beijing.aliyuncs.com/16774890976414.jpg)
## 数据的表示和运算
### 定点数的编码表示
- 原码：表示浮点数的小数部分
	- 表示整数的范围是 $-(2^n-1)\to(2^n-1)$
	- 与真值的转化简单，但是难以实现加减法，并且存在两个 0
- 补码：表示整数
	- 正数的补码为其自身，负数各位取反末位加一（即模减去负数的绝对值）综合为 **$2^{n+1}+x$（补码的本质）**
	- 表示范围为 $-2^n\to 2^{n}-1$
	- 特殊值
		- 0:0000...
		- -1:1111...
		- -2147483648:1000...
		- 2147483647:0111...
	- 双符号位（模 4 补码）
		- 00：正数，无溢出
		- 01：正溢出
		- 10：负溢出
		- 11：负数无溢出
		- 更容易检查加减运算中的溢出问题
		- 存储时仍然只有一位，只是送到 ALU 计算时复制为了两份
- 移码：浮点数的阶码
	- 译码就是再真值上加一个偏置值 （通常是最大正数的一半） $[x]_{移}=2^n+x(-2^n\leq x<2^n)$ 使得包括负数在内的所有数值的**表示都是正的**
	- 移码和补码表示实际上只差了一个符号位（移码中 0 表示负数，1 表示正数）（移码实际上和补码差一个 $2^n$）
	- +5和-5分别表示为 `10000100`（132，即127+5）和 `01111000`（122，即127-5）
	- 使用移码作为阶码的好处：比较大小更为方便，检查特殊值（0，max）比较容易
- 无符号数与有符号数
	- C 语言中长变短直接截断；短变长对于无符号整数进行零扩展，有符号整数进行符号扩展
### 运算方法与电路
- 运算器由 ALU、移位器、多路选择器、状态寄存器和通用寄存器等组成
- 带标志加法器
	- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231105174629282.png" alt="image-20231105174629282" style="zoom:50%;" />
	- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231105174550051.png" alt="image-20231105174550051" style="zoom:33%;" />
	- **（有符号）溢出标志位**$OF=C_n\bigoplus C_{n-1}$
	- 符号标志 $SF=F_{n-1}$
	- 零标志位 $ZF=1 \ iff \ F=0$
	- **（无符号）进位、借位标志**$CF=Cout\bigoplus Cin$
    - $Cin=sub=1$（这里这个 1 的作用就是减法时的"**各位取反，末位加一**"）
- 移位操作
	- 逻辑移位：左移出 1 是发生溢出
	- 算术移位：右移补符号，移出 1 会损失精度；**左移前后符号位不同**，发生溢出
#### 加减法
$$
\displaylines{
[X+Y]_补=[X]_补+[Y]_补(mod \ 2^n)\\
    [X-Y]_补=[X]_补+[-Y]_补(mod \ 2^n)\\
}
$$
- 做加法直接补码相加，做减法**将被减数与减数的负数补码**相加，最终运算结果的高位丢弃。
- 发生溢出的判断：两个正数相加结果为负数，两个负数相加结果为正数
- 加减法电路
	- ![image.png|475](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231231160805.png)
	- sub 为 1 时可以实现 $X+\overline Y+10$
- 无符号数大小比较
	- ZF=1 表示 A=B
	- ZF=0 CF=0 表示 A>B
	- ZF=0 CF=1 表示 A\<B
- 有符号数大小比较
	- ZF=1 表示 A=B
	- OF^SF=0 ZF=0 表示 A>B
	- OF^SF=1 ZF=0 表示 A>B
- 对于原码加减法，分开处理符号位和数值位
#### 原码定点数乘除法
- 乘法原理
	-  <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231105182304501.png" alt="image-20231105182304501" style="zoom:33%;" />
	- 不溢出的条件（假设 32 位相乘）：无符号数高 32 位为 0，有符号数为符号位
- 乘法运算电路
	- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231105185939698.png" alt="image-20231105185939698" style="zoom:33%;" />
	- C 存储加法 p 的进位，每次根据 Y 的最低位决定是否进行加法
- 除法原理
	- 首先需要将 n 位的被除数扩展到 2 n 位，小数低位补 0，整数高位补 0
	- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231105230733853.png" alt="image-20231105230733853" style="zoom:33%;" />
	- 用 2n 的被除数除以 n 位除数得到的商位 n+1 位，如果第一次试商的结果为 1 则表示发生了溢出（无法用 n 位进行表示）
- 除法运算电路
	- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231105230954470.png" alt="image-20231105230954470" style="zoom:33%;" />
	- 每次在高位进行试减，根据结果对 Q 左移并上商
	- 最终 Q 中存储商，而 R 中存储余数
### 浮点数的运算与表示
- 使用浮点数表示法既扩大了数的表示范围，又保持了数的有效精度
- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/16774988380176.jpg" style="zoom: 50%;" />
	- 符号位为1/0，**尾数阶数全为0**表示0
	- 阶数为0，尾数不为0表示非规格化浮点数，即为了可以表示更小的浮点数，通过去掉前导的1来实现
	- **尾数为0，阶数全1**表示正负无穷 inf
	- **尾数不为零，阶数全为1**表示非数字NaN
- 浮点数的规格化
	- 左规：当尾数的最高位不为 1 时，进行左规，左移 1 位阶码减 1
	- 右规：当尾数的有效位进到了小数点前面，需要进行右规，右规只会进行一次，尾数右移阶码加 1
- 单精度浮点数的偏置常数为 127 而不是 128（因为实际上移码只用了 154 个，剩下 2 个表示特殊含义）
- 浮点数的加减运算
	- **对阶**：使操作数小数点对齐（阶码相同），将小阶码向大的看齐（尾数右移一位阶码加一）
	- 尾数加减（注意还原隐藏位）
	- **尾数规格化**：右规/左规
	- **舍入**：在对阶和右规中需要对尾数右移，为了保证精度，一般先将移出的部分低位**保留下来**，参加中间过程的运算，最后再进行舍入
		- 就近舍入：0 舍 1 入
		- 正向舍入：取右边最近可表示数
		- 负向舍入：取左边最近可表示数
		- 截断法：丢弃多余位（向原点舍入）
	- 溢出判断
		- 指数上溢：右规时发生
		- 指数下溢：左规可能导致阶码变成全 0
#### 大端与小端存储
- 