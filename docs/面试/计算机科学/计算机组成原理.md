## 计算机系统概述
- 计算机系统包括：配套的硬件设备和软件系统
- 冯诺依曼结构：**运算器，控制器，存储器，输入输出设备**
	- ![image-20230215132410399](https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20230215132410399.png)
	- 基本工作方式是：**控制流驱动方式**
- 软件和硬件具有**逻辑上的等价性**，硬件的执行速度快，软件更灵活（频繁使用的应该考虑使用硬件实现），功能上可以相互替代
- 存储程序基本思想：将**事先编好的程序和原始数据送入主存**后才能执行程序，启动执行后，计算机能在不需要操作人员干预下自动完成逐条指令去除和执行的任务
	- 根据 PC 取指令（PC-MAR-M-MDR-IR）
	- 指令译码 (IR-CU)
	- 取操作数，执行指令 (IP-MAR-M)-MDR-ACC)
	- 回写结果，修改 PC 的值，执行下一指令
- ![image-20230215133038262](https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20230215133038262.png)
	- 存储器：主存储器，外存储器，MAR 存储器地址寄存器（cpu 送地址），MDR 存储器数据寄存器（收集来的信息），地址译码器，（实际上 MAR、MDR 通常集成在 CPU）
	- 控制器：IR 指令寄存器，PC 程序计数器，控制单元；IR 的数据来自 MDR，指令送往控制单元，地址码送往 MAR
- IR、MAR、MDR 对程序员透明（包含汇编程序员）
- 计算机软件的分类：
	- 按照功能分类：系统软件、应用软件
	- 三个级别语言：机器语言、汇编语言、高级语言
	- 翻译程序的分类：汇编程序（汇编-机器），编译程序（高级-汇编、机器），解释程序（逐条翻译，立即执行）
- 计算机的层次结构
	- ![image-20230216085237389](https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20230216085237389.png)
- 可执行文件的生成
	- ![image-20230215235043129](https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20230215235043129.png)
### 性能指标
- 机器字长：计算机进行一次整数运算，能处理的二进制数据的位数；此外字长一般等于通用**寄存器位数、ALU 宽度等**
	- 通常来说一个字的大小等于字长，是计算机处理数据的基本单位
	- 机器字长是 **CPU 一次性能处理**的最大数据位数，影响**运算精确度**
	- 存储字长是计算机**内存中一次可存取**的表示数据或指令的位数
	- 指令字长是每条指令的标准长度。
	- 字长足够时可以表示任何一个整数，但是仍然不能精确表示所有小数
- 主存容量：MAR 的位数反映存储单元数目，MDR 位数反映存储单元字长（如 64 K\*32 位）
- 计算机性能评估：**吞吐量/响应时间** 
- CPU 的**主频和时钟周期**呈倒数关系
- CPI 表示执行一条指令需要的时钟周期数（是所有指令的平均值）
	- IPS (IPC)每秒执行多少指令，IPS=主频/平均 CPI
	- MIPS：每秒执行多少百万条指令
- CPU **执行时间**=指令数目\*CPI/主频
- 浮点数的运算指标
	- ![](https://thdlrt.oss-cn-beijing.aliyuncs.com/16774890976414.jpg)
## 数据的表示和运算
### 定点数的编码表示
- 原码：表示浮点数的小数部分
	- 表示整数的范围是 $-(2^n-1)\to(2^n-1)$
	- 与真值的转化简单，但是难以实现加减法，并且存在两个 0
- 补码：表示整数
	- 正数的补码为其自身，负数各位取反末位加一（即模减去负数的绝对值）综合为 **$2^{n+1}+x$（补码的本质）**
	- 表示范围为 $-2^n\to 2^{n}-1$
	- 特殊值
		- 0:0000...
		- -1:1111...
		- -2147483648:1000...
		- 2147483647:0111...
	- 双符号位（模 4 补码）
		- 00：正数，无溢出
		- 01：正溢出
		- 10：负溢出
		- 11：负数无溢出
		- 更容易检查加减运算中的溢出问题
		- 存储时仍然只有一位，只是送到 ALU 计算时复制为了两份
- 移码：浮点数的阶码
	- 译码就是再真值上加一个偏置值 （通常是最大正数的一半） $[x]_{移}=2^n+x(-2^n\leq x<2^n)$ 使得包括负数在内的所有数值的**表示都是正的**
	- 移码和补码表示实际上只差了一个符号位（移码中 0 表示负数，1 表示正数）（移码实际上和补码差一个 $2^n$）
	- +5和-5分别表示为 `10000100`（132，即127+5）和 `01111000`（122，即127-5）
	- 使用移码作为阶码的好处：比较大小更为方便，检查特殊值（0，max）比较容易
- 无符号数与有符号数
	- C 语言中长变短直接截断；短变长对于无符号整数进行零扩展，有符号整数进行符号扩展
### 运算方法与电路
- 运算器由 ALU、移位器、多路选择器、状态寄存器和通用寄存器等组成
- 带标志加法器
	- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231105174629282.png" alt="image-20231105174629282" style="zoom:50%;" />
	- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231105174550051.png" alt="image-20231105174550051" style="zoom:33%;" />
	- **（有符号）溢出标志位**$OF=C_n\bigoplus C_{n-1}$
	- 符号标志 $SF=F_{n-1}$
	- 零标志位 $ZF=1 \ iff \ F=0$
	- **（无符号）进位、借位标志**$CF=Cout\bigoplus Cin$
    - $Cin=sub=1$（这里这个 1 的作用就是减法时的"**各位取反，末位加一**"）
- 移位操作
	- 逻辑移位：左移出 1 是发生溢出
	- 算术移位：右移补符号，移出 1 会损失精度；**左移前后符号位不同**，发生溢出
#### 加减法
$$
\displaylines{
[X+Y]_补=[X]_补+[Y]_补(mod \ 2^n)\\
    [X-Y]_补=[X]_补+[-Y]_补(mod \ 2^n)\\
}
$$
- 做加法直接补码相加，做减法**将被减数与减数的负数补码**相加，最终运算结果的高位丢弃。
- 发生溢出的判断：两个正数相加结果为负数，两个负数相加结果为正数
- 加减法电路
	- ![image.png|475](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231231160805.png)
	- sub 为 1 时可以实现 $X+\overline Y+1$
- 无符号数大小比较
	- ZF=1 表示 A=B
	- ZF=0 CF=0 表示 A>B
	- ZF=0 CF=1 表示 A\<B
- 有符号数大小比较
	- ZF=1 表示 A=B
	- OF^SF=0 ZF=0 表示 A>B
	- OF^SF=1 ZF=0 表示 A>B
- 对于原码加减法，分开处理符号位和数值位
#### 原码定点数乘除法
- 乘法原理
	-  <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231105182304501.png" alt="image-20231105182304501" style="zoom:33%;" />
	- 不溢出的条件（假设 32 位相乘）：无符号数高 32 位为 0，有符号数为符号位
- 乘法运算电路
	- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231105185939698.png" alt="image-20231105185939698" style="zoom:33%;" />
	- C 存储加法 p 的进位，每次根据 Y 的最低位决定是否进行加法
- 除法原理
	- 首先需要将 n 位的被除数扩展到 2 n 位，小数低位补 0，整数高位补 0
	- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231105230733853.png" alt="image-20231105230733853" style="zoom:33%;" />
	- 用 2n 的被除数除以 n 位除数得到的商位 n+1 位，如果第一次试商的结果为 1 则表示发生了溢出（无法用 n 位进行表示）
- 除法运算电路
	- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231105230954470.png" alt="image-20231105230954470" style="zoom:33%;" />
	- 每次在高位进行试减，根据结果对 Q 左移并上商
	- 最终 Q 中存储商，而 R 中存储余数
### 浮点数的运算与表示
- 使用浮点数表示法既扩大了数的表示范围，又保持了数的有效精度
- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/16774988380176.jpg" style="zoom: 50%;" />
	- 符号位为1/0，**尾数阶数全为0**表示0
	- 阶数为0，尾数不为0表示非规格化浮点数，即为了可以表示更小的浮点数，通过去掉前导的1来实现
	- **尾数为0，阶数全1**表示正负无穷 inf
	- **尾数不为零，阶数全为1**表示非数字 NaN
- **规格化尾数**的要求
	- 规格化的目的：可以多表示一位，增加数据的表示精度
	- 补码表示尾数要求第一位与补码符号位不同
	- 4 为基要求前两位不同
- 浮点数的规格化
	- 左规：当尾数的最高位不为 1 时，进行左规，左移 1 位阶码减 1
	- 右规：当尾数的**有效位进到了小数点前面**，需要进行右规，右规只会进行一次，尾数右移阶码加 1（尾数舍入可能导致右规，并且只有右规可能导致舍入，因为左规移出的都是 0）
- 单精度浮点数的偏置常数为 127 而不是 128（因为实际上移码只用了 154 个，剩下 2 个表示特殊含义）
- 浮点数的加减运算
	- **对阶**：使操作数小数点对齐（阶码相同），将小阶码向大的看齐（尾数右移一位阶码加一）对阶不会导致溢出
	- 尾数加减（注意还原隐藏位）
	- **尾数规格化**：右规/左规
	- **舍入**：在**对阶和右规**中需要对尾数右移，为了保证精度，一般先将移出的部分低位**保留下来**，参加中间过程的运算，最后再进行舍入（定点数不存在舍入）
		- 就近舍入：0 舍 1 入
		- 正向舍入：取右边最近可表示数
		- 负向舍入：取左边最近可表示数
		- 截断法：丢弃多余位（向原点舍入）
	- 溢出判断
		- 指数上溢：右规时发生
		- 指数下溢：左规可能导致
### 大端与小端存储
- lsb、msb 表示最低、高有效位
	- 如 int：01234567 H 的 MSB=01H LSB=67H
- 大端方式：msb 所在地址为数的地址
- 小端方式：lsb 所在地址为数的地址
- 如：`FF AF 00 23`
	- 从大端还原：`FF AF 00 23`
	- 从小端还原：`23 00 AF FF`
### 存储对齐
- CPU 访问主存时只能一次读取或写入若干特定位，因此如果数据的存储不满足这个规律则会导致对统一数据需要**多次存取**才能完整的到数据，会降低效率，因此需要进行对齐
	- ![image.png|450](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240404112730.png)
- 结构体对齐
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240404112819.png) 
## 层次存储系统
- 按照层次分类
	- 主存储器：内存，可以直接访问
	- 辅助存储器：外存，调入主存之后才能被 CPU 访问
	- 高速缓冲器（Cache）：位于主存和 CPU 之间，通常在 CPU 中
- 按照存取方式分类
	- 随机存储器 RAM：随机读取，并且时间物理位置无关，用作主存、高速缓冲器
	- 只读存储器 ROM：一旦写入就不能更改（断电也不会丢失）
	- 顺序存取存储器 SAM：数据按顺序从存储载体的始端读出或写入，因而存取时间的长短与信息所在位置有关。例如：磁带
	- 直接存取存储器 DAM：直接定位到读写数据块，在读写数据块时按顺序进行。如磁盘。
	- 相联存储器 CAM：按**内容检索**（而不是根据位置）到存储位置进行读写。例如：快表。
	- 串行访问寄存器：按照物理位置顺序寻址 (如硬盘，光盘)
- 信息的可保存性
	- 易失性：断电后存储内容消失如 RAM，Cache
	- 非易失性：如 ROM
-  ![image-20230507214759948](https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20230507214759948.png)
- 层次存储结构
	- ![image-20230507215120882|475](https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20230507215120882.png)
	- 将上一层的存储器作为低一层存储器的高速缓存，数据总是在相邻的两层之间传送
	- **时间局部性**：刚被访问过的单元可能不久又被访问
	- **空间局部性**：刚被访问的单元的临近单元可能不久被访问
#### 性能指标
- 存储容量
	- 存储成本：每位加个=总成本/总容量
- 存储速度
	- 存取时间 $T_{a}$：从 CPU**送出内存单元的地址码**开始，到主存**读出** 数据并送到 CPU（或者是把 CPU 数据写入主存）所需要的时间，分**读取时间和写入时间**
	- 存取周期 $T_{m}$：连读两次访问存储器所需的最小时间间隔，即**存取时间+恢复时间**
	- 存储器带宽 $B_{m}$：每秒从主存进出信息的最大数量
### 主存储器
- 
### 外部存储器
- 
### 高速缓存
- 
### 虚拟存储器&地址转换
- 
## 指令系统
## 中央处理器
## 总线
## 输入输出 IO