### 什么是数据库
- 数据库专门用于管理数据，应用程序通过数据库提供的接口来读写数据。效率高，通用接口
- **数据**：数据是指对客观事件、事物或对象（称为实体）进行记录的可以鉴别的符号。数据只有对实体行为产生影响时才成为**信息** 。信息是数据的内涵，信息是加载于数据之上，对数据作具有含义的解释。

- 数据库系统的组成：
	- **数据库**：存储数据（数据文件、控制文件、日志文件、参数等）
	- **数据库管理系统**：为管理数据库而设计的一套软件系统
	- 数据库管理软件：为了提高数据库系统的处理能力所使用的配套和辅助软件
- **数据库**用于存储关联数据，要与数据库管理系统区分（DBMS 如 MySQL、Oracle、MongoDB）**数据库管理系统**是为管理数据库而设计的一套软件系统，旨在允许用户和应用程序定义、创建、查询、更新和管理数据库。

- 数据库的分类：
	- **关系型数据库**：以关系模型组织数据，以表的形式存储数据并使用表之间的关系来维护数据的完整性。可以使用 SQL 语言查询数据
	- **NoSQL 数据库**：又称非关系型数据库，是一种新型的数据库，它可以处理海量、多模式的数据，可以快速访问大量的数据，是面向新一代 web 应用的解决方案。
	- **NewSQL 数据库**：是一种新型的 SQL 数据库，它融合了关系型数据库和 NoSQL 数据库的优点，既具有关系型数据库的可靠性和安全性，同时也具有 NoSQL 数据库的高性能和可扩展性。
## MySQL
### 基础使用
#### 数据库规范化（范式）
- 数据库设计目标：消除数据冗余、确保数据完整、易于修改维护
- 第一范式：标的**列具有原子性**不可再分解，也就是说一个列不应该有多个值（如联系方式就不应该在同一列存储电话和邮件）
	- 解决了重复列的问题：查询单个值、更新、插入数据都会比较麻烦
- 第二范式：每个表必须有一个主键并且非主键必须完全依赖与**整个**主键
	- 解决了非主键列对主键的**部分函数依赖**问题。减少了数据冗余，并避免了各种数据维护异常
	- 一个表中包含字段：学生 ID、课程 ID、学生姓名、课程名称、课程成绩。（学生 ID, 课程 ID）构成复合主键。学生姓名仅依赖于学生 ID，课程名称仅依赖于课程 ID，这两个依赖都是部分函数依赖。
	- 拆分为：学生表（学生 ID，学生姓名）；课程表（课程 ID，课程名称）；成绩表（学生 ID，课程 ID，课程成绩）
- 第三范式：一个数据库表中**不包含**已在其它表中已包含的**非主键字段**（表的信息如果能够被推导出来，就不应该单独的设计一个字段来存放）
	- 减少重复存储
	- 表：教师 ID（主键）；教师姓名；所教科目 ID；科目名称；科目所在部门
	- 拆分：**教师表**：包含教师 ID、教师姓名、所教科目 ID；**科目表**：包含科目 ID、科目名称、科目所在部门。

- **范式**：通过一系列规范化步骤将一个关系数据库表设计成**更加符合规范的形式**。
	- 优点：减少数据冗余；数据查询优化；提高数据完整性、一致性、可靠性
	- 缺点：数据表过多（拆分细）需要进行大量关联查询
- **反范式**：将一个关系数据库表设计成非范式化的形式
	- 优点：查询效率高，减少关联查询
	- 缺点：数据冗余、一致性问题等
#### 连接
- 优点
	- 可以让我们轻松地从多个表中获取数据，并且通过连接操作将数据整合到一个查询结果中，提高查询效率和数据处理效率。
	- 可以在数据之间建立关联关系，实现数据的逻辑和物理关联。这对于复杂的数据分析和查询操作非常有用，可以让我们更加灵活地进行数据分析和挖掘。
- 缺点
	- 在连接多个表时，会涉及到大量的数据传输和处理操作，可能会导致性能问题。因此，在使用连接操作时，需要仔细考虑表的大小、关联关系等因素，避免出现**性能瓶颈**。
	- 在使用外连接操作时，需要注意未匹配数据的处理，避免产生空值或者重复数据等。
	- 联接查询，跨业务，两个不相关的表，因为业务放在一起。对后续的拆表、拆库、拆服务，会造成很大的麻烦。
- 替代方法：
	- 先查出一个表的数据，然后通过在另一个表中的条件限制的方式进行查询
	- 减少数据冗余
	- 利用 ES 建立一个宽表
	- 通过内存缝合装配
#### 查询优化
- 性能开销较大的部分：
	- 较大的表
	- 连接操作
	- 聚合操作
- 性能分析：
	- MySQL 提供了 EXPLAIN 语句来分析查询语句
	- `EXPLAIN SELECT * FROM table_name WHERE conditions;`
- 慢查询优化的基本步骤：
	- 定位问题
	- 针对优化
	- 结果检验
- 优化的方式
	- 语句优化：避免过多的 JOIN、DISTINCT、\*、减少子查询
	- 缓存优化
	- 索引优化：在 MySQL 建立联合索引时会遵循最**左前缀匹配**的原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。尽量选择**区分度高**的列作为索引，区分度越高比例越大我们扫描的记录数越少，扫描越少，就越快。
#### 分库分表
- 随着数据量和访问量的不断增长，大表和单一数据库往往成为性能瓶颈。这时我们经常通过分库分表来优化数据库结构，提高系统的性能、增加可用性、减少数据库管理的复杂性。
- **垂直分表**
	- 将一个大数据表按数据**列（字段）的维度进行拆分**。垂直分表适用于数据表列数过多、列之间关联较小的场景。
	- 减少了 IO 冲突和锁表的几率（对不同表查询互不干扰）
- **垂直分库**
	- 将一个大型数据库中的数据**按照业务模块进行拆分**，将不同的业务模块分配到不同的数据库上。垂直分库适用于业务模块复杂、数据表之间关联较小的场景，每个库可以部署在不同的服务器上，从而达到多个服务器共同分摊压力的效果
	- 解决业务层面的耦合，业务清晰。
	- 能对不同业务的数据进行分级管理、维护、监控、扩展等。
	- 高并发场景下，垂直分库一定程度的提升 IO、减少数据库连接数、降低单机硬件资源的瓶颈。
- **水平分表**
	- 是将一个大表按照数据行的维度进行拆分，将数据行分配到不同的数据表中。水平分表适用于数据表行数过多、数据访问量分散的场景。
	- 优化单一表数据量过大而产生的性能问题
	- 避免 IO 争抢并减少锁表的几率
- **水平分库**
	- 将一个大型数据库依据一定规则，按数据行的维度进行切分，将数据行分配到不同的数据库上，每个库可以部署在不同的服务器上。水平分库是对数据行的拆分，不影响表结构。
	- 解决了单库数据量大和高并发的性能瓶颈。
	- 提高了系统的稳定性及可用性。稳定性提升体现在 IO 冲突减少，锁定减少，可用性指如果某个库出问题，数据库仍部分可用。
	- 但由于同一个表被分配在不同的数据库，需要额外进行数据操作的路由工作，因此大大提升了系统复杂度。
#### 数据库的设计
##### 设计主键
- 业务主键（自然主键）：在数据库表中把具有业务逻辑含义的字段作为主键
- 逻辑主键（代理主键）：在数据库表中采用一个与当前表中逻辑信息无关的字段作为其主键
	- 通常使用：避免由于业务信息变动造成的主键变动
- 复合主键（联合主键）：通过两个或者多个字段的组合作为主键。

- 通常使用 ID 或 UUID 作为主键
- 自增 ID
	- 数据库自动编号，速度快，而且是递增式增长，汇总的主键按顺序存储，对检索非常有利。
	- 当系统与其他系统集成，需要导入数据时，很难保证原系统的 ID 没有主键冲突。（容易重复发生冲突）当在一个产生唯一标识符的并发环境中，每个增量值都必须对这个全局值**进行锁定和解锁**，以确保增量值的唯一性。这就产生了一个并发瓶颈，降低了查询性能。
- UUID：是一个在机器上生成的字符串，保证对同一时空的所有机器都是唯一的。在 UUID 算法中，可以使用诸如网卡 MAC 地址、IP、主机名、进程 ID 等信息来保证其独立性。
	- 全局唯一性，安全性，可移植性。
	- UUID 的无序性带来性能下降，并且 UUID 较长，占用内存（一次可以加载到内存的数目下降）
#### 事务
- 数据库事务是由**有限的数据库操作序列构成**，要么都完成要么就都取消（如果事务中有的操作没有成功完成，则事务中的所有操作都需要**回滚**）
##### MVVC 多版本控制机制
- 事务开启时，会先申请一个事务 id 当一个事务修改一行数据时，MySQL 会保留修改前数据的 undo 回滚日志，并将事务 id：transaction_id 赋给 trx_id 版本记录中的字段。将这些 undo log 日志串联起来，形成一条**历史版本链**
	- ![image.png|425](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240309190837.png)
- 一致性视图：实现可重复读、读已提交
	- 对事务按照时间轴划分 ：已提交、未提交、未开始 ![image.png|475](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240309191307.png)
	- 如果当前事务 id 落在**紫色部分**，说明这个版本是一个 committed 事务或者是当前事务自己生成的，这个数据是**可见**的。
	- 如果当前事务 id 落在**蓝色部分**，说明这个版本是以后开始的事务产生的，肯定是**看不见的。**
	- 如果当前事务 id 落在**橙色部分**，则包括两种情况：
		- A、如果该行在 trx_id 数组中，说明这个版本是由一个尚未提交的事务生成的，不可见。
		- B、如果该行 trx_id 不在数组中，说明这个版本是由一个已提交的事务生成的，可见。
	- 每个事务都会获得一个唯一的**时间戳**（或版本号）。这个时间戳用来标记事务修改或查询数据的版本。事务在访问数据时，系统会根据事务的时间戳和数据版本的时间戳**决定哪个版本的数据对该事务可见。**

#### 索引
- 索引是一种特殊的数据结构，它可以帮助数据库**快速地定位**要查询的数据，从而提高查询性能和效率
- 键和索引的区别：
	- 键是用于标识表中唯一行的列或列组合
	- 索引是一种特殊的数据结构, 用于**快速查找**数据库表中的的数据
- 分类
	- 按数据结构分类可分为：B+tree 索引、Hash 索引、Full-text 索引。
	- 按物理存储分类可分为：聚簇索引、二级索引（辅助索引）。
	- 按字段特性分类可分为：主键索引、普通索引、前缀索引。
	- 按字段个数分类可分为：单列索引、联合索引（复合索引、组合索引）。
- 优点：
	- 
- 缺点：
	- 
##### [[docs/归档课程/数据结构/笔记/文件系统#B 树 难点|B树]]
#### 锁
- 
### 原理
#### SQL 语句的执行
- ![image.png|275](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240309181317.png)
- **解析**请求：进行语法分析和语义分析，转化为抽象语法树
- 查询**优化**：对语法树进行优化，生成最优执行计划，提高查询性能
- **执行**计划：执行引擎分局执行计划进行查询
- **结果**：引擎完成查询，将查询结果发送给客户端
#### MySQL 体系结构
- ![image.png|400](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240309181924.png)
- Client-Sever 结构：Sever 包含：服务处理层，存储引擎、文件系统
- **服务器层**
	- 负责 MySQL 关系数据库管理系统的所有逻辑功能
	- **MySQL 服务和实用程序**：包括备份和恢复，安全，分区等。
	- SQL: 用于查询 MySQL 服务器。
	- SQL 解析器
	- 优化器
	- 缓存：如果任何客户端发出的查询与缓存中已有的查询相同，服务器将**跳过**解析、优化甚至执行，它只是简单地显示缓存中的输出。（这也是为什么二次查询会很快）
	- ![image.png|475](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240309182950.png)
- **存储引擎层**
	- 负责为数据库执行**实际的数据 I/O 操作**，并启用和实施针对特定应用程序需求的某些功能集。
	- 用 MyISAM，InnoDB 还有一群其他的 Federated，Mrg_MyISAM，Memory
- **数据存储层**
![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240309183205.png)

#### 存储引擎
- MySQL **可插拔存储引擎架构**使数据库专业人员能够为特定应用程序需求选择专门的存储引擎，同时完全无需管理任何特定应用程序编码要求。
- 常用的引擎：InnoDB 和 MyISAM
- InnoDB
	- **事务支持**：InnoDB 提供了对事务的支持，允许行级锁定，这对于需要处理大量并发写入操作的应用来说非常重要。
	- **数据完整性**：通过外键约束支持，InnoDB 有助于维护数据库的数据完整性。
	- **恢复能力**：支持崩溃后的恢复机制。
	- **行级锁定**：InnoDB 支持行级锁定，减少了数据库操作时的锁争用，提高了并发处理能力。
	- **支持 MVCC**：支持多版本并发控制（MVCC），提高读取效率，特别是在高并发场景下。
	- **默认引擎**：从MySQL 5.5开始，InnoDB是MySQL的默认存储引擎。
- MyISAM
	- **速度快**：在不需要事务处理和外键约束的场景下，MyISAM 的简单设计使其读取速度非常快。
	- **表级锁定**：MyISAM 在操作表时使用表级锁定，这意味着当执行写入（INSERT、UPDATE、DELETE）操作时，会锁定整个表。
	- **全文索引**：直到 MySQL 5.6引入 InnoDB 全文索引之前，MyISAM 支持全文索引是其一个主要优势。
	- **不支持事务**：MyISAM 不支持事务处理，也不支持外键。
	- **压缩表**：MyISAM支持表数据的压缩，以减少磁盘空间的使用。
- 对比
	- **事务支持**：InnoDB 支持事务处理，而 MyISAM 不支持。这是两者之间最重要的区别之一。
	- **并发**：InnoDB 通过行级锁定和 MVCC 提供了更好的并发处理能力，而 MyISAM 的表级锁定可能会成为性能瓶颈。
	- **数据完整性**：InnoDB 支持外键约束，有助于保持数据的完整性，而 MyISAM 则不支持。
	- **恢复能力**：InnoDB 提供了更强的恢复能力，可以处理系统崩溃后的数据恢复，MyISAM 在这方面较为脆弱。
	- **存储要求**：MyISAM 通常需要更少的磁盘空间和内存，这是因为它的结构相对简单。
## Redis（NoSQL）
