> 由于本人对算法编写比较熟悉，略过了许多算法的具体过程（比如快速排序、归并等）侧重于在 OI 中不常见的理论部分知识点。
> 内容包含：数据结构，算法设计与分析
### 概述
- 数据结构三要素：逻辑结构、存储（物理）结构、数据的运算
	- 逻辑结构：线性、非线性（树、图）
	- 存储结构：顺序存储、链式存储、索引存储（<关键字，地址>）、散列存储

#### 渐进复杂度分析
- $O$ 的定义 $\lim_{ n \to \infty }\frac{f(n)}{g(n)}=c<\infty\to f\in O(g)$ 
	- 若 $c=0$ 则为 $o$，$c=w$ 则为 $\infty$
	- 等于为 $\Theta$（$0<c<\infty$），大于等于为 $\Omega$ ($c>0$)
- 常见复杂度的比较
	-  $lglgn<lnn,lgn<lgn^2<\sqrt{ n }<n<nlgn<n^{1.1}<$
	- $n^2,n^2+lgn<n^3<2^{n-1},2^{n}<e^n<n!$
	- Tip $n! = \sqrt{ 2\pi n }{\left( \frac{n}{e} \right)^n}$

- smooth 定理：
	- 对于⼀个非负 ,最终单增的函数若满⾜ $f(2n)\in \Theta(f(n))$ 则称为 smooth 函数
	- 可以用部分特殊位置的渐进复杂度作为算法的复杂度 (如 $2^k$)

递归问题的时间复杂度求解
- 对分治递归式的理解 $T(n)=aT\left( \frac{n}{b} \right)+f(n)$
	-  划分为 a 个问题规模为 1/b 的子问题
	- f (n) 表示子问题划分与合并的代价
- 猜测-证明法：
	- 先根据递归树推导猜测，再用变量替换进行证明
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240418213844.png)
- 递归树
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240418214613.png)
- **主定理法**：
	- 如果公比大于 1，最后一行代价作为总代价；如果小于 1，根节点代价作为总代价；如果公比等于 1，每一行代价和作为总代价
	- 取 $E=\log_{b}^a$
	- 若 $f(n)\in O(n^{E-\epsilon})$ 则 $T(n)\in\Theta(n^E)$
	- 若 $f(n)\in \Theta(n^E)$ 则 $T(n)\in \Theta(f(n)\lg n)$
	- 若 $f(n)\in \Omega(n^{E+\epsilon})$ 则 $T(n)\in\Theta(f(n))$
	- \*若 $f(n)\in \Theta(n^E\lg ^kn)$ 则 $T(n)\in \Theta (n^E\lg ^{k+1}n)$
#### 算法分析的数学基础
- 级数求和
	- $\sum^n_{i=1}i=\frac{n(n+1)}{2}$
	- $\sum^n_{i=1}i^2=\frac{1}{3}n\left( n+\frac{1}{2} \right)(n+1)$
	- 即求和 $\sum^n_{i=1}i^k\in \Theta\left( \frac{1}{k+1}n^{k+1} \right)$
	-  等比数列 $\sum ar^i=\Theta(r^k)$ 就等于最大那一项
	- $\\sum^k_{i=1}\frac{1}i=\ln k$

- 算法问题规约：
	- 输入规约：明确规定算法接受的所有合法输入
	- 输出规约：规定对于每一组合法的输入，相应的输出是什么
- 弱数学归纳法
	- P (1) 为 TRUE
	- p (k) -> p (k+1)
- 强数学归纳法
	- P (1) 为 TRUE
	- p (1)&&... p (k)->p (k+1)
> 比如 gcd 算法就可以由强数学归纳法证明
## 顺序结构
### 排序
- 内排序与[[数据结构与算法#外排序|外排序]]:   内排序是指在排序期间数据元素**全部存放在内存**的排序；外排序是指在排序期间全部元素个数太多，**不能同时存放在内存**，必须根据排序过程的要求，不断在内、外存之间移动的排序。
- **常见的不稳定排序：希尔排序，快速排序，直接选择排序，堆排序**
- ![image-20231216130305703|575](https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231216130305703.png)
- 需要**随机访问**的排序**只能使用顺序存储**：如折半插入排序，希尔排序，快速排序，堆排序
- n 较小：选择直接插入排序、简单选择排序
- n 较大：使用 nlogn 算法
- 基本有序：直接插入，冒泡
- 如果 n 很大，但是关键位较少可以考虑基数排序
#### 常见的排序算法
- 插入排序
	- 直接插入排序：每次选一个还没有排序的元素向已经排好序的数组中插入元素（从后向前），不能放久交换位置
	- 折半插入排序：在查找插入位置时折半查找而不是逐一比较（不过由于要逐一交换，还是很慢，只是比较次数减少了）
- 希尔排序
	- 取一个整数 gap 作为间隔，将距离为 gap 的元素放在同一个子序列（即得到 gap 个序列），对每一个子序列进行直接插入排序，然后减小 gap 重新进行插入排序，直至 gap=1
	- 复杂度约为 $n^{1.25}$
- 选择排序
	- 直接选择排序：每一趟选出待排序元素中的最小元素，放在已排序区间的末尾（与第一个元素对调）
	- 锦标赛排序：将两两比较中较小者作为优胜者上升到双亲节点（胜者树）
	- ![image.png|400](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240418235442.png)
	- 建树 $O (n)$
	- 之后对树进行维护，将获胜者修改为 $-\infty$ 之后对整个路径进行更新，耗时 $O(\log n)$

- 快速排序
	- $A(n)=(n-1)+A(i)+A(n-1-i)$
	- partition 的两种方式：左右交替移动（partition 作为中介）交换；ij 双指针，从左到右移动，维护两个区间
	- 注意由于递归的原因，快速排序并不是 O (1) 的，平均为 O (nlogn)最差 O (n^2)
- 归并排序
	- $A(n)=2A\left( \frac{n}{2} \right)+O(n)$
- 堆排序
	- 建堆 $W(n)=2W\left( \frac{n}{2} \right)+2\log n=O(n)$
	- 维护堆 $O(\log n)$
	- 两种维护操作：从上向下（如删除根节点），从下向上（如插入新元素）
- 基数排序
	- 以 LSD 为例，先从左到右遍历元素，将第 i 为 k 的 push 到第 k 组（一共 0-9 即 10 组），之后从左到右取出元素得到新排列；再根据第二位（十位）重做，直至所有位完成
- 复习到这看到了这个图片~![|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/YNIN9~K%7DU%7D$NU0ETKZE8%5DDS.jpg)
#### 基于比较的排序的下界
- 引入决策树，每个节点表示两个元素之间的比较，其左右节点分别表示比较不同结果，最终叶节点表示根据前面的比较信息得到的排序
- 由于排序结果有 n! 种，因此决策树的叶节点至少有 n! 个，那么 $h\geq\log (n!)=\Omega(n\log n)$ 即为基于比较的排序的**最坏情况的下界**

- 平均情况的时间复杂度对应于根节点到所有叶节点的**路径长度的加权值**
	- 为了计算决策树根节点到所有叶节点路径长度的加权和，引入**外部路径长度 EPL**
	- $ELP(T)=ELP(T_{L})+N_{L}+ELP(T_{R})+N_{R}$
	- 平均复杂度就是 $\frac{ELP}{L}$，L 为叶节点数目，即可能得排序结果数目
	- 对于尽可能平衡的树 $ELP=L\log L$ 得到最终的复杂度同为 nlogn
### 查找&选择

## 树与搜索
## 图论
## NP-C 问题
## 其他数据结构
### 平衡搜索树
#### 红黑树
- 
#### AVL 树
- 
#### 哈希表
- 
#### 并查集
- 
## 文件系统
- 能够**唯一标识**一个记录的数据项或数据项集称为**主关键码项**，其值称为主关键码；
- **不唯一标识**一个记录的数据项或数据项集称为**次关键码项**，其值称为次关键码。
- 文件记录分为逻辑记录和物理记录。前者是**面向用户**的基本存取单位，后者是**面向外设**的基本存取单位。
### 文件的存储结构
- 文件的存储结构：顺序存储、直接存取组织（散列函数）、索引组织
#### 顺序存储
- 顺序文件中的记录按它们**进入文件的先后顺序存放**，其逻辑顺序与物理顺序**一致**
- 如果按**主关键码有序**，则称为**顺序有序**文件，否则为顺序无序文件
- **只能顺序搜索存取**
- 连续文件：存放在外存的连续区域
- 串联文件，成块存放，但是块与块之间可以不连续，通过块状指针顺序链接
#### 直接存取
- 利用散列进行组织，可以**通过**记录的**关键码**直接**确定记录的地址**
- 优点：随机存放，记录不需要进行排序，插入删除方便，不需要存储索引
- 缺点：不能顺序存取，多次插入删除后需要重新组织文件

- 按桶散列：若一个组能存储 m 个记录，那么第 m+1 个同义词出现时，发生溢出
- 溢出链
	- 将第 m+1 个同义词存放到溢出桶（前 m 个所在的为基桶），当基桶中检索不成功时，到溢出桶中进行检索
	- 删除时只做逻辑删除标记，系统周期性重构时再做物理删除
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231228005110.png)
- 分布式溢出空间
	- 溢出桶按照一定间隔分布在基桶之间，如果有一个基桶溢出了，系统就将记录存放在下一个溢出桶，溢出桶溢出了再溢出到下一个溢出桶
	- ![image.png|150](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231228005639.png)
- 相继溢出法
	- 当发生溢出时，溢出记录直接存放到下一个相继的桶中
	- 优点是对溢出不需要漫长的寻找，但是如果临近多个桶存满会导致要检查多个桶
	- ![image.png|175](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231228005846.png)
- 可扩充散列：根据桶的大小进行合并分裂等操作
#### 索引文件
- 由索引表和数据表组成，索引表表示**逻辑记录与物理记录的对应关系**
- 索引顺序文件：数据顺序分组，**一组记录**对应一个索引项（稀疏索引）
	- ![image.png|475](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231228125653.png)
- 索引非顺序文件，每一个记录分别对应一个索引项，稠密索引
	- ![image.png|450](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231228125641.png)
- 静态索引
- 
##### 倒排表
- 
##### 多级索引结构
- 
### B 树

### 外排序
