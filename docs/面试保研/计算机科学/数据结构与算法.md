> 由于本人对算法编写比较熟悉，略过了许多算法的具体过程（比如快速排序、归并等）侧重于在 OI 中不常见的理论部分知识点。
> 内容包含：数据结构，算法设计与分析
### 概述
- 数据结构三要素：逻辑结构、存储（物理）结构、数据的运算
	- 逻辑结构：线性、非线性（树、图）
	- 存储结构：顺序存储、链式存储、索引存储（<关键字，地址>）、散列存储

#### 渐进复杂度分析
- $O$ 的定义 $\lim_{ n \to \infty }\frac{f(n)}{g(n)}=c<\infty\to f\in O(g)$ 
	- 若 $c=0$ 则为 $o$，$c=w$ 则为 $\infty$
	- 等于为 $\Theta$（$0<c<\infty$），大于等于为 $\Omega$ ($c>0$)
- 常见复杂度的比较
	-  $lglgn<lnn,lgn<lgn^2<\sqrt{ n }<n<nlgn<n^{1.1}<$
	- $n^2,n^2+lgn<n^3<2^{n-1},2^{n}<e^n<n!$
	- Tip $n! = \sqrt{ 2\pi n }{\left( \frac{n}{e} \right)^n}$

- smooth 定理：
	- 对于⼀个非负 ,最终单增的函数若满⾜ $f(2n)\in \Theta(f(n))$ 则称为 smooth 函数
	- 可以用部分特殊位置的渐进复杂度作为算法的复杂度 (如 $2^k$)

递归问题的时间复杂度求解
- 对分治递归式的理解 $T(n)=aT\left( \frac{n}{b} \right)+f(n)$
	-  划分为 a 个问题规模为 1/b 的子问题
	- f (n) 表示子问题划分与合并的代价
- 猜测-证明法：
	- 先根据递归树推导猜测，再用变量替换进行证明
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240418213844.png)
- 递归树
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240418214613.png)
- **主定理法**：
	- 如果公比大于 1，最后一行代价作为总代价；如果小于 1，根节点代价作为总代价；如果公比等于 1，每一行代价和作为总代价
	- 取 $E=\log_{b}^a$
	- 若 $f(n)\in O(n^{E-\epsilon})$ 则 $T(n)\in\Theta(n^E)$
	- 若 $f(n)\in \Theta(n^E)$ 则 $T(n)\in \Theta(f(n)\lg n)$
	- 若 $f(n)\in \Omega(n^{E+\epsilon})$ 则 $T(n)\in\Theta(f(n))$
	- \*若 $f(n)\in \Theta(n^E\lg ^kn)$ 则 $T(n)\in \Theta (n^E\lg ^{k+1}n)$
#### 算法分析的数学基础
- 级数求和
	- $\sum^n_{i=1}i=\frac{n(n+1)}{2}$
	- $\sum^n_{i=1}i^2=\frac{1}{3}n\left( n+\frac{1}{2} \right)(n+1)$
	- 即求和 $\sum^n_{i=1}i^k\in \Theta\left( \frac{1}{k+1}n^{k+1} \right)$
	-  等比数列 $\sum ar^i=\Theta(r^k)$ 就等于最大那一项
	- $\\sum^k_{i=1}\frac{1}i=\ln k$

- 算法问题规约：
	- 输入规约：明确规定算法接受的所有合法输入
	- 输出规约：规定对于每一组合法的输入，相应的输出是什么
- 弱数学归纳法
	- P (1) 为 TRUE
	- p (k) -> p (k+1)
- 强数学归纳法
	- P (1) 为 TRUE
	- p (1)&&... p (k)->p (k+1)
> 比如 gcd 算法就可以由强数学归纳法证明
## 顺序结构
### 线性表
#### 顺序表
- 用地址连续的存储单元一次存储线性表中的数据元素，逻辑上相邻的元素在物理位置上也相邻
- **顺序表与数组的区别**
	- 数组是一种**存储方式**（顺序存储），数组并不一定是顺序表（比如数组形式存储的堆）
	- 顺序表（线性表）强调的是一对一的前后继关系
#### 链表
- 逻辑上相邻的元素，物理上不再相邻
- 头插法得到反序链表，尾插法得到正序
### 栈与队列
- 栈和队列都是**限制存取位置的线性结构**，即具有相同的逻辑结构（线性结构）
#### 栈
-  n 个元素入栈，**可能的出栈顺序数目**：
  - 枚举第一个元素的出栈时间，分治 $f(n) = \sum_{i=1}^{i=n}{f(i-1)*f(n-i)}$（**卡特兰数**），通项为 $f(n) = \frac{C_{2n}^{n}}{n+1}$ 
  - 在**第一个元素**入栈之后出栈**之前**有 i-1 个元素**入栈又出栈**，这可以作为一个类似的子问题
- 双栈共享空间
	- ![image-20230929192722735|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20230929192722735.png)
- 链式栈
	- **栈顶在链头**，插入与删除仅在栈顶处执行
	-  ![image-20230929193637012|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20230929193637012.png)

表达式求值
- 转化为后缀表达式
	- 手动转化方式：先对中缀表达式按运算优**先次序加上括号**，再**把操作符后移到右括号的后面**并以就近移动为原则，最后将所有括号消去。![image-20231108151451666|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231108151451666.png)
	- ![image-20230929194833254|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20230929194833254.png)
	- ![image-20230929194856002|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20230929194856002.png)
	- 数字直接输出
- `;` 用作标识，开始之前先将 `;` **入栈**，并且中缀表达式**末尾**也有一个 `;`（用作结束时**清空栈**）
	- ![image-20231107212727767|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231107212727767.png)
	- ![image-20231107212737135|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231107212737135.png)
- 后缀表达式求值
	- 遍历后缀表达式，遇到数就压栈，遇到操作复就从栈中取数进行计算，再放回栈中
	- 栈中剩下的最后一个元素就是计算结果
- 对于尾递归和前向递归可以不使用栈修改为迭代
#### 队列
- 顺序队列
	- ![image-20230929202943266|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20230929202943266.png)
	- 进队：rear++；出队：front++
	- 队空时：rear=front；队满时：rear=maxSize
	- 随着元素进入与弹出，逐渐无法使用，出现**假溢出**
- 循环队列
	- ![image-20231107220444662|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231107220444662.png)
	- 队头指针进 1: front = (front+1) % maxSize; 
	- 队尾指针进 1: rear = (rear+1) % maxSize; 
	- 队列初始化：front = rear = 0; 
	- 队空条件：front == rear; 
	- **队满条件**：(rear+1) % maxSize == front
- 链式队列
	- ![image.png|350](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240104184824.png)
	- 队头在链头，队尾在链尾。
### 数组与矩阵
- 对称矩阵（方阵）
	- 可以只存储为上三角矩阵或下三角矩阵
	- 下三角矩阵：只存储 $i\geq j$ 的数组元素，数组元素 $A[i][j]$ 在数组中存放位置为 $1+2+\cdots+i+j=(i+1)*i/2+j$
	- 上三角矩阵：只存储 $i\leq j$ $A[i][j]$ (i<=j)位于 $n+(n-1)+\dots+(n-i+1)+j-i=(2*n-i-1)*i/2+j$
- 三对角矩阵
	- 有 $3n-2$ 个非 0 元素, $0<=i<=n-1 \ i-1<=j<=i+1$
	- $A[i][j]$ 位于 $k=2*i+j$
- 计算时**一定要小心下标是否从 0 开始**

- 稀疏矩阵
	- 稀疏因子 $e=s/(m*n)$ 通常认为 $e<=0.05$ 为稀疏矩阵
	- 存储稀疏矩阵时一般**只存储非零元素**，使用三元组 $(i,j,a_{ij})$ 表示矩阵的元素在稀疏矩阵的三元组表中 (按照字典序进行存储)
	- 非空元素**三元组加上矩阵的长宽**就可以确定唯一的稀疏矩阵
- 稀疏矩阵转置
	- 设矩阵列数为 Cols，对矩阵三元组表扫描 Cols 次。第 k 次扫描找寻所有**列**号为 k 的项，将其行号变列号、列号变行号，**顺次存于转置矩阵三元组表。**
	- （因为要维护字典序所以这么麻烦）
- 快速转置算法
	-  ![image-20231024005924543|525](https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231024005924543.png)
### 字符串
#### KMP 算法
- 朴素的模式匹配 $O(n\cdot m)$，kmp 的复杂度 $O(m+n)$
- $next[i]$ 表示 $pat[0,i-1]$ 的最长共同前后缀的长度
-  ![image-20231024083510277|475](https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231024083510277.png)
```cpp
vector<int> build_next(string s)//构建next数组
{
    vector<int>next{-1};//第一位一定为零（因为规定前后缀不能为自身）
    int i=1,len=0;//len记录当前位置最大重合长度
    while(i<s.size())
    {
        if(s[len]==s[i-1]&&len!=i-1)
        {
            len++;
            next.push_back(len);
            i++;
        }
        else
        {
            if(len==0)
            {
                next.push_back(0);
                i++;
            }
            else
                len=next[len];//找到对应的前缀的末尾位置（一种递归思想，长的匹配不上则逐渐缩短去找）
        }
    }
    return next;
}
    int kmp(string fs,string ss)//ss为待匹配的子串
    {
        vector<int>next=build_next(ss);
        int i=0,j=0;
        while(i<fs.size())
        {
            if(fs[i]==ss[j])
            {
                i++;
                j++;
            }
            else if(j>0)
                j=next[j];//前next[j-1]位仍相同，在这之后继续匹配
            else
                i++;
            if(j==ss.size())
                return i-j;
        }
        return -1;
    }
```
### 广义表
- 广义表中的元素可以为数据元素或子表
- n > 0 时表的**第一个元素**为广义表的**表头**，其他元素为表尾 $G=('a',(5,3,'x'),\dots)$ 其中表头为 $'a'$，表尾为 $((5,3,'x'),\dots)$
- 通过 head、tail 操作获得表头和表尾，进而得到任何一个元素（要走注意的是返回表尾时会在外面额外加上一组括号）
	- ![image-20231024085833176|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231024085833176.png)
	- ![image-20231108103418890|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231108103418890.png)
- 长度为元素数目，深度为括号嵌套的层级
	- ![image.png|450](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240104231357.png)

- 广义表节点的定义：`utype|info|tlink`
	- utype 节点类型：0 表示广义表附加头结点（表标识符 ABCD）；1 表示元素数据项；2 表示子表
	- info 存储信息：0 时存储引用计数；1 时存储具体数据值；2 时存储子表表头指针
	- tlink 尾指针：0 时指向第一个节点；否则指向同层下一个节点
	- ![]( https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231108171439237.png )
### 排序
- 内排序与[[数据结构与算法#外排序|外排序]]:   内排序是指在排序期间数据元素**全部存放在内存**的排序；外排序是指在排序期间全部元素个数太多，**不能同时存放在内存**，必须根据排序过程的要求，不断在内、外存之间移动的排序。
- **常见的不稳定排序：希尔排序，快速排序，直接选择排序，堆排序**
- ![image-20231216130305703|575](https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231216130305703.png)
- 需要**随机访问**的排序**只能使用顺序存储**：如折半插入排序，希尔排序，快速排序，堆排序
- n 较小：选择直接插入排序、简单选择排序
- n 较大：使用 nlogn 算法
- 基本有序：直接插入，冒泡
- 如果 n 很大，但是关键位较少可以考虑基数排序
#### 常见的排序算法
- 插入排序
	- 直接插入排序：每次选一个还没有排序的元素向已经排好序的数组中插入元素（从后向前），不能放久交换位置
	- 折半插入排序：在查找插入位置时折半查找而不是逐一比较（不过由于要逐一交换，还是很慢，只是比较次数减少了）
- 希尔排序
	- 取一个整数 gap 作为间隔，将距离为 gap 的元素放在同一个子序列（即得到 gap 个序列），对每一个子序列进行直接插入排序，然后减小 gap 重新进行插入排序，直至 gap=1
	- 复杂度约为 $n^{1.25}$
- 选择排序
	- 直接选择排序：每一趟选出待排序元素中的最小元素，放在已排序区间的末尾（与第一个元素对调）
	- 锦标赛排序：将两两比较中较小者作为优胜者上升到双亲节点（胜者树）
	- ![image.png|400](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240418235442.png)
	- 建树 $O (n)$
	- 之后对树进行维护，将获胜者修改为 $-\infty$ 之后对整个路径进行更新，耗时 $O(\log n)$

- 快速排序
	- $A(n)=(n-1)+A(i)+A(n-1-i)$
	- partition 的两种方式：左右交替移动（partition 作为中介）交换；ij 双指针，从左到右移动，维护两个区间
	- 注意由于递归的原因，快速排序并不是 O (1) 的，平均为 O (nlogn)最差 O (n^2)
- 归并排序
	- $A(n)=2A\left( \frac{n}{2} \right)+O(n)$
- 堆排序
	- 建堆 $W(n)=2W\left( \frac{n}{2} \right)+2\log n=O(n)$
	- 维护堆 $O(\log n)$
	- 两种维护操作：从上向下（如删除根节点），从下向上（如插入新元素）
- 基数排序
	- 以 LSD 为例，先从左到右遍历元素，将第 i 为 k 的 push 到第 k 组（一共 0-9 即 10 组），之后从左到右取出元素得到新排列；再根据第二位（十位）重做，直至所有位完成
- 复习到这看到了这个图片~![|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/YNIN9~K%7DU%7D$NU0ETKZE8%5DDS.jpg)
#### 基于比较的排序的下界
- 引入决策树，每个节点表示两个元素之间的比较，其左右节点分别表示比较不同结果，最终叶节点表示根据前面的比较信息得到的排序
- 由于排序结果有 n! 种，因此决策树的叶节点至少有 n! 个，那么 $h\geq\log (n!)=\Omega(n\log n)$ 即为基于比较的排序的**最坏情况的下界**

- 平均情况的时间复杂度对应于根节点到所有叶节点的**路径长度的加权值**
	- 为了计算决策树根节点到所有叶节点路径长度的加权和，引入**外部路径长度 EPL**
	- $ELP(T)=ELP(T_{L})+N_{L}+ELP(T_{R})+N_{R}$
	- 平均复杂度就是 $\frac{ELP}{L}$，L 为叶节点数目，即可能得排序结果数目
	- 对于尽可能平衡的树 $ELP=L\log L$ 得到最终的复杂度同为 nlogn
### 查找&选择
#### 线性时间选择
期望线性时间选择-partition
- 做一次 partition 之后，如果左边元素数等于 k-1，那么直接返回该元素
- 如果左边数目大于 k-1，那么在左边递归的找第 k 元素
- 如果左边数目小于 k-1，那么对右边递归选择（选 $k-n_{l}-1$）
- 平均复杂度 $O(n)$ 最坏时间复杂度 $O(n^2)$

最坏线性时间选择
- 核心思想：最坏情况下的划分也不能太不平衡
- 将所有元素 5 个一组进行划分（$\left\lceil  \frac{n}{5}  \right\rceil$ 组），并找到每一组中的中位数，并对数组进行划分
- 再对所有组，依据中位数的大小求中位数的中位数，并进行划分
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240420152144.png)
- 可以明确的是
	- A 区全部小于 $m^*$；B 区全部大于 $m^*$（这就保证了相对均衡的划分）
	- 对于 CD 区要进行比较判断
- 这就相当于进行了一次有划分均匀性保障的 partition，之后的过程一致
- 时间复杂度 $W(n)\leq W\left( \left\lceil  \frac{n}{5}  \right\rceil \right)+W\left( \frac{7}{10}n+6 \right)+O(n)=O(n)$
##### 为什么是 5 个一组
- 3 个一组
	- $W(n)\geq W\left( \left\lceil  \frac{n}{3}  \right\rceil \right)+W\left( \frac{2}{3}n+3 \right)+O(n)=O(n\log n)$
	- 渐进复杂度都不对了
- 7 个一组
	- $W (n)\leq W\left ( \left\lceil  \frac{n}{7}  \right\rceil \right)+W\left ( \frac{5}{7}n+8 \right)+O (n)$
	- 只是常数大一点（因为没必要分这么细，并没有比 5 使得划分更加均匀）
- 问题在这：对于 $W(n)=W(an)+W(bn)+O(n)$
	- 当 $a+b<1$ 时时间复杂度为 $O(n)$；每一层任务量递减，因此主要是由**顶层贡献**的
	- 当 $a+b=1$ 时时间复杂度为 $O(n\log n)$；每一层任务量不变，即每一层的贡献量一致，**都要纳入计算**
#### 二分查找
- 
## 树与搜索
- 树的深度：到根路径长（根的深度为 0）
- 数的高度：带叶节点最大路径长（叶节点的高度为 0）
### 森林
## 图论
## 查找数据结构
### 搜索树
#### 二叉搜索树
- 
#### 红黑树
- 
#### AVL 树
- 
### 哈希表
- 
### 并查集
- 
## 算法例题
### 分治算法
#### CDQ 分治
- 基本思想：分别计算左串和右串的共享，然后进行合并（计算跨越中介的贡献）

- 寻找常见项元素（找出出现次数大于 n/k）
	- 将原始数组分为左右两半，在数组中出现次数大于 n/k 的元素，一定会在其中一半出现次数大于 n/2k
	- 这样的元素就作为一半数组的候选元素，用于传递给下一层进行检查合并
	- 每次合并遍历整个数组（左右两半）检查候选元素是否还符合条件（每次要求数目\*2）
	- 最后可能还需要对结果去重

- 偏序问题，给定许多点，查找多少个点（x, y）满足不存在点使得 (x<x'&&y<y')
	- 首先对 x 排序，然后在左一半和右一半分别处理（标记不符合的点）
	- 然后对左边和右边分别对 y 进行排序，计算跨越贡献（当今当左边一个点的 y 大于右边 y 最大值时这个点才可能是候选）
	- 最后整理没有被标记的点并进行计数

- 平面内有多个点，求解最近距离
	- 分治（假设左右划分）：统计左边最近点对，右边最近点对，以及左边一点与右边一点的点对（这个是核心）
	- 设 $D=min(D_{l},D_{r})$ 即左右得到的距离最小值，
	- 对左边每一个点构建一个宽为 $D$，长度为 $2D$ 的矩形框（只需要判断这个氛围内对面点的距离）![image.png|400](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240420143359.png)
	- 这个框内不可能不会有太多点的，实际上最多只能 6 个（划分为 6 块，鸽笼原理证明）

### 其他
- 摩尔投票法：用于寻找数组中出现次数超过一半的元素（多数元素）
	- 初始选定第一个元素作为候选元素，并设置一个计数器 count（1）
	- 遍历数组，如果元素等于候选元素，那么 count+1；否则-1，如果变为 0 说明候选元素被抵消了，选择当前遍历到的元素作为新的候选元素，并将 count 设置为 1
	- 遍历结束后的候选元素还要进行检查，如果出现次数大于 n/2 那么就找到了多数元素

- 两个有序数组找中位数
	- 扩展为找第 $k$ 大的元素，那么比较 $arr_{1}\left[ \frac{k}{2} \right],arr_{2}\left[ \frac{k}{2} \right]$，小的那一半可以直接去掉（一定不包含第 k 大的元素），之后对 $k$ 进行更新（减去去掉的元素）
	- 即每次能去掉一半的元素，时间复杂度接近 $\log k$

- 权值中位数
	- 一个数组（无序），每个数有一个权值，求解权值中位数 ($\sum_{x_{i}\leq x_{k}}w_{i}\leq \frac{1}{2}$) 
	- $O(n)$ 时间求出中位数，之后进行 partition 并求出两边的权值和，较小的那一边应该舍去，并把其权值和加到中位数上

- 大数乘法
	- 

- 芯片检测
	- 
## 算法正确性与复杂度分析
### 决策树
- 决策树用于求解问题下限（但是并不紧）
### 对手论证
### 平摊分析
### NP-C 问题
## 文件系统
- 能够**唯一标识**一个记录的数据项或数据项集称为**主关键码项**，其值称为主关键码；
- **不唯一标识**一个记录的数据项或数据项集称为**次关键码项**，其值称为次关键码。
- 文件记录分为逻辑记录和物理记录。前者是**面向用户**的基本存取单位，后者是**面向外设**的基本存取单位。
### 文件的存储结构
- 文件的存储结构：顺序存储、直接存取组织（散列函数）、索引组织
#### 顺序存储
- 顺序文件中的记录按它们**进入文件的先后顺序存放**，其逻辑顺序与物理顺序**一致**
- 如果按**主关键码有序**，则称为**顺序有序**文件，否则为顺序无序文件
- **只能顺序搜索存取**
- 连续文件：存放在外存的连续区域
- 串联文件，成块存放，但是块与块之间可以不连续，通过块状指针顺序链接
#### 直接存取
- 利用散列进行组织，可以**通过**记录的**关键码**直接**确定记录的地址**
- 优点：随机存放，记录不需要进行排序，插入删除方便，不需要存储索引
- 缺点：不能顺序存取，多次插入删除后需要重新组织文件

- 按桶散列：若一个组能存储 m 个记录，那么第 m+1 个同义词出现时，发生溢出
- 溢出链
	- 将第 m+1 个同义词存放到溢出桶（前 m 个所在的为基桶），当基桶中检索不成功时，到溢出桶中进行检索
	- 删除时只做逻辑删除标记，系统周期性重构时再做物理删除
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231228005110.png)
- 分布式溢出空间
	- 溢出桶按照一定间隔分布在基桶之间，如果有一个基桶溢出了，系统就将记录存放在下一个溢出桶，溢出桶溢出了再溢出到下一个溢出桶
	- ![image.png|150](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231228005639.png)
- 相继溢出法
	- 当发生溢出时，溢出记录直接存放到下一个相继的桶中
	- 优点是对溢出不需要漫长的寻找，但是如果临近多个桶存满会导致要检查多个桶
	- ![image.png|175](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231228005846.png)
- 可扩充散列：根据桶的大小进行合并分裂等操作
#### 索引文件
- 由索引表和数据表组成，索引表表示**逻辑记录与物理记录的对应关系**
- 索引顺序文件：数据顺序分组，**一组记录**对应一个索引项（稀疏索引）
	- ![image.png|475](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231228125653.png)
- 索引非顺序文件，每一个记录分别对应一个索引项，稠密索引
	- ![image.png|450](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231228125641.png)
- 静态索引：多级索引结构，每一级索引都是一个有序表，在运行中结构不发生变化（可能导致不平衡，效率降低）
- 动态索引：动态调整的平衡搜索树结构，保持最佳的搜索效率

- 索引的时间效率：主要取决于**访问外存的次数**（索引树的高度）
##### 倒排表
- 只使用关键码无法**根据存储的内容进行查询**
- 可以把常用的搜索属性作为**次关键码**，建立次索引；次索引中**列出属性的取值**，对取值**建立有序链表**，把具有相同属性值得记录按存放地址/主关键码的顺序**连接**。由次**关键码、链表长度、链表本身**三部分组成。
- ![image.png|475](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231228134008.png)
	- 仅通过**搜索次索引**就能找到所有具有相同属性值的记录。
- 单元式倒排表：（解决倒排表中链表长度大小不一的问题）
	- 索引项不再储存具体地址，而是用 01 表示在哪些硬件（存储）区域中出现
	- ![image.png|450](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231228134645.png)
	- 对于希望的属性值的做 AND 就得到了目标硬件区域，到这些区域中去查找即可
##### 多级索引结构
- 数据记录比较大时索引表也会太大，可以**建立（常驻内存的）索引的索引**

- ISAM 索引：盘组、柱面、磁道三级地址索引

- m 路搜索树（B 树就是自平衡的 m 路搜索树）
	- ![image.png|400](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231228161444.png)
#### B 树
- B 树通过多叉树**降低深度**，可以减少磁盘 IO 读取次数，适用于**磁盘存储**
- 定义：
	- **根节点至少有两个子女**，其它所有节点至少有 $\left\lceil  \frac{m}{2}  \right\rceil$ 个子女
	- 所有**失败节点** （叶） **位于同一层**
	- 符合 m 路搜索树的所有定义 
	- 每个节点的关键码个数 $\left[ \left\lceil  \frac{m}{2}  \right\rceil -1,m-1\right]$，对应子节点 $\left[ \left\lceil  \frac{m}{2}  \right\rceil,m\right]$
	- 每一个关键码就对应一个搜索结果
- m 的选择：
	- B 树的搜索由两部分组成：在节点内的搜索和寻一条路径向下一层搜索交替进行的过程
	- 提高 m 可以减少 h 的高度，但是 m 过大会导致节点的大小超出内存，增加磁盘 io 降低效率
- 搜索
	- 继承了 m 路搜索树 Mtree 上的搜索算法
	- 搜索成功的时间取决于**关键码所在的层次**，不成功的时间取决于**树的高度**
- 插入
	- 插入总是在叶节点进行，之后可能进行自底向上的调整（关键码数目超过 m-1）
	- 如果插入后关键字数目大于 $m-1$ 则要对插入后的节点进行**分裂操**作：$\lceil m/2\rceil$ 关键字放入父节点中，其左侧节点留在原先的子树中，右侧节点放入**新节点**中。（即把中间节点提升到父节点）
	- ![image.png|400](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231228173317.png)
	- ![image.png|200](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231228173325.png)

- 删除
	- 首先先通过搜索找要删除的关键码的位置
- 删除终端节点：
	- 若删除后关键字数目过少，且兄**弟够借**（临近的兄弟节点的关键字个数 $>=\lceil m/2 \rceil$ 则从兄弟节点借一个关键字 ![image.png|425](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231228184201.png)
	- 兄弟**不够借**，则与一个不够借的兄弟节点**合并**，并把双亲中的一个节点下移 ![image.png|425](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240419141328.png)
- 删除非终端节点：
	- 使用右子树中最小关键码（被删除节点的**后继节点**）代替被删除的关键码，再从子树中**删除最小关键码**
	- 这就转化为删除终端节点的问题![image.png|475](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231228175418.png)
#### B+树
- 定义：
	- 每个节点最多 m 个子树
	- 根节点最少 1 棵，其它节点至少 $\left\lceil  \frac{m}{2}  \right\rceil$ 棵，一棵子树对应一个关键码
- 所有的数据都保存在叶子结点，关键字只用来索引；叶子节点被指针串联起来，支持顺序访问
- 所有的非终端结点可以看成是**索引部分**，结点中的**关键字**表示其**子树**（根结点）中的**最大（或最小）关键字**。
- 插入
	- 如果节点中**有多余的空间**放入元素，则直接插入即可。
	- 如果插入后叶节点关键码个数大于 m，则将其**分裂**为两个节点，并将其**中间元素的索引放入到父节点中** （叶节点拷贝，非叶结点直接上移）![image.png|525](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231228191826.png)
- 删除
  - 仅在**叶节点中删除元素**，如果节点还满足 B+树的要求，则直接删除。
  - 如果**元素个数过少**，并且其**邻近兄弟节点有多余的元素**，则从邻近兄弟节点中**借一个元素，并修改父节点中的索引**使其满足新的划分。![image.png|550](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231228192159.png)
  - 如果其邻近兄弟节点也**没有多余的元素**，则将其和邻近**兄弟节点合并**，并且我们需要**修改其父节点的索引**以满足新的划分。![image.png|550](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231228192232.png)
### 外排序
- 待排序的记录数目太多，无法在内存中一次处理，**必须以文件形式存放于外存**，排序过程中一部分一部分调入内存进行处理，这种基于外部存储设备的排序就是外排序。
- 外排序的基本过程
	- 首先建立内存缓冲区，并根据内存缓冲区的大小对文件进行**划分**，对每一段数据分别进行排序，得到**初始归并段**，写回到外存
	- 按照归并树的模式对初始归并段进行归并，不断扩大归并段，最终归并为一个大的归并段（如对于两路归并来说：将缓冲区划分为两个输入缓冲区一个输出缓冲区，一旦某个输入缓冲区中的数据被完全消耗，就从对应的归并段中**读取更多数据**填充这个缓冲区。同理，当输出缓冲区被填满时，其内容将被**写回外存**，并清空输出缓冲区以便再次使用）

- 外部排序的耗时 $t_{ES}=m^{*}t_{IS}+d^{*}t_{IO}+S^{*}n^{*}t_{mg}$
	- 分别为：每个初始段内排序时间；外存快访问次数；取得内存中记录时间
	- m 为归并路，S 为归并趟数
	- 时间瓶颈在于 io 磁盘读取时间，因此希望减少 io 的次数（使用多路归并）
#### k 路归并
- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231228211128.png)
- 假设每趟归并 n 个元素，则一次大致进行 $(n-1)*(k-1)$ 次比较
	- 即总共进行约 $(n-1)*(k-1)*\lceil \log_{k}m \rceil$
	- 也就是说 k 增大会使得**内部归并的时间增大**
	- 使用败者树优化（获取最大元素复杂度 $\log_{2}k$ ）复杂度变为 $\lceil \log_{2}m \rceil*(n-1)$ 与 k 无关
- 归并路数 k **不是越大越好**。归并路数 k 增大, 相应需增加输入缓冲区个数。如果可供使用的内存空间不变, 势必要减少每个输入缓冲区的容量, 使内外存交换数据的次数增大。
##### 败者树
- 在非叶结点中败者数存储败者（假设从小到大排序，那么就存储排序码较大的节点）
	- 败者树**记录败者**，但仍然**派胜者**继续向上
- 根结点的上一层另外**增加一个结点**，存放树中当前记录排序码**最小的结点** (最终胜者)。
- 在初始建立败者树时使用: 存放一个最小的在各归并段中不可能出现的排序码: -**MaxValue。**
- ![[多路合并.pdf]]
##### 败者树、胜者树与堆
- 这三者都可以用于实现优先队列，并且渐进时间复杂度相同，但是常数有所区别
- 堆
	- 堆取出最小值之后将新的值取出的值放到堆顶，之后对堆进行调整，每一层父节点都需要与两个子节点进行比较，即**比较两次**
- 胜者树
	- 胜者树更新叶子节点之后从下向上进行维护，每次需要与兄弟节点进行比较，即**比较一次**，但是每次都要**先获取父节点，再获取兄弟节点**，再进行比较
- 败者树
	- 败者树维护时**只需要与父节点进行一次比较**（更新的一定是有胜节点这一边，因此父节点上的败者就是兄弟节点）
- 由此，败者树的效率最高，因此使用败者树来实现多路归并
#### 置换选择算法
- 使用置换选择算法可以得到平均长度为 2n 的多个归并段（n 为缓冲区可以容纳的元素数目），由此实现减少层数，减少 io 提高效率
- ![image.png|450](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240419225346.png)
- 填入元素装满缓冲区，每次选择最小元素取出到 FO，并从 FI 装入一个元素
- 当最小元素小于当前 FO 的末尾时截断，创建新的 FO（这就得到了一个完成内排序的串）
#### 最佳归并树
- ![image.png|450](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240419225357.png)
- 使用霍夫曼树思想，每次选择最短的几个归并段进行归并
- 为了实现完美的多路归并，还需要添加几个零段（长度为 0 的归并段），使得每次合并都是 3 项合并
	- 即使得 $(n_{0}-1)\%(k-1)=0$，添加 $k-u-1$ 项