{"path":"pdf/课件/L9 - Hashing.pdf","text":"Introduction to Algorithm Design and Analysis [09] Hashing Jingwei Xu https://cs.nju.edu.cn/ics/people/jingweixu/ index.html Institute of Computer Software Nanjing University In the last class … • The searching problem • “Architecture” of data • logn search • Binary search • In a more general sense • Red-black tree: balanced BST • Deﬁnition • Black height constraint for balance • Color constraint for low maintenance cost • Operation • Insertion, deletion Hashing • The searching problem • The ambition of hashing • Hashing • Brute force table: direct addressing • Basic idea of hashing • Collision Handling for Hashing • Closed address hashing • Open address hashing • Amortized Analysis • Array doubling Cost for Searching • Brute force • O(n) • Balanced BST • O(logn) • Hashing - almost constant time • O(1+α) • “Mission impossible” • O(1) Searching - A Brute Force Approach • Direct-address table • Take into account the whole universe of keys Direct-address Table DIRECT-ADDRESS-SEARCH(T, k) return T[k] DIRECT-ADDRESS-INSERT(T, x) T[key[x]] := x DIRECT-ADDRESS-DELETE(T, x) T[key[x]] := NIL Hashing: the Idea Collision Handling: Closed Address Closed Address - Analysis • Assumption - simple uniform hashing • For j = 0, 1, 2, …, m-1, the average length of the list at E[j] is n/m. • The average cost for an unsuccessful search • Any key that is not in the table is equally likely to hash to any of the m address. • Total cost Θ(1+n/m) • The average cost to determine that the key is not in the list e[h(k)] is the cost to search to the end of the list, which is n/m. Closed Address - Analysis • For successful search (assuming that x i is the ith element inserted into the table, i = 1, 2, …, n) • For each i, the probability of that x i is searched is 1/n. • For a speciﬁc x i , the number of elements examined in a successful search is t+1, where t is the number of elements inserted into the same list as x i , after x i has been inserted • How to compute t? • Consider the construction process of the hash table. 1 n n ∑ i=1 (1 + t) Closed Address - Analysis • For successful search: (assuming that x i is the i th element inserted into the table, i = 1, 2, …, n) • For each i, the probability of that x i is searched is 1/n. • For a speciﬁc x i , the number of elements examined in a successful search is t+1, where t is the number of elements inserted into the same list as x i , after x i has been inserted. And for any j, the probability of that x j is inserted into the same list of x i is 1/m. So, the cost is: Cost for computing hashing 1 + 1 n n ∑ i=1 (1 + n ∑ j=i+1 1 m ) Expected number of elements in front of the searched one in the same linked list. Closed Address: Analysis • The average cost of a successful search: • Deﬁne α=n/m as load factor, • The average cost of a successful search is: 1 n n ∑ i=1 ( 1 + n ∑ j=i+1 1 m ) = 1 + 1 nm n ∑ i=1 (n − i) = 1 + 1 nm n−1 ∑ i=1 i = 1 + n − 1 2m = 1 + α 2 − α 2n = Θ(1 + α) Number of elements in front of the searched one in the same linked list Collision Handling: Open Address • All elements are stored in the hash table • No linked list is used • The load factor α cannot be larger than 1 • Collision is settled by “rehashing” • A function is used to get a new hashing address for each collided address • The hash table slots are probed successively, until a valid location is found. • The probe sequence can be seen as a permutation of (0,1,2,…,m-1) Linear Probing: An Example Commonly Used Probing • Linear probing: • Given an ordinary hash function h’, which is called an auxiliary hash function, the hash function is: (clustering may occur) • Quadratic probing: • Given auxiliary function h’ and nonzero auxiliary constant c 1 and c 2 , the hash function is: (secondary clustering may occur) • Double hashing: • Given auxiliary functions h 1 and h 2 , the hash function is: h(k, i) = (h′ (k) + i) mod m(i = 0,1,...,m − 1) h(k, i) = (h′ (k) + c 1 i + c 2 i 2 ) mod m(i = 0,1,...,m − 1) h(k, i) = (h 1 (k) + ih 2 (k)) mod m(i = 0,1,...,m − 1) Equally Likely Permutations • Assumption • Each key is equally likely to have any of the m! Permutations of (1,2,…,m) as its probe sequence • Note • Both linear and quadratic probing have only m distinct probe sequence, as determined by the ﬁrst probe Analysis for Open Address hashing • The average number of probes in an unsuccessful search is at most 1/(1-α) (α=n/m<1) • Assuming uniform hashing See [CLRS] p.1199, C.25 Analysis for Open Address Hashing • The average cost of probes in an successful search is at most (α=n/m<1) • Assuming uniform hashing 1 α ln 1 1 − α For your reference: Half full: 1.387; 90% full: 2.559 Hash Function • A good hash function satisﬁes the assumption of simple uniform hashing • Heuristic hashing functions • The division method: • The multiplication method: • No single function can avoid the worst case Θ(n) • So “universal hashing” is proposed. • Rich resource about hashing function • Gonnet and Baeza-Yates: Handbook of Algorithms and Data Structures, Addison-Wesley, 1991. h(k) = k mod m h(k) = ⌊m(kA mod 1)⌋(0 < A < 1) Array Doubling • Cost for search in a hash table is Θ(1+α) • If we can keep α constant, the cost will be Θ(1) • What if the hash table is more and more loaded? • Space allocation techniques such as array doubling may be needed • The problem of “unusually expensive” individual operation Looking at the Memory Allocation hashingInsert(HASHTABLE H, ITEM x) integer size = 0, num = 0; if size = 0 then allocate a block of size 1; size = 1; if num = size then allocate a block of size 2size; move all item into new table; size = 2size; insert x into the table; num = num + 1; return Elementary insertion: cost 1 Insertion with expansion: cost size Worst-case Analysis • For n execution of insertion operations • A bad analysis: the worst case for one insertion is the case when expansion is required, up to n • So, the worst case cost is in O(n 2 ) • Note the expansion is required during the i th operation only if i=2 k , and the cost of the i th operation Amortized Analysis - Why? • Unusually expensive operations • E.g., Insert-with-array-doubling • Relation between expensive and usually operations • Each piece of the doubling cost corresponds to some previous insert Amortized Analysis - How? • Amortized equation: • amortized cost = actual cost + accounting cost • Design goal for accounting cost • In any legal sequence of operations, the sum of the accounting costs is nonnegative • The amortized cost of each operation is fairly regular, in spite of the wide ﬂuctuate possible for the actual cost of individual operations Array Doubling • Why non-negative accounting cost? • For any possible sequence of operations? Amortized Actual Accounting Insert (normal) 3 1 2 Insert (doubling) 3 k+1 -k+2 K is the number of elements upon doubling Multi-pop StackMulti-pop Stack • Why non-negative accounting cost? • For any possible sequence of operations? Amortized Actual Accounting Push 2 1 1 Multi-pop 0 k -k K is the number of elements upon multi-pop Binary CounterBinary Counter • Why non-negative accounting cost? • For any possible sequence of operations? Amortized Actual Accounting Set 1 2 1 1 Set 0 0 1 -1 Thank you! Q & A","libVersion":"0.2.4","langs":""}