{"path":"pdf/算法设计与分析/L7 - Selection.pdf","text":"Introduction to Algorithm Design and Analysis [07] Selection Jingwei Xu http://cs.nju.edu.cn/ics/people/jingweixu/ index.html Institute of Computer Software Nanjing University In the last class … • MergeSort • Worst-case analysis of MergeSort • Lower Bounds for comparison-based sorting • Worst-case • Average-case The Selection • Selection - warm-ups • Finding max and min • Finding the second largest key • Adversary argument and lower bound • Selection - select the median • Expected linear time • Worst-case linear time • A Lower Bound for Finding the Median The Selection Problem • Problem Deﬁnition • Suppose E is an array containing n elements with keys from some linearly order set, and let k be an integer such that 1<=k<=n. The selection problem is to ﬁnd an element with the k th smallest key in E. • Special cases • Find the max/min: k=n or k=1 • Find the median (k=n/2) Selection v.s. Searching Lower Bound of Finding the Max • For any algorithm A that can compare and copy numbers exclusively, in the worst case, A cannot do fewer than n-1 comparisons to ﬁnd the largest entry in an array with n entries. • Proof: an array with n distinct entries is assumed. We can exclude a speciﬁc entry from being the largest entry only after it is determined to be “loser” to at least one entry. So, n‐1 entries must be “losers” in comparisons done by the algorithm. However, each comparison has only one loser, so at least n‐1 comparisons must be done. • Decision Tree and Lower Bound • Since the decision tree for the selection problem must have at least n leaves, the height of the tree is at least . It’s not a good lower bound. ⌈log n⌉ Finding max and min • The strategy • Pair up the keys, and do n/2 comparisons (if n odd, having E[n] uncompared); • Doing ﬁndMax for larger key set and ﬁndMin for small key set respectively (if n odd, E[n] included in both sets) • Number of comparisons • For even n: • For odd n: • n/2 + 2(n/2 − 1) = 3n/2 − 2 (n − 1)/2 + 2((n − 1)/2 + 1 − 1) = ⌈3n/2⌉ − 2 How to prove this lower bound? Adversary Argument! Unit of Information • Max and Min • That x is max can only be known when it is sure that every key other than x has lost some comparison. • That y is min can only be known when it is sure that every key other than y has win some comparison. • Each win or loss is counted as one unit of information • Any algorithm must have at least 2n‐2 units of information to be sure of specifying the max and min. • Adversary Strategy The principle: let the key win if it never lose, or, let the key lose if it never win, and change one value if necessary. Lower Bound by the Adversary Argument • Construct an input to force the algorithm to do more comparisons as possible • To give away as few as possible units of new information with each comparison. • It can be achieved that 2 units of new information are given away only when the status is N,N. • It is always possible to give adversary response for other status so that at most one new unit of information is given away, without any inconsistencies. • So, the Lower Bound is n/2+n-2 (for even n) n 2 × 2 + (n − 2) × 1 = 2n − 2 Find the 2 nd Largest Key • Brute force - using FindMax twice • Need 2n‐3 comparisons. • For a better algorithm • Collect some useful information from the ﬁrst FindMax • Observations • The key which loses to a key other than max cannot be the 2nd largest key. • To check “whether you lose to max?” Tournament for the 2 nd Largest Key Analysis of Finding the 2 nd • Any algorithm that ﬁnds secondLargest must also ﬁnd max before. (n-1) • The secondLargest can only be in those which lose directly to max. • On its path along which bubbling up to the root of tournament tree, max beat keys at most. • Pick up secondLargest • Total cost: ⌈log n⌉ (⌈log n⌉ − 1) n + ⌈log n⌉ − 2 Lower Bound by Adversary • Theorem • Any algorithm (that works by comparing keys) to ﬁnd the second largest in a set of n keys must do at least comparisons in the worst case. • Proof • There is an adversary strategy that can force any algorithm that ﬁnds secondLargest to compare max to distinct keys. • n + ⌈log n⌉ − 2 ⌈log n⌉ Weighted Key • Assigning a weight w(x) to each key • The initial values are all 1. • Adversary strategy Lower Bound by Adversary: Details • Note: the sum of weights is always n. • Let x is max, then x is the only nonzero weighted key, that is w(x)=n. • By the adversary rules: • Let K be the number of comparisons x wins against previously undefeated keys: • So, w k (x) ≤ 2w k−1 (x) n = w K (x) ≤ 2 K w 0 (x) = 2 K K ≤ ⌈log n⌉ Tracking the Losers to MAX Finding the Median: the Strategy • Observation • If we can partition the problem set of keys into 2 subsets: S1, S2, such that any key in S1 is smaller that that of S2, the median must located in the set with more elements. • Divide‐and‐Conquer • Only one subset is needed to be processed recursively. • Adjusting the Rank • The rank of the median (of the original set) in the subset considered can be evaluated easily. • An example • Let n=255 • The rank of median we want is 128 • Assuming |S1|=96, |S2|=159 • Then, the original median is in S2, and the new rank is 128‐96=32 Partitioning: Larger and Smaller • Dividing the array to be considered into two subsets: “small” and “large”, the one with more elements will be processed recursively. Selection: the Algorithm • Input: S, a set of n keys; and k, an integer such that . • Output: The k th smallest key in S. • Note: Median selection is only a special case of the algorithm, with . • Procedure • Element select(SetOfElements S, int k) • if |S|<=5 return direct solution; else • Constructing the subsets S 1 and S 2; • Processing one of S 1 ,S 2 with more elements, recursively. 1 ≤ k ≤ n k = ⌈n/2⌉ Key issue: How to construct the partition? Partition improved: the Strategy Constructing the Partition • Find the m*, the median of medians of all the groups of 5, as illustrated previously. • Compare each key in sections A and D to m*, and • Let • Let (m* is to be used as the pivot for the partition) S 1 = C ∪ {x | x ∈ A ∪ D and x < m*} S 2 = B ∪ {x | x ∈ A ∪ D and x > m*} Divide and Conquer • if (k=|S 1 |+1) return m*; • else if (k<=|S 1 |) return select(S 1 ,k); //recursion • else return select(S 2 ,k-|S 1 |-1); //recursion Analysis Worst Case Complexity of Select Relation to Median • Observation • Any algorithm of selection must know the relation of every element to the median. The adversary makes you wrong in either case Crucial Comparison • A crucial comparison • Establishing the relation of some x to the median. • Deﬁnition (for a comparison involving a key x) • Crucial comparison for x: the ﬁrst comparison where x>y, for some y=>median, or x<y for some y<=median • Non‐crucial comparison: the comparison between x and y where x>median and y<median， or vise versa Adversary for Lower Bound • Status of the key during the running of the Algorithm: • L: Has been assigned a value larger than median • S: Has been assigned a value smaller than median • N: Has not yet been in a comparison • Adversary rule: Notes on the Adversary Arguments • All actions explicitly speciﬁed above make the comparisons un-crucial. • At least, (n‐1)/2 L or S can be assigned freely. • If there are already (n‐1)/2 S, a value larger than median must be assigned to the new key, and if there are already (n‐1)/2 L, a value smaller than median must be assigned to the new key. The last assigned value is the median. • So, an adversary can force the algorithm to do (n-1)/2 un- crucial comparisons at least(In the case that the algorithm start out by doing (n-1)/2 comparisons involving two N. Lower Bound for Selection Problem • Theorem: • Any algorithm to ﬁnd the median of n keys(for odd n) by comparison of keys must do at least 3n/2‐3/2 comparisons in the worst case. • Argument: • There must be done n‐1 crucial comparisons at least. • An adversary can force the algorithm to perform as many as (n‐1)/2 uncritical comparisons. • Note: the algorithm can always start out by doing (n‐1)/2 comparisons involving 2 N‐keys, so, only (n‐1)/2 L or S left for the adversary to assign freely as the adversary rule. Thank you! Q & A","libVersion":"0.2.4","langs":""}