{"path":"pdf/算法设计与分析/L16 - DP1.pdf","text":"Introduction to Algorithm Design and Analysis [16] Dynamic Programming 1 Jingwei Xu https://ics.nju.edu.cn/~xjw Institute of Computer Software Nanjing University In the last class… • Single-source shortest paths • From BFS to the Dijkstra algorithm • All-pairs shortest paths • BF1, BF2, BF3 • Floyd-Warshall algorithm Dynamic Programming • Basic Idea of Dynamic Programming (DP) • Smart scheduling of subproblems • Minimum Cost Matrix Multiplication • BF1, BF2 • A DP solution • Weighted Binary Search Tree • The “same” DP with matrix multiplication Brute Force Recursion Subproblem Graph • The subproblem graph for a recursive algorithm A of some problem is deﬁned as: • vertex: the instance of the problem • directed edge: I->J if and only if when A invoked on I, it makes a recursive call directly on instance J. • Portion A(P) of the subproblem graph for Fibonacci function: here is ﬁb(6) Properties of Subproblem Graph • If A always terminates, the subproblem graph for A is a DAG. • For each path in the tree of activation frames of a particular call of A, A(P), there is a corresponding path in the subproblem graph of A connecting vertex P and a base-case vertex. • The subproblem graph can be viewed as a dependency graph of subtasks to be solved. • A top-level recursive computation traverse the entire subproblem graph in some memoryless style. Basic Idea of DP • Smart recursion • Compute each subproblem only once • Basic process of a “smart” recursion • Find a reverse topological order for the subproblem graph • In most cases, the order can be determined by particular knowledge of the problem • General method based on DFS is available • Scheduling the subproblems according to the reverse topological order • Record the subproblem solutions in a dictionary Recursion by DPFibonacci by DP DP: New Concept Recursion Many subproblems Scheduling of subproblems Storage/retrieval of subproblem results DAG of subproblems Topological ordering Subproblem dictionary Matrix Multiplication Order Problem • The task: • Find the product: A 1 x A 2 x…A n-1 x A n • A i is 2-dimensional array of diﬀerent legal sizes • The issues: • Matrix multiplication is associative • Diﬀerent computing order results in great diﬀerence in the number of operations • The problem: • Which is the best computing order Cost for Matrix Multiplication Let C = A pxq x B qxr C has pxr elements as c i,j So, pqr multiplications altogether c i,j = q ∑ k=1 a ik b kj There are q multiplication Cost for Matrix Multiplication Let C = A pxq x B qxr C has pxr elements as c i,j So, pqr multiplications altogether c i,j = q ∑ k=1 a ik b kj There are q multiplication An example: A 1 × A 2 × A 3 × A 4 30×1 1×40 40×10 10×25 ((A 1 ×A 2 )×A 3 )×A 4 : 20700 multiplications A 1 ×(A 2 ×(A 3 ×A 4 )): 11750 (A 1 ×A 2 )×(A 3 ×A 4 ): 41200 A 1 ×((A 2 ×A 3 )×A 4 ): 1400 Looking for a Greedy Solution • Strategy 1: “cheapest multiplication ﬁrst” • Success: A 30x1 x ((A 1x40 x A 40x10 ) x A 10x25 ) • Fail: (A 4x1 x A 1x100 ) x A 100x5 • Strategy 2: “largest dimension ﬁrst” • Correct for the second example above • A 1x10 x A 10x10 x A 10x2 : two results Intuitive Solution • Matrices: A 1 , A 2 , …, A n • Dimension: dim: d 0 ,d 1 ,d 2 ,…,d n-1 ,d n , for A i is d i-1 x d i • Sub-problem: seq: s 0 ,s 1 ,s 2 ,…,s k-1 ,s len , which means the multiplication of k matrices, with the dimensions: d s0 x d s1 ,d s1 x d s2 ,…,d s[len]-1 x d s[len] . • Note: the original problem is: seq=(0,1,2,…,n) Intuitive SolutionSubproblem Graph • Key issue • How can a subproblem be denoted using a concise identiﬁer? • For mmTry1, the diﬃculty originates from the varied intervals in each newSeq. • If we look at the last (contrast to the ﬁrst) multiplication, the two (not one) resulted subproblems are both contiguous subsequences, which can be uniquely determined by the pair: • <head-index, tail index> Improved RecursionSmart Recursion by DP • DFS can traverse the subproblem graph in time O(n 3 ) • At most n^2/2 vertices, as <i,j>, 0≤i<j≤n. • At most 2n edges leaving a vertex Order of Computation • Dependency between subproblems Multiplication Order An Example Arithmetic Expression Tree • Example input: d 0 =30, d 1 =1, d 2 =40, d 3 =10, d 4 =25 Getting the optimal Order • The core procedure is extractOrder, which ﬁlls the multiOrder array for subproblem (low, high), using information in the last array. Binary Search Tree Key with Diﬀerent Frequencies Unbalanced but Improved Optimal Binary TreeProblem Rephrased • Subproblem identiﬁcation • The keys are in sorted order. • Each subproblem can be identiﬁed as a pair of index (low, high) • Expected solution of the subproblem • For each key K i , a weight p i is associated. • Note: p i is the probability that the key is searched for. • The subproblem (low, high) is to ﬁnd the binary search tree with minimum weighted retrieval cost. Minimum Weighted Retrieval Cost • A(low, high, r) is the minimum weighted retrieval cost for subproblem (low, high) when K r is chosen as the root of its binary search tree. • A(low, high) is the minimum weighted retrieval cost for subproblem (low, high) over all choices of the root key. • p(low, high), equal to p low + p low+1 + … + p high , is the weight of the subproblem (low, high). • Note: p(low, high) is the probability that the key searched for is in this interval. Subproblem Solutions • Weighted retrieval cost of a subtree • T contains K low , ..., K high , and the weighted retrieval cost of T is W, with T being a whole tree. • As a subtree with the root at level 1, the weighted retrieval cost of T will be: W+p(low, high) • So, the recursive relations are: • A(low, high, r ) = p r +p(low, r-1)+A(low, r-1)+p(r+1, high) +A(r+1, high) = p(low, high)+A(low, r-1)+A(r+1, high) • A(low, high) = min{A(low, high, r) | low≤r≤high} Using DP • Array cost • Cost[low][high] gives the minimum weighted search cost of subproblem (low, high). • The cost[low][high] depends upon subproblems with higher ﬁrst index (row number) and lower second index (column number) • Array root • root[low][high] gives the best choice of root for subproblem (low, high) Array cost[]Optimal BST by DP Thank you! Q & A","libVersion":"0.2.4","langs":""}