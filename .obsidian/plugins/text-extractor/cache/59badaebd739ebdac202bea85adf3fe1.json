{"path":"pdf/课件/L11 - GraphTraversal.pdf","text":"Introduction to Algorithm Design and Analysis [11] Graph Traversal Jingwei Xu https://cs.nju.edu.cn/ics/people/jingweixu/ index.html Institute of Computer Software Nanjing University Course Contents BFS DFS DFS (directed) DFS (undirect ed) MST Path (single source) Path (all-pair) Dynamic program ming decomposition graph structure graph problems greedy DP optimization problems Course Contents BFS DFS DFS (directed) DFS (undirect ed) MST Path (single source) Path (all-pair) Dynamic program ming graph problems decomposition graph structure greedy DP optimization problems In the last class … • Dynamic Equivalence Relation • Implementing disjoint set by Union-Find • Straight Union-Find • Making Shorter Tree by Weighted Union • Compressing Path by Compressing Find • Amortized analysis of wUnion-cFind Graph EverywhereGraph Everywhere Protein-protein interaction network Graph Basics • Node • Entities of interest • V(G) • Edge • Relations of interest • E(G) ∈ V x V Graph Traversals • Depth-First and Breadth-First Search • Finding Connected Components • General DFS/BFS Skeleton • Depth-First Search Trace Graph Traversal A D F B C G E Starting node Not reachable Depth-First Search Graph Traversal A D F B C G E Starting node Not reachable Breadth-First Search Outline of Depth-First Search • dfs(G, v) • Mark v as “discovered”. • For each vertex w that edge vw is in G: • If w is undiscovered: • dfs(G, w) • Otherwise: • “check” vw without visiting w. • Mark v as “ﬁnished”. A vertex must be exact one of three diﬀerent status: Undiscovered Discovered but not ﬁnished Finished That is: exploring vw, visiting w, exploring from there as much as possible, and backtrack from w to v. Outline of Breadth-First Search • bfs(G, v) • Mark s as “discovered”; • enqueue(pending, s); • while (pending is nonempty) • dequeue(pending, v); • For each vertex w that edge vw is in G: • If w is “undiscovered” • Mark w as “discovered” and enqueue(pending, w) • Mark v as “ﬁnished”; Finding Connected Components • Input: a symmetric digraph G, with n nodes and 2m edges (interpreted as undirected graph), implemented as a array adjVertices[1,…n] of adjacency lists. • Output: an array cc[1..n] of component number for each node v i . • void connectedComponents(intlist[] adjVertices, int n, int[] cc)// This is a wrapper procedure • int[] color=new int[n+1]; • int v; • <initialize color array to white for all vertices> • for(v=1; v≤n; v++) • if(color[v]==white) • ccDFS(adjVertices, color, v, v, cc); • return Depth-ﬁrst search ccDFS: the procedure • void ccDFS(intList[] adjVertices, int[] color, int v, int ccNum, int[] cc)// v as the code of current connected component • int w; • intList remAdj; • color[v]=gray; • cc[v]=ccNum; • remAdj=adjVertices[v]; • while(remAdj != nil) • w=ﬁrst(remAdj); • if(color[w]==white) • ccDFS(adjVertices, color, w, ccNum, cc); • remAdj=rest(remAdj); • color[v]=black; • return The elements of remAdj are neighbors of v Processing the next neighbor, if existing, another depth‐ﬁrst search to be incurred v ﬁnished Analysis of CC Algorithm • connectedComponents, the wrapper • Linear in n (color array initialization+for loop on adjVertices) • ccDFS, the depth-ﬁrst searcher • In one execution of ccDFS on v, the number of instructions(rest(remAdj)) executed is proportional to the size of adjVertices[v]. • Note: ∑ (size of adjVertices[v]) is 2m, and the adjacency lists are traversed only once. • So, the time complexity is in Θ(m+n) • Extra space requirements: • Color array • Activation frame stack for recursion Visits On a Vertex • Classiﬁcation for visits on a vertex • First visit (exploring): status: white->gray • (Possibly) multi-visits by backtracking to: status keeps gray • Last visit (no more branch-ﬁnished): status: gray->black • Different operations can be done, during the different visits on a speciﬁc vertex • On the vertex • On (selected) incident edges Depth-ﬁrst Search Trees A D F B C G E Root of tree 1 Root of tree 2 DFS forest={(DFS tree1), (DFS tree2)} T.E: tree edge B.E: back edge D.E: descendant edge C.E: cross edge A ﬁnished vertex is never revisited, such as C. B.EB.ET.E T .E T .ET.E C.ED.EC.E C.ET.E B.EC.E Depth-First Search — Generalized Skeleton • Input: Array adjVertices for graph G • Output: Return value depends on application • int dfsSweep(intList[], adjVertices, int n, …) • int ans; • <Allocate color array and initialize to white> • for each vertex v of G, in some order • if(color[v]==white) • int vAns=dfs(adjVertices, color, v, …); • <Process vAns> • // continue loop • return ans; Depth-First Search — Generalized Skeleton • int dfs(intList[] adjVertices, int[] color, int v, …) • int w; • intList remAdj; • int ans; • color[v]=gray; • <Preorder processing of vertex v> • remAdj=adjVertices[v]; • while(remAdj != nil) • w=ﬁrst(remAdj); • if(color[w]==white) • <Exploratory processing for tree edge vw> • int wAns=dfs(adjVertices, color, w, …) • <Backtrack processing for tree edge vw, using wAns> • else • <Checking for nontree edge vw> • remAdj=rest(remAdj); • <Postorder processing of vertex v, including ﬁnal computation of ans> • color[v]=black; • return ans; If partial search is used for a application, tests for termination may be inserted here. Specialized for connected components: Parameter added Preorder processing inserted - cc[v] =ccNum Breadth-First Search — Skeleton • Input: Array adjVertices for graph G • Output: Return value depends on application • void bfsSweep(intList[], adjVertices, int n, …) • int ans; • <Allocate color array and initialize to white> • for each vertex v of G, in some order • if(color[v]==white) • void bfs(adjVertices, color, v, …); • // continue loop • return; Breadth-First Search — Skeleton • void bfs(intList[] adjVertices, int[] color, int v, …) • int w; intList remAdj; Queue pending; • color[v]=gray; enqueue(pending, v); • while(pending is nonempty) • w=dequeue(pending); remAdj=adjVertices[w]; • while(remAdj!=nil) • x=ﬁrst(remAdj); • if(color[x]==while) • color[x]=gray; enqueue(pending, x); • remAdj=rest(remAdj); • <processing of vertex w> • color[w]=black; • return Can be further generalized DFS v.s. BFS Search • Processing opportunities for a node • Depth-ﬁrst: 2 • At discovering • At ﬁnishing • Breadth-ﬁrst: only 1, when de-queued • At the second processing opportunity for the DFS, the algorithm can make use of information about the descendants of the current node. Time Relation on Changing Color • Keeping the order in which vertices are encountered for the ﬁrst or last time • A global integer time: 0 as the initial value, incremented with each color changing for any vertex, and the ﬁnal value is 2n • Array discoverTime: the i th element records the time vertex v i turns into gray • Array ﬁnishTime: the i th element records the time vertex v i turns into black • The active interval for vertex v, denoted as active(v), is the duration while v is gray, that is: • discoverTime[v], …, ﬁnishTime[v] Depth-First Search Trace • General DFS skeleton modiﬁed to compute discovery and ﬁnishing times and “construct” the depth-ﬁrst search forest. • int dfsTraceSweep(intList[] adjVertices, int n, int[] discoverTime, int[] ﬁnishTime, int[] parent) • int ans; int time=0; • <Allocate color array and initialize to white> • for each vertex v of G, in some order • if(color[v]==white) • parent[v]=-1 • int vAns=dfsTrace(adjVertices, color, v, discoverTime, ﬁnishTime, parent, time); • //continue loop • return ans; Depth-First Search Trace • int dfsTrace(intList[] adjVertices, int[] color, int v, int[] discoverTime, int[] ﬁnishTime, int[] parent, int time) • int w; intList remAdj; int ans; • color[v]=gray; time++; discoverTime[v]=time; • remAdj=adjVertices[v]; • while(remAdj != nil) • w=ﬁrst(remAdj); • if(color[w]==white) • parent[w]=v; • Int wAns=dfs(adjVertices, color, w, discoverTime, ﬁnishTime, parent, time); • else <Checking for nontree edge vw> • remAdj=rest(remAdj); • time++; ﬁnishTime[v]=time; • color[v]=black; • Return ans; Active Interval A D F B C G E B.EB.ET.E T .E T .ET.E C.ED.EC.E C.ET.E B.EC.E 1/10 8/9 3/4 11/14 12/13 5/6 2/7 The relations are summarized in the next frame T.E: tree edge B.E: back edge D.E: descendant edge C.E: cross edge Properties of Active Intervals(1) • If w is a descendant of v in the DFS forest, then active(w)⊆active(v), and the inclusion is proper if w≠v. • Proof: • Deﬁne a partial order <: w<v iﬀ. w is a proper descendants of v in its DFS tree. The proof is by induction on <. • If v is minimal. The only descendant of v is itself. Trivial. • Assume that for all x<v, if w is a descendant of x, then active(w)⊆active(x). • Let w be any proper descendant of v in the DFS tree, there must be some x such that vx is a tree edge on the tree path to w, so w is a descendant of x. According to dfsTrace, we have active(x)⊂active(v), by inductive hypothesis, active(w)⊂active(v). Properties of Active Intervals(2) • If active(w)⊆active(v), then w is a descendant of v. And if active(w)⊂active(v), then w is a proper descendant of v. • That is: w is discovered while v is active. • Proof: • If w is not a descendant of v, there are two cases: • v is a proper descendant of w, then active(v)⊂active(w), so, it is impossible that active(w)⊆active(v), contradiction. • There is no ancestor/descendant relationship between v and w, then active(w) and active(v) are disjoint, contradiction. Properties of Active Intervals(3) • If v and w have no ancestor/descendant relationship in the DFS forest, then their active intervals are disjoint. • Proof: • If v and w are in diﬀerent DFS tree, it is trivially true, since the trees are processed one by one. • Otherwise, there must be a vertex c, satisfying that there are tree paths c to v, and c to w, without edges in common. Let the leading edges of the two tree path are cy, cz, respectively. According to dfsTrace, active(y) and active(z) are disjoint. • We have active(v)∈active(y), active(w)∈active(z). So, active(v) and active(w) are disjoint. Properties of Active Intervals(4) • If edge vw ∈ E G , then • vw is a cross edge iﬀ. active(w) entirely precedes active(v). • vw is a descendant edge iﬀ. there is some third vertex x, such that active(w)⊂active(x)⊂active(v), • vw is a tree edge iﬀ. active(w)⊂active(v), and there is no third vertex x, such that active(w)⊂active(x)⊂active(v), • vw is a back edge iﬀ. active(v)⊂active(w), Ancestor and Descendant • That w is a descendant of v in the DFS forest means that there is a direct path from v to w in some DFS tree. • The path is also a path in G. • However, if there is a direct path from v to w in G, is w necessarily a descendant of v in the DFS forest? DFS Tree Path • [White Path Theorem] w is a descendant of v in a DFS tree iff. At the time v is discovered(just to be changing color into gray), there is a path in G from v to w consisting entirely of white vertices. Proof of White Path Theorem • Proof • => all the vertices in the path are descendants of v. • <= by induction on the length k of a white path from v to w. • When k=0, v=w. • For k>0, let P=(v, x 1 ,x 2 ...x k =w). There must be some vertex on P which is discovered during the active interval of v, e.g. x 1 , Let x i is earliest discovered among them. Divide P into P 1 from v to x i , and P 2 from x i to w. P 2 is a white path with length less than k, so, by inductive hypothesis, w is a descendant of x i . Note: active(x i )⊆active(v), so x i is a descendant of v. By transitivity, w is a descendant of v. Thank you! Q & A","libVersion":"0.2.4","langs":""}