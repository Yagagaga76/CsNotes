{"path":"pdf/算法设计与分析/L13 - Undirected Graph.pdf","text":"Introduction to Algorithm Design and Analysis [13] Undirected Graph Jingwei Xu https://ics.nju.edu.cn/~xjw Institute of Computer Software Nanjing University In the last class … • Directed Acyclic Graph • Topological order • Critical path analysis • Strongly Connected Component (SCC) • Strong connected component and condensation • Finding SCC based on DFS DFS on Undirected Graph • Undirected Graph • Symmetric Digraph • Undirected Graph DFS Skeleton • Biconnected Components • Articulation Points • Bridge • Other undirected graph problems • Orientation of an undirected graph • Simpliﬁed Minimum Spanning Tree What is Diﬀerent for “Undirected” • Characteristics of undirected graph traversal • One edge may be traversed for two times in opposite directions. • For an undirected graph, DFS provides an orientation for each of its edges • Oriented in the direction in which they are ﬁrst encountered. Edges in DFS Modiﬁcations to the DFS Skeleton • All the second encounter are bypassed. • So, the only substantial modiﬁcation is for the possible back edges leading to an ancestor, but not direct parent. • We need know the parent, that is, the direct ancestor, for the vertex to be processed. DFS Skeleton for Undirected Graph • void dfsSweep(intList[] adjVertices, int n, …) • int ans; • <Allocate color array and initialize to white> • for each vertex v of G, in some order • if(color[v]==white) • Int vAns=dfs(adjVertices, color, v, -1,…); • <Process vAns> • //continue loop • return ans; DFS Skeleton for Undirected Graph • int dfs(intList[] adjVertices, int[] color, int v, int p,…) • int w; intList remAdj; int ans; color[v]=gray; • <Preorder processing of vertex v> • remAdj=adjVertices[v]; • while(remAdj != nil) • w=ﬁrst(remAdj); • if(color[w]==white) • <Exploratory processing for tree edge vw> • dfs(adjVertices, color, w, v, …); • <Backtrack processing for tree edge vw, using wAns> • else if(color[w]==gray && w!=p) • <Checking for nontree edge vw> • remAdj=rest(remAdj); • <Postorder processing of vertex v, including ﬁnal computation of ans> • color[v]=black; • return ans; Complexity of Undirected DFS • Θ(m+n) • If each inserted statement for specialized application runs in constant time • The same with directed graph DFS • Extra space Θ(n) • For array color, or activation frames of recursion Biconnected Graph • Being connected • Tree: acyclic, least (cost) connected • Node/edge connected: fault-tolerant connection • Articulation point (2-node connected) • v is an articulation point if deleting v leads to disconnection • Bridge (2-edge connected) • uv is a bridge if deleting uv leads to disconnection Articulation Points Deﬁnition Transformation • “Short deﬁnition” • Deleting v leads to disconnection • “Long deﬁnition” • If there exist nodes w and x, such that v is in every path from w to x (w and x are vertices diﬀerent from v) • “Long deﬁnition” or “DFS deﬁnition” • No back edges linking any vertex in some w-rooted subtree and any ancestor of v Articulation Point Algorithm Updating the value of back • v ﬁrst discovered • back=discoverTime(v) • Trying to explore, but a back edge vw from v encountered • back=min(back, discoverTime(w)) • Backtracking from w to v • back=min(back, wback) The back value of v is the smallest discover time a back edge “sees” from any subtree of v. ExampleExampleExample Keeping the Track of Backing • Tracking data • For each vertex v, a local variable back is used to store the required information, as the value of discoverTime of some vertex. • Testing for bicomponent • At backtracking from w to v, the condition implying a bicomponent is: • wBack ≥ discoverTime(v) When back is no less than the discover time of v, there is at least one subtree of v connected to other part of the graph only by v. (where wback is the returned back value for w) Example Articulation Point Algorithm Correctness • We have seen that: • If v is the articulation point farthest away from the root on the branch, then one bicomponent is detected. • So, we need only prove that: • In a DFS tree, a vertex (not root) v is an articulation point if and only if (1) v is not a leaf; (2) some subtree of v has no back edge incident with a proper ancestor of v. Characteristics of Articulation Point • In a DFS tree, a vertex (not root) v is an articulation point if and only if (1) v is not a leaf; (2) some subtree of v has no back edge incident with a proper ancestor of v. • <= Trivial • => • By deﬁnition, v is on every path between some x, y (diﬀerent from v). • At least one of x, y is a proper descendent of v (otherwise, x<- >root<->y not containing v). • By contradiction, suppose that every subtree of v has a back edge to a proper ancestor of v, we can ﬁnd a xy-path not containing v for all possible cases (only 2 cases) Case 1Case 2What about the root? • One single DFS tree • We only consider each connected component • Root AP ≡Two or more sub-trees • The root is an articulation point Deﬁning the Bridge • Short deﬁnition • Removing uv leading to disconnection • Long deﬁnition • Edge uv is a bridge iﬀ node u and v are connected only by uv • DFS Deﬁnition • Edge uv is a tree edge in DFS • Three is no subtree rooted at v to any proper ancestor of v (including u) Bridge Algorithm Other Traversal Problems • Orientation of an undirected graph • Give each edge a direction • Satisfying pre-speciﬁed constraints • E.g., the “in-degree of each vertex is at least 1” • Possible or not? • If possible, how to? • As for “in-degree ≥ 1” • Orientation possible iﬀ. the graph has at least a circle • Find the end point of some back edge • A second DFS from this end point Other Traversal Problems • Get MST in O(m+n) time • Given that edges weights are only 1 and 2 • Graph traversal is sufﬁcient • DFS over “weight 1 edges” only • DFS over “weight 2 edges” only MST: Minimum Spanning Tree Thank you! Q & A","libVersion":"0.2.4","langs":""}