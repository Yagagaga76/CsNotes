{"path":"pdf/算法设计与分析/L15 - Path in Graph.pdf","text":"Introduction to Algorithm Design and Analysis [15] Path in Graph Jingwei Xu https://ics.nju.edu.cn/~xjw Institute of Computer Software Nanjing University In the last class… • Optimization Problem • Greedy strategy • MST Problem • Prim algorithm • Kruskal algorithm • Single-Source Shortest Path Problem • Dijkstra algorithm Path in Graph • Single-source shortest paths (SSSP) • Dijkstra algorithm by example • Priority queue-based implementation • Proof of correctness • All-pairs shortest paths (APSP) • Shortest path and transitive closure • Warshall algorithm for transitive closure • BF1, BF2, BF3 => Warshall algorithm • Floyd-Warshall algorithm for shortest paths Single Source Shortest Paths Warm Up • Single-source shortest path over uniformly weighted graph • Just BFS Dĳkstra’s Algorithm s 7 7 2 1 2 5 1 2 4 4 8 3 5 3 4 6 3 0 ∞ ∞ ∞ ∞ ∞ ∞ ∞ Dĳkstra’s Algorithm s 7 7 2 1 2 5 1 2 4 4 8 3 5 3 4 6 3 0 ∞ ∞ ∞ ∞ ∞ ∞ ∞ Dĳkstra’s Algorithm s 7 7 2 1 2 5 1 2 4 4 8 3 5 3 4 6 3 0 ∞ ∞ ∞ ∞ ∞ ∞ ∞ Dĳkstra’s Algorithm s 7 7 2 1 2 5 1 2 4 4 8 3 5 3 4 6 3 0 ∞ ∞ ∞ ∞ ∞ ∞ Dĳkstra’s Algorithm s 7 7 2 1 2 5 1 2 4 4 8 3 5 3 4 6 3 0 ∞ ∞ ∞ ∞ ∞ ∞ 4 Dĳkstra’s Algorithm s 7 7 2 1 2 5 1 2 4 4 8 3 5 3 4 6 3 0 ∞ ∞ ∞ ∞ ∞ ∞ 4 Dĳkstra’s Algorithm s 7 7 2 1 2 5 1 2 4 4 8 3 5 3 4 6 3 0 ∞ ∞ ∞ ∞ ∞ 4 Dĳkstra’s Algorithm s 7 7 2 1 2 5 1 2 4 4 8 3 5 3 4 6 3 0 ∞ ∞ ∞ ∞ ∞ 8 4 Dĳkstra’s Algorithm s 7 7 2 1 2 5 1 2 4 4 8 3 5 3 4 6 3 0 ∞ ∞ ∞ ∞ ∞ 8 4 Dĳkstra’s Algorithm s 7 7 2 1 2 5 1 2 4 4 8 3 5 3 4 6 3 0 ∞ ∞ ∞ ∞ 8 4 Dĳkstra’s Algorithm s 7 7 2 1 2 5 1 2 4 4 8 3 5 3 4 6 3 0 ∞ ∞ ∞ ∞ 1 8 4 Dĳkstra’s Algorithm s 7 7 2 1 2 5 1 2 4 4 8 3 5 3 4 6 3 0 ∞ ∞ ∞ ∞ 1 8 4 Dĳkstra’s Algorithm s 7 7 2 1 2 5 1 2 4 4 8 3 5 3 4 6 3 0 ∞ ∞ ∞ 1 8 4 Dĳkstra’s Algorithm s 7 7 2 1 2 5 1 2 4 4 8 3 5 3 4 6 3 0 ∞ ∞ ∞ 2 1 8 4 Dĳkstra’s Algorithm s 7 7 2 1 2 5 1 2 4 4 8 3 5 3 4 6 3 0 ∞ ∞ ∞ 2 1 8 4 Dĳkstra’s Algorithm s 7 7 2 1 2 5 1 2 4 4 8 3 5 3 4 6 3 0 ∞ ∞ 2 1 8 4 Dĳkstra’s Algorithm s 7 7 2 1 2 5 1 2 4 4 8 3 5 3 4 6 3 0 ∞ ∞ 2 1 8 4 7 Dĳkstra’s Algorithm s 7 7 2 1 2 5 1 2 4 4 8 3 5 3 4 6 3 0 ∞ ∞ 2 1 8 4 7 Dĳkstra’s Algorithm s 7 7 2 1 2 5 1 2 4 4 8 3 5 3 4 6 3 0 ∞ ∞ 2 1 8 4 7 Dĳkstra’s Algorithm s 7 7 2 1 2 5 1 2 4 4 8 3 5 3 4 6 3 0 ∞ ∞ 2 1 8 4 7 Dĳkstra’s Algorithm s 7 7 2 1 2 5 1 2 4 4 8 3 5 3 4 6 3 0 ∞ 2 1 8 4 7 Dĳkstra’s Algorithm s 7 7 2 1 2 5 1 2 4 4 8 3 5 3 4 6 3 0 ∞ 2 1 8 4 4 7 Dĳkstra’s Algorithm s 7 7 2 1 2 5 1 2 4 4 8 3 5 3 4 6 3 0 ∞ 2 1 8 4 4 7 Dĳkstra’s Algorithm s 7 7 2 1 2 5 1 2 4 4 8 3 5 3 4 6 3 0 ∞ 2 1 8 4 4 7 Dĳkstra’s Algorithm s 7 7 2 1 2 5 1 2 4 4 8 3 5 3 4 6 3 0 ∞ 2 1 8 4 7 Dĳkstra’s Algorithm s 7 7 2 1 2 5 1 2 4 4 8 3 5 3 4 6 3 0 ∞ 2 1 8 4 7 3 Dĳkstra’s Algorithm s 7 7 2 1 2 5 1 2 4 4 8 3 5 3 4 6 3 0 ∞ 2 1 8 4 7 3 Dĳkstra’s Algorithm s 7 7 2 1 2 5 1 2 4 4 8 3 5 3 4 6 3 0 ∞ 2 1 8 4 7 3 Dĳkstra’s Algorithm s 7 7 2 1 2 5 1 2 4 4 8 3 5 3 4 6 3 0 ∞ 2 1 8 4 7 3 Dĳkstra’s Algorithm s 7 7 2 1 2 5 1 2 4 4 8 3 5 3 4 6 3 0 2 1 8 4 7 3 Dĳkstra’s Algorithm s 7 7 2 1 2 5 1 2 4 4 8 3 5 3 4 6 3 0 2 1 8 4 7 3 9 Dĳkstra’s Algorithm s 7 7 2 1 2 5 1 2 4 4 8 3 5 3 4 6 3 0 2 1 8 4 3 9 Dĳkstra’s Algorithm s 7 7 2 1 2 5 1 2 4 4 8 3 5 3 4 6 3 0 2 1 8 4 3 9 6 Dĳkstra’s Algorithm s 7 7 2 1 2 5 1 2 4 4 8 3 5 3 4 6 3 0 2 1 8 4 3 9 6 Dĳkstra’s Algorithm s 7 7 2 1 2 5 1 2 4 4 8 3 5 3 4 6 3 0 2 1 8 4 3 9 6 Dĳkstra’s Algorithm s 7 7 2 1 2 5 1 2 4 4 8 3 5 3 4 6 3 0 2 1 4 3 9 6 Dĳkstra’s Algorithm s 7 7 2 1 2 5 1 2 4 4 8 3 5 3 4 6 3 0 2 1 4 3 9 6 6 Dĳkstra’s Algorithm s 7 7 2 1 2 5 1 2 4 4 8 3 5 3 4 6 3 0 2 1 4 3 9 6 6 Dĳkstra’s Algorithm s 7 7 2 1 2 5 1 2 4 4 8 3 5 3 4 6 3 0 2 1 4 3 9 6 6 Dĳkstra’s Algorithm s 7 7 2 1 2 5 1 2 4 4 8 3 5 3 4 6 3 0 2 1 4 3 9 6 6 Dĳkstra’s Algorithm s 7 7 2 1 2 5 1 2 4 4 8 3 5 3 4 6 3 0 2 1 4 3 9 6 6 Dĳkstra’s Algorithm s 7 7 2 1 2 5 1 2 4 4 8 3 5 3 4 6 3 0 2 1 4 3 9 6 6 Priority Queue-based Implementation Correctness of Dijkstra Algorithm The Dijkstra Skeleton • Single-source shortest path (SSSP) • SSSP + node weight constraint • E.g. in routing • Each router has its cost (node cost) • Each route has its cost (edge cost) • SSP + capacity constraint • The “pipe problem” • Maximize the min edge weight • The “electric vehicle problem” • Minimize the max edge weight  “Dijkstra Skeleton” All-pairs Shortest Paths • For all pair of vertices in a graph, say, u, v: • Is there a path from u to v? • What is the shortest path from u to v? • Reachability as a (reﬂexive) transitive closure of the adjacency relation • Which can be represented as a bit matrix Transitive Closure by Shortcuts • The idea: if there are edges s i s k , s k s j , then an edge s i s j , the “shortcut” is inserted. Shortcut Algorithm • Input: A, an n×n boolean matrix that represents a binary relation • Output: R, the boolean matrix for the transitive closure of A • Procedure • void simpleTransitiveClosure(boolean[][] A, int n, boolean[][] R) • int i,j,k; • Copy A to R; • Set all main diagonal entries, r ii , to true; • while(any entry of R changed during one complete pass) • for(i=1; i≤n; i++) • for(j=1; j≤n; j++) • for(k=1; k≤n; k++) • r ij =r ij ∨(r ik ∧r kj ) The order of (i,j,k) matters O(n 4 ) Another Way to Add Shortcuts • Enumerate all edges (x,v) • v as the destination • Enumerate all possible sources u while any entry of R changed for all vertices u for every edge (x,v) r uv =r uv ∨(r ux ∧r xv ) O(n 2 m) Length of the Path • Recursion • Reachable via at most k edges • Enumeration • Enumerate all path length • Enumerate all sources and destinations for k=1 to n-1 for all vertices u for all vertices v for all vertices x pointing to v r kuv =r k-1uv ∨(r k-1ux ∧r xv ) O(n 4 ) r uv =1 Floyd’s Lemma Shortcuts in Diﬀerent Order • Duplicated checking may be deleted by changing the order of the vertices. Change the Order: The Warshall Algorithm • void simpleTransitiveClosure(boolean[][] A, int n, boolean[][] R) • int i,j,k; • Copy A to R; • Set all main diagonal entries, r ii , to true; • while(any entry of R changed during one complete pass) • for(k=1; k≤n; i++) • for(i=1; i≤n; j++) • for(j=1; j≤n; j++) • r ij =r ij ∨(r ik ∧r kj ) k Varys in the outmost loop Note: “false to true” can not be reversed Why the Floyd-Warshall Algorithm Works • <k,i,j> or <i,j,k> • The order matters • That’s why Dijkstra fails Correctness of the Warshall Algorithm • Notation: • The value of r ij changes during the execution of the body of the “for k…” loop • After initializations: r ij(0) • After the k th time of execution: r ij(k) Correctness of the Warshall Algorithm • If there is a simple path from s i to s j (i!=j) for which the highest- numbered intermediate vertex is s k , then r ĳ(k) =true. • Proof by induction: • Base case: r ij(0) =true if and only if s i s j ∈E • Hypothesis: the conclusion holds for h<k(h≥0) • Induction: the simple s i s j -path can be looked as s i s k -path+s k s j - path, with the indices h 1 , h 2 of the highest-numbered intermediate vertices of both segment strictly (simple path) less than k. So, r ik(h1) =true, r kj (h2) =true, then r ik (k-1) =true, r kj(k-1) =true(Remember, false to true can not be reversed). So, r ij(k) =true Highest-numbered Intermediate Vertex Correctness of the Warshall Algorithm • If r ĳ (k) =true, then there is a (s i , s j ) (k) path • Proof • If r ij(0) =true, then there is (s i ,s j ) (0) path • If r ij ﬁrst become true in round k, then • rik(k-1) = true, rkj(k-1) = true • We have a “si->sk->sj” path  • Intermediate nodes in {1, 2, ..., k-1} ∪ {k} All-pairs Shortest Paths • Shortest path property • If a shortest path from x to z consisting of path P from x to y followed by path Q from y to z. Then P is a shortest xy- path, and Q, a shortest yz-path. • The regular matrix representing a graph can easily be transformed into a (minimum) distance matrix D (just replacing 1 by edge weight, 0 by inﬁnity, and setting main diagonal elements as 0) Computing the Distance Matrix • Basic formula: • D (0) [i][j]=wij • D (k) [i][j]=min(D (k-1) [i][j], D (k-1) [i][k]+ D (k-1) [k][j]) • Basic property: • D (k) [i][j] = dij (k) • where d ij(k) is the weight of a shortest path from v i to v j with highest numbered intermediate vertex v k . All-pairs Shortest Paths • Floyd algorithm • Only slight changes on Washall’s algorithm. All-pairs Shortest Paths • Construction of the routing table • Forward, backward • APSP + capacity constraints • The pipeline problem • The electric vehicle problem Floyd algorithm => Floyd skeleton Negative WeightNegative Weight • Can the shortest path algorithm work correctly? • Dijkstra’s algorithm • No negative weight edge • Floyd’s algorithm • No negative weight cycle Matrix Representation • Deﬁne family of matrix A (p) : • a ĳ(p) =true if and only if there is a path of length p from s i to s j . • A (0) is speciﬁed as identity matrix. A (1) is exactly the adjacency matrix. • Note that a ĳ (2) =true if and only if exists some s k , such that both a ik (1) and a kj (1) are true. So, a ĳ(2) =∨ k=1,2,...,n (a ik (1) ∧a kj (1) ), which is an entry in the Boolean matrix product. Boolean Matrix Operations • Boolean matrix product C=AB as: • c ij =∨ k=1,2,...,n (a ik ∧b kj ) • Boolean matrix sum D=A+B as: • d ij =a ij ∨b ij • R, the transitive closure matrix of A, is the sum of all A p , p is a non-negative integer. • For a digraph with n vertices, the length of the longest simple path is no larger than n-1. Bit Matrix • A bit string of length n is a sequence of n bits occupying contiguous storage(word boundary) (usually, n is larger than the word length of a computer) • If A is a bit matrix of n×n, then A[i] denotes the ith row of A which is a bit string of length n. a ĳ is the jth bit of A[i]. • The procedure bitwiseOR(a,b,n) compute a∨b bitwise for n bits, leaving the result in a. Straightforward Multiplication of Bit Matrix • Computing C=AB • <Initialize C to the zero matrix> • for (i=1; i≤n, i++) • for (k=1; k≤n, k++) • if (a ik ==true) bitwiseOR(C[i], B[k], n) Thought as a union of sets (row union), n 2 unions are done at most In the case of a ik is true, c ĳ =a ik b kj is true iff. b kj is true. As a result: C[i]=∪ k∊A[i] B[k], (A[i]={k|a ik =true}) Union for B[k] is repeated each time when the kth bit is true in a different row of A is encountered. Reducing the Duplicates by Grouping • Multiplication of A, B, two 12 x 12 matrices Segment Length t The Segmentation for Matrix A An Example t=4 Storage of the Row Combinations • Using one large 2-dimensional array • Goals • keep all unions generated • provide indexing for using • Coding with in a group • One-to-one correspondence between a bit string of length t and one union for a subset of a set of t elements • Establishing indexing for union required • When constructing a row of AB, a segment can be notated as a integer. Use it as index. Storage the Unions Array for Row Combinations Cost as Function of Group Size • Cost for the pre-computation • There are 2 t diﬀerent combination of rows in one group, including an empty and t singleton. Note, in a suitable order, each combination can be made using only one union. So, the total number of union is g[2 t -(t+1)], where g=n/t is the number of group. • Cost for the generation of the product • In computing one of n rows of AB, at most one combination from each group is used. So, the total number of union is n(g-1) Selecting Best Group Size • The total number of union done is: • g[2 t -(t+1)]+n(g-1) ≈ (n2 t )/t+n 2 /t (Note: g=n/t) • Trying to minimize the number of union • Assuming that the ﬁrst term is of higher order: • Then t≥lgn, and the least value is reached when t=lgn. • Assuming that the second term is of higher order: • Then t≤lgn, and the least value is reached when t=lgn. • So, when t≈lgn, the number of union is roughly 2n 2 /lgn, which is of lower order than n 2 . We use t=⎣lgn⎦ Sketch for the Procedure • t=⎣lgn⎦; g=⎡n/t⎤; • <Compute and store in allUnions unions of all combinations of rows of B> • for (i=1; i≤n; i++) • <Initialize C[i] to 0> • for (j=1; j≤g; j++) • C[i] = C[i] ∪ allUnions[j][bitSeg(A[i],j,t)] Kronrod Algorithm • Input: A,B and n, where A and B are n×n bit matrices. • Output: C, the Boolean matrix product. • Procedure • The processing order has been changed, from “row by row” to “group by group”, resulting the reduction of storage space for unions. Complexity of the Kronrod Algorithm • For computing all unions within a group, 2 t - 1 union operations are done. • One union is bitwiseOR’ed to n row of C • So, altogether, (n/t)(2 t -1+n) row unions are done. • The cost of row union is ⎡n/w⎤ bitwise or operations, where w is word size of bitwise or instruction dependent constant. Thank you! Q & A","libVersion":"0.2.4","langs":""}