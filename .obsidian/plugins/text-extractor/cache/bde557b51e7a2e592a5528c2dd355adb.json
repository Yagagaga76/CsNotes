{"path":"pdf/算法设计与分析/L4 - QuickSort.pdf","text":"Introduction to Algorithm Design and Analysis [04] QuickSort Jingwei Xu https://cs.nju.edu.cn/ics/people/jingweixu/ index.html Institute of Computer Software Nanjing University In the Last Class … • Recursion in algorithm design • The divide and conquer strategy • Proving the correctness of recursive procedures • Solving recurrence equations • Some elementary techniques • Master theorem QuickSort • The sorting problem • InsertionSort • Analysis of InsertionSort • QuickSort • Analysis of QuickSort The Sorting Problem • Sorting • E.g., sort all the students according to their GPA • Assumptions for analysis of sorting • What to sort? • Problem size n: elements a1,a2,…,an with no identical keys • In which order to sort? • Sort in increasing order • What are the inputs likely to be? • Each possible input appears with the same probability Comparison-based Sorting • Sorting a number of keys • The class of “algorithms that sort by comparison of keys” • Critical operation • Comparison between two keys • No other operations are allowed for sorting • Amount of work done • The number of critical operations (key comparisons) As Simple as Inserting Initial Status Ongoing Final Status ……………. ……………. Sorted Unsorted The “vacancy”, to be shifted leftward, by comparisons Sorted Unsorted (empty) Shifting Vacancy • int shiftVac(element[] E, int vacant, key x) • Precondition: vacant is nonnegative • Postconditions: Let xLoc be the value returned to the caller, then: • Elements in E at indexes less than xLoc are in their original positions and have keys less than or equal to x. • Elements in E at positions (xLoc+1, …, vacant) are greater than x and were shifted up by one position from their positions when shiftVac was invoked. Shifting Vacancy: Recursion int shiftVacRec(Element[] E, int vacant, key x) int xLoc; 1. if(vacant == 0) 2. xLoc = vacant; 3. else if (E[vacant - 1].key ≤ x) 4. xLoc = vacant; 5. else 6. E[vacant] = E[vacant - 1]; 7. xLoc = shiftVacRec(E, vacant - 1, x); 8. return xLoc; The recursive call is working on a smaller range, so terminating; The second argument is non- negative, so precondition holding Worse case frame stack size is O(n) Shifting Vacancy: Iteration int shiftVac(Element[] E, int xindex, key x) int vacant, xLoc; vacant = xindex; xLoc = 0; //Assume failure while(vacant > 0) if(E[vacant - 1].key ≤ x) xLoc = vacant; //Succeed break; E[vacant] = E[vacant - 1]; vacant -= 1; //Keep looking return xLoc; InsertionSort: the Algorithm • Input: E(array), n ≥ 0(size of E) • Output: E, ordered non-decreasingly by keys • Procedure: void InsertionSort(Element[] E, int n) int xindex; for(xindex = 1; xindex < n; xindex ++){ element current = E[xindex]; Key x = current.key; int xLoc = shiftVac(E, xindex, x); E[xLoc] = current; return; Worst-Case Analysis • At the beginning, there are n-1 entries in the unsorted segment, so: ……………. To ﬁnd the right position for x in the sorted segment, i comparisons must be done in the worst case. Sorted (i entries) …… W(n) ≤ n−1 ∑ i=1 i = n(n − 1) 2 The input for which the upper bound is reached does exist, so: W(n) = Θ(n 2 ) Average-Case Behavior • Assumptions: • All permutations of the keys are equally likely as input. • There are not diﬀerent entries with the same keys. ……………. x may be located in any one of the i+1 intervals (inclusive), assuming with the same probability Sorted (i entries) …… Note: For the i-th and (I+1)-th intervals (leftmost), only one comparisons is needed. Average Complexity • The expected number of comparisons in shiftVac to ﬁnd the location for the (i+1)-th element: • For all n-1 insertions: 1 i + 1 i ∑ j=1 j + 1 i + 1 (i) = i 2 + i i + 1 = i 2 + 1 − 1 i + 1 A(n) = n−1 ∑ i=1 ( i 2 + 1 − 1 i + 1 ) = n(n − 1) 4 + n − 1 − n ∑ j=2 1 i = n(n − 1) 4 + n − n ∑ j=1 1 j = n 2 4 + 3n 4 − ln n ∈ Θ(n 2 ) Inversion and Sorting • An unsorted sequence E: • {x 1 , x 2 , x 3 ,…, x n-1 , x n } = {1, 2, 3,…,n-1, n} • <x i , x j > is an inversion if x i > x j , but i < j • Sorting ≡ Eliminating inversions • All the inversions must be eliminated during the process of sorting Eliminating Inverses: Worst Case • Local comparison is done between two adjacent elements • At most one inversion is removed by a local comparison • There do exist inputs with n(n-1)/2 inversions, such as (n, n-1, …, 3, 2, 1) • The worst-case behavior of any sorting algorithm that remove at most one inversion per key comparison must in Ω(n 2 ) Eliminating Inversions: Average Case • Computing the average number of inversions in inputs of size n (n > 1): • Transpose: x 1 , x 2 , x 3 ,…, x n-1 , x n => x n ,x n-1 , …x 3 , x 2 , x 1 • For any i, j, (1≤j≤i≤n), the inversion (x i , x j ) is in exactly one sequence in a transpose pair. • The number of inversions (x i , x j ) on n distinct integers is n(n-1)/2. • So, the average number of inversions in all possible inputs is n(n-1)/4, since exactly n(n-1)/2 inversions appear in each transpose pair. • The average behavior of any sorting algorithm that remove at most one inversion per key comparison must in Ω(n 2 ). QuickSort: the Strategy • Divide the array to be sorted into two parts: “small” and “large”, which will be sorted recursively. …………….…… [ﬁrst] [last] [splitPoint]: pivot small large for any element in this segment, the key is less than pivot. for any element in this segment, the key is not less than pivot. To be sorted recursively QuickSort: the Strategy • Divide • “small” and “large” • Conquer • Sort “small” and “large” recursively • Combine • Easily combine sorted sub-array ……………. …… [ﬁrst] [last] [splitPoint]: pivot small large Hard divide, easy combination QuickSort: the Algorithm • Input: Array E, indexes ﬁrst, and last, such that elements E[i] are deﬁned for ﬁrst≤i≤last. • Output: E[ﬁrst], …, E[last] is a sorted rearrangement of the same elements. • The procedure: void quickSort(Element[] E, int ﬁrst, int last) if(ﬁrst < last) Element pivotElement = E[ﬁrst]; Key pivot = pivotElement.key; int splitPoint = partition(E, pivot, ﬁrst, last); E[splitPoint] = pivotElement; quickSort(E, ﬁrst, splitPoint - 1); quickSort(E, splitPoint - 1, last); return; The splitting point is chosen arbitrarily, as the ﬁrst element in the array segment here. Partition: the Strategy ……………. Expanding Directions “Small” segment Unexamined segment “Large” segment Partition: the Process • Always keep a vacancy before completion ……………. ……………. highVac Vacancy at the beginning, the key as pivot Moving as far as possible! ……………. lowVac Vacant left after moving First met key that is lees than pivot First met key that is lees than pivot Partition: the Algorithm • Input: Array E, pivot, the key around which to partition, and indexes ﬁrst, and last, such that elements E[i] are deﬁned for ﬁrst+1≤i≤last and E[ﬁrst] is vacant. It is assumed that ﬁrst<last. • Output: Returning splitPoint, the elements originally in ﬁrst+1, …, last are rearranged into two subranges, such that • the keys of E[ﬁrst], …, E[splitPoint - 1] are less than pivot, and • the keys of E[splitPoint + 1], …, E[last] are not less than pivot, and • ﬁrst≤splitPoint≤last, and E[splitPoint] is vacant. Partition: the Procedure int partition(Element[ ] E, Key pivot, int ﬁrst, int last) int low, high; 1. low = ﬁrst; high = last; 2. while(low < high){ 3. int highVac = 4. extendLargeRegion(E, pivot, low, high); 5. int lowVac = 6. extendSmallRegion(E, pivot, low + 1, highVac); 7. low = lowVac; high = highVac - 1; 8. } 9. return low; // this is the splitPoint highVac has been ﬁlled now Extending Regions • Speciﬁcation for • Precondition: • lowVac < high • Postcondition: • if there are elements in E[lowVac + 1], …, E[high] whose key is less than pivot, then the rightmost of them is moved to E[lowVac], and its original index is returned. • If there is no such element, lowVac is returned; extendLargeRegion(Element[ ] E, Key pivot, int lowVac, int high) An Example 45 14 62 51 75 96 33 84 20 20 14 62 51 75 96 33 84 20 20 14 62 51 75 96 33 84 62 20 14 62 51 75 96 33 84 62 20 14 33 51 75 96 33 84 62 20 14 33 51 75 96 51 84 20 45 as pivot high highVac low lowVac low highVac highVac lowVac high = highVac - 1 To be processed in the next loop Worst Case: a Paradox • For a range of k positions, k-1 keys are compared with the pivot (one is vacant). • If the pivot is the smallest, then the “large” segment has all the remaining k-1 elements, and the “small” segment is empty. • If the elements in the array to be sorted has already in ascending order (the Goal), then the number of comparison that Partition has to do is: n ∑ k=2 (k − 1) = n(n − 1) 2 ∈ O(n 2 ) Average-case Analysis • Assumption: all permutation of the keys are equally likely. • A(n) is the average number of key comparisons done for range of size n. • In the ﬁrst cycle of Partition, n-1 comparisons are done. • If split point is E[i] (each i has probability 1/n), Partition is to be executed recursively on the subrange [0, …, i-1] and [i+1, …, n-1] The Recurrence Equation …………….…… E[0] E[n-1] [splitPoint]: E[i] subrange 1: size = i subrange 2: size = n-1-i with i∈{0, 1, 2,…, n-1}, each value with the probability 1/n the average number of key comparison A(n) is: A(n) = (n − 1) + n−1 ∑ i=0 1 n [A(i) + A(n − 1 − i)] for n ≥ 2 A(1)=A(0)=0 The number of key comparison in the ﬁrst cycle (ﬁnding the splitPoint) is n-1 why the assumed probability still holds for each subrange? Simpliﬁed Recurrence Equation • Note: • So: • Two approaches to solve the equation • Guess, and prove by induction • Solve directly n−1 ∑ i=0 A(i) = n−1 ∑ i=0 A[(n − 1) − i] A(0) = 0 A(n) = (n − 1) + 2 n n−1 ∑ i=1 A(i) for n ≥ 1 Guess the Solution • A special case as the clue for a smart guess • Assuming that Partition divide the problem range into 2 subranges of about the same size. • So, the number of comparison Q(n) satisfy: • Applying Master Theorem, cases: Q(n) ≈ n + 2Q(n/2) Q(n) ∈ Θ(n log n) Note: here, b=c=2, so E=log(b)/log(c)=1, and, f(n)=n E =n Inductive Proof: A(n)∈O(nlnn) • Theorem: A(n)≤cnlnn for some constant c, with A(n) deﬁned by the recurrence equation above. • Proof: • By induction on n, the number of elements to be sorted. Base case (n=1) is trivial. • Inductive assumption: for 1≤i<n A(n) = (n − 1) + 2 n n−1 ∑ i=1 A(i) ≤ (n − 1) + 2 n n−1 ∑ i=1 ci ln i 2 n n−1 ∑ i=1 ci ln i ≤ 2c n ∫ n 1 x ln xdx ≈ 2c n ( n 2 ln n 2 − n 2 4 ) = cn ln n − cn 2 A(n) ≤ cn ln n + n ( 1 − c 2 ) − 1 Note: So, Let c = 2, we have A(n) ≤ 2n ln n A(i) ≤ ci ln i For Your Reference ∫ n 1 x k ln xdx = ( x k+1 ln x k + 1 − x k+1 (k + 1) 2 ) n 1 = n k+1 ln n k + 1 − n k+1 (k + 1) 2 + 1 (k + 1) 2 ∫ b a−1 f(x)dx ≤ b ∑ i=a f(i) ≤ ∫ b+1 a f(x)dx a b n ∑ i=1 1 i ≈ ln n + 0.577 Harmonic Series Inductive Proof: A(n)∈Ω(nlnn) • Theorem: A(n)≥cnlnn for some constant c, with large n • Inductive reasoning: A(n) = (n − 1) + 2 n n−1 ∑ i=1 A(i) ≥ (n − 1) + 2 n n−1 ∑ i=1 ci ln i = (n − 1) + 2c n n ∑ i=2 i ln i − 2c ln n ≥ (n − 1) + 2c n ∫ n 1 x ln xdx − 2c ln n ≈ cn ln n + [(n − 1) − c( n 2 + 2 ln n)] c < n − 1 n 2 + 2 ln n A(n) > cn ln n lim n→∞ n − 1 n 2 + 2 ln n = 2 Let , then (Note: ) Directly Derived Recurrence Equation nA(n) − (n − 1)A(n − 1) A(n) = (n − 1) + 2 n n−1 ∑ i=1 A(i) A(n − 1) = (n − 2) + 2 n − 1 n−2 ∑ i=1 A(i) We have and Combining the 2 equations in some way, we can remove all A(i) for i=1, 2, …, n-2 nA(n) = (n + 1)A(n − 1) + 2(n − 1) = n(n − 1) + 2 n−1 ∑ i=1 A(i) − (n − 1)(n − 2) − 2 n−2 ∑ i=1 A(i) = 2A(n − 1) + 2(n − 1) So, Solve the Equation • We have: • Thus: • Finally we get • nA(n) = (n + 1)A(n − 1) + 2(n − 1) A(n) n + 1 = A(n − 1) n + 2(n − 1) n(n + 1) B(n) = B(n − 1) + 2(n − 1) n(n + 1)B(n) = O(log n) B(1) = 0 A(n) = O(n log n) Space Complexity • Good news: • Partition is in-place • Bad news: • In the worst case, the depth of recursion will be n-1 • So, the largest size of the recursion stack will be in Θ(n) More than Sorting • QuickSort Partition • O(n) • Bolts and nuts • O(nlogn) • k-Sorted • O(nlogk) Thank you! Q & A","libVersion":"0.2.4","langs":""}