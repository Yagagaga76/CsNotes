{"path":"pdf/课件/L12 - DAG.pdf","text":"Introduction to Algorithm Design and Analysis [12] Directed Acyclic Graph Jingwei Xu https://cs.nju.edu.cn/ics/people/jingweixu/ index.html Institute of Computer Software Nanjing University 期中考试时间：4⽉24⽇ 下午2点-4点 考试地点：仙I-109 In the last class … • Depth-ﬁrst and breadth-ﬁrst search • Finding connected components • General DFS/BFS skeleton • Depth-ﬁrst search trace Applications of Graph Decomposition • Directed Acyclic Graph • Topological order • Critical path analysis • Strongly Connected Component (SCC) • Strong connected component and condensation • The algorithm • Leader of strong connected component For Your Reference Directed Acyclic Graph (DAG) 1 4 2 6 3 8 7 9 5 1 4 2 6 3 8 7 9 5 A Directed Acyclic Graph Not a DAG Topological Order for G=(V, E) • Topological number • An assignment of distinct integer 1,2,…,n to the vertices of V • For every vw∈E, the topological number of v is less than that of w. • Reverse topological order • Deﬁned similarly (“greater than”) 1 4 2 6 3 8 7 9 5 7 8 2 4 5 6 1 9 3 Existence of Topological Order - a Negative Result • If a directed graph G has a cycle, then G has no topological order • Proof • [By contradiction] 1 4 2 6 3 8 7 9 5 x y For any given topological order, all the vertices on both paths must be in increasing order. Contradiction results for any assignments for x and y. yx-path xy-path Reverse Topological Ordering • Specialized parameters • Array topo, keeps the topological number assigned to each vertex. • Counter topoNum to provide the integer to be used for topological number assignments • Output • Array topo as ﬁlled. Reverse Topological Ordering • void dfsTopoSweep(intList[] adjVertices, int n, int[] topo) • int topoNum=0; • <Allocate color array and initialize to white> • for each vertex v of G, in some order • if(color[v]==white) • dfsTopo(adjVertices, color, v, topo, topoNum); • //continue loop • return; For non-reverse topological ordering, initialized as n+1 Reverse Topological Ordering • int dfsTopo(intList[] adjVertices, int[] color, int v, int[] topo, int topoNum) • int w; intList remAdj; color[v]=gray; • remAdj=adjVertices[v]; • while(remAdj != nil) • w=ﬁrst(remAdj); • if(color[w]==white) • dfsTopo(adjVertices, color, w, topo, topoNum); • remAdj=rest(remAdj); • topoNum++; topo[v]=topoNum; • color[v]=black; • return; Obviously, in Θ(m+n) Filling topo is a post-order processing, so, the earlier discovered vertex has relatively greater top number Reverse Topological Ordering • For an “end node” • Easy to decide • Acyclic • There is always an end • Everyone becomes an end B D c A structural end structural end structural end … logical end (when B, C, D ﬁnished) Correctness of the Algorithm • If G is a DAG with n vertices, the procedure dfsTopoSweep computes a reverse topological order for G in the array topo. • Proof • The procedure dfsTopo is called exactly once for a vertex, so, the numbers in topo must be distinct in the range 1,2,...n. • For any edge vw, vw can’t be a back edge (otherwise, a cycle is formed). For any other edge types, we have ﬁnishTime(v)>ﬁnishTime(w), so, topo(w) is assigned earlier than topo(v). Note that topoNum is incremented monotonically, so, topo(v)>topo(w). Existence of Topological Order • In fact, the proof of correctness of topological ordering has proved that: DAG always has a topological order. • So, G has a topological ordering, iff. G is a directed acyclic graph. Task Scheduling • Problem: • Scheduling a project consisting of a set of interdependent tasks to be done by one person. • Solution: • Establishing a dependency graph, the vertices are tasks, and edge vw is included iﬀ. the execution of v depends on the completion of w, • Making task scheduling according to the topological order of the graph (if existing). Task Scheduling: an Example Project Optimization Problem • Observation • In a critical path, v i-1 , is a critical dependency of v i , i.e., any delay in v i-1 will result in delay in v i . • The time for entire project depends on the time for the critical path. • Reducing the time of an oﬀ-critical-path task is of no help for reducing the total time for the project. • The Problems • Find the critical path in a DAG • (Try to reduce the time for the critical path) Assuming that parallel executions of tasks (v i ) are possible except for prohibited by interdependency. This is a precondition. Critical Path in a Task Graph • Earliest start time (est) for a task v • If v has no dependencies, the est is 0 • I v has dependencies, the est is the maximum of the earliest ﬁnish time of its dependencies. • Earliest ﬁnish time (eft) for a task v • For any task: eft = est + duration • Critical path in a project is a sequence of tasks: v 0 , v 1 , …, v k , satisfying: • v 0 has no dependencies; • For any v i =(i=1,2,…,k), v i-1 is a dependency of v i , such that est of v i equals eft of v i-1 ; • eft of v k , is maximum for all tasks in the project. DAG with Weights 1 4 2 6 3 8 7 9 5 toast:2 choose:3 dress:6.5 eat:6 leave:1 coﬀee:4.5 wake:0 shower:8.5 juice:0.5 1 4 2 6 3 8 7 9 5 0 0 0 0 0 3 8.5 4.5 2 0.5 6.0 6.5 1 Done Critical Path Critical Subpath Critical Path Finding - DFS • Specialized parameters • Array duration, keeps the execution time of each vertex. • Array critDep, keeps the critical dependency of each vertex. • Array eft, keeps the earliest ﬁnished time of each vertex. • Output • Array topo, critDep, eft as ﬁlled. • Critical path is built by tracing the output. Critical Path - Case 1Critical Path - Case 2 Critical Path by DFS • void dfsCritSweep(intList[] adjVertices, int n, int[] duration, int[] critDep, int[] eft) • <Allocate color array and initialize to white> • for each vertex v of G, in some order • if(color[v]==white) • dfsCrit(adjVertices, color, v, duration, critDep, eft); • //continue loop • return; Critical Path by DFS • int dfsCrit(intList[] adjVertices, int[] color, int v, int[] duration int[] critDep, int eft) • int w; intList remAdj; int est=0; • color[v]=gray; critDep[v]=-1; remAdj=adjVertices[v]; • while(remAdj != nil) w=ﬁrst(remAdj); • if(color[w]==white) • dfsCrit(adjVertices, color, w, duration, critDep, eft); • if (eft[w]≥est) est=eft[w]; critDep[v]=w; • else//checking for nontree edge • if (eft[w]≥est) est=eft[w]; critDep[v]=w; • remAdj=rest(remAdj); • eft[v]=est+duration[v]; color[v]=black; • return; When is the eft[w] initialized? Only black vertex Analysis of Critical Path Algorithm • Correctness: • When eft[w] is accessed in the while-loop, the w must not be gray(otherwise, there is a cycle), so, it must be black, with eft initialized. • According to DFS, each entry in the eft array is assigned a value exactly once. The value satisﬁes the deﬁnition of eft. • Complexity • Simply same as DFS, that is Θ(n+m). SCC: Strongly Connected Component Transpose Graph Basic Idea - G Original edge Basic Idea - G T SCC - An Example Strong Component Algorithm: Outline • void strongComponents(intList[] adjvertices, int n, int[] scc) • //Phase 1 • 1. intStack ﬁnishStack=create(n); • 2. perform a depth-ﬁrst search on G, using the DFS skeleton. At postorder processing for vertex v, insert the statement: push(ﬁnishStack, v) • //Phase 2 • 3. Compute G T , the transpose graph, represented as array adjTrans of adjacency list. • 4. dfsTsweep(adjTrans, n, ﬁnishStack, scc); • return Note: G and G T have the same SCC sets Strong Component Algorithm: Core • void dfsTSweep(intList[] adjVertices, int n, intStack ﬁnishStack, int[] scc) • <Allocate color array and initialize to white> • while(ﬁnishStack is not empty) • int v=top(ﬁnishStack); • pop(ﬁnishStack); • if(color[v]==white) • dfsT(adjVertices, color, v, v, scc); • return; • void dfsT(intList[] adjTrans, int[] color, int v, int leader, int[] scc) • Use the standard depth-ﬁrst search skeleton. At postorder processing for vertex v insert the statement: • scc[v]=leader; • Pass leader and scc into recursive calls. Leader of a Strong Component • For a DFS, the ﬁrst vertex discovered in a strong component S i is called the leader of S i . • Each DFS tree of a digraph G contains only complete strong components of G, one or more. • Proof: Applying White Path Theorem whenever the leader of S i (i=1,2,...p) is discovered, starting with all vertices being white. • The leader of S i is the last vertex to ﬁnish among all vertices of S i . (since all of them in the same DFS tree) Path between SCCs C 1 : The End CaseC 2 : The White CaseC 2 : The Black Case Active Intervals • If there is an edge from S i to S j , then it is impossible that the active interval of v j is entirely after that of v i . (Note: for leader v i only) • Th ere is no path from a leader of a strong component to any gray vertex. • If there is a path from the leader v of a strong component to any x in a diﬀerent strong component, v ﬁnishes later than x. Correctness of Strong Component Algorithm (1) • In phase 2, each time a white vertex is popped from finishStack, that vertex is the Phase 1 leader of a strong component. • The later ﬁnished, the earlier popped • The leader is the ﬁrst to get popped in the strong component it belongs to • If x popped is not a leader, then some other vertex in the strong component has been visited previously. But not a partial strong component can be in a DFS tree, so, x must be in a completed DFS tree, and is not white. Correctness of Strong Component Algorithm (2) • In phase 2, each depth-ﬁrst search tree contains exactly one strong component of vertices • Only “exactly one” need to be proved • Assume that v i , a phase 1 leader is popped. If another component S j is reachable from v i in G T , there is a path in G from v j to v i . So, in phase 1, v j ﬁnished later than v i , and popped earlier than v i in phase 2. So, when v i popped, all vertices in S j are black. So, S j are not contained in DFS tree containing v i (S i ). Thank you! Q & A","libVersion":"0.2.4","langs":""}