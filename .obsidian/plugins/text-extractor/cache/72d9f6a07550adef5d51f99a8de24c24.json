{"path":"pdf/算法设计与分析/L6 - MergeSort.pdf","text":"Introduction to Algorithm Design and Analysis [06] MergeSort Jingwei Xu http://cs.nju.edu.cn/ics/people/jingweixu Institute of Computer Software Nanjing University In the last class … • Heap • Partial order property • FixHeap • ConstructHeap • Heap structure • Array-based implementation • HeapSort • Complexity • Accelerated HeapSort MergeSort • MergeSort • Worst-case analysis of MergeSort • Lower Bounds for comparison-based sorting • Worst-case • Average-case MergeSort: the Strategy • Easy division • No comparison is conducted during the division • Minimizing the size diﬀerence between the divided subproblems • Merging two sorted subranges • Using Merge Merging Sorted Arrays compare A[0] A[i] A[k-1] B[0] B[j] B[m-1] … … … … … … … … … … … … Merge: the Speciﬁcation • Input • Array A with k elements and B with m elements, whose keys are in non-decreasing order • Output • Array C containing n=k+m elements from A and B in non-decreasing order • C is passed in and the algorithm ﬁlls it Merge: Recursive Version merge(A,B,C) if (A is empty) rest of C = rest of B else if (B is empty) rest of C = rest of A else if (ﬁrst of A ≤ ﬁrst of B) ﬁrst of C = ﬁrst of A merge(rest of A, B, rest of C) else ﬁrst of C = ﬁrst of B merge(A, rest of B, rest of C) return Base cases Worst Case Complexity of Merge • Observations • Worst case is that the last comparison is conducted between A[k-1] and B[m-1] • After each comparison, at least one element is inserted into Array C, at least. • After entering Array C, an element will never be compared again. • After the last comparison, at least two elements have not yet been moved to Array C. So at most n-1 comparisons are done. • In worst case, n-1 comparisons are done, where n=k+m Optimality of Merge • Any algorithm to merge two sorted arrays, each containing k=m=n/2 entries, by comparison of keys, does at least n-1 comparisons in the worst case. • Choose keys so that: b 0 <a 0 <b 1 < a 1 <...<b i <a i <b i+1 ,...,<b m-1 <a k-1 • Then the algorithm must compare a i with b i for every i in [0, m-1], and must compare a i with b i+1 for every i in [0, m-2], so, there are n-1 comparisons. Valid for |k-m| ≤ 1, as well. Space Complexity of Merge • An algorithm is “in space” • If the extra space it has to use is in Θ(1) • Merge is not a algorithm “in space” • Since it needs O(n) extra space to store the merged sequence during the merging process. Overlapping Arrays for Merge Before the merge 0 k-1 k+m-1 0 B m-1 extra space Before the merge 0 k-1 k+m-1 0 m-1 Merge from the right Merged 0 k-1 k+m-1 0 m-1Finished A MergeSort • Input: Array E and indexes ﬁrst, and last, such that the elements of E[i] are deﬁned for ﬁrst≤i≤last. • Output: E[ﬁrst],…,E[last] is a sorted rearrangement of the same elements. • Procedure void mergeSort(Element[] E, int ﬁrst, int last) if (ﬁrst < last) int mid = (ﬁrst+last) / 2; mergeSort(E, ﬁrst, mid); mergeSort(E, mid + 1, last); merge(E, ﬁrst, mid, last); return; Analysis of MergeSort • The recurrence equation for MergeSort Where n = last - ﬁrst + 1, the size of range to be sorted • The Master Theorem applies for the equation, so: W(n) = W(⌊n/2⌋) + W(⌈n/2⌉) + n − 1 W(1) = 0 W(n) ∈ Θ(n log n) Recursion Tree for MergeSort Base cases occur at depth lg(n+1)-1 and lg(n+1) n-1 Level 0 n-2 Level 1 n-4 Level 2 n-8 Level 3 Note: non recursive costs on level k is n-2 k for all level without base case node. T(n) n-1 T(n/2) n/2-1 T(n/4) n/4-1 T(n/8) n/8-1 Non-complete Recursion Tree Example: n=11 2 D-1 nodes Since each nonbase-case node has 2 children, there are (n-B)/2 nonbase-case nodes at depth D-1 n-B base-case nodes No nonbase-case nodes at this depth B base-case nodes on the second lowest level Number of Comparison of MergeSort • The maximum depth D of the recursive tree is lg(n+1). • Let B base case nodes on depth D-1, and n-B on depth D, (Note: base case node has non-recursive cost 0). • (n-B)/2 non-base case nodes at depth D-1, each has non-recursive cost 1. • So: • nlg(n)-n+1 ≤ number of comparison ≤ nlg(n)-0.914n 1)l g(l g)(, l gl g,21,1 2 12)(, 2,)22( 2 )12()1( 2 )2()( 2 0 1 +−−= +=<≤=+= +−= −==+− − +−−−= − +−= ∑ − = − nnnnWS o nDt h e n n B n L e t n DnWS o nBi st h a tnBBS i n c e Bn Dn Bn nnW D D DD D d Dd αα ααα The MergeSort D&C • Counting the number of inversions • Brute force: O(n 2 ) • Can we use divide & conquer • In O(nlogn)=>combination in O(n) • MergeSort as the carrier • Sorted subarrays • A[0..k-1] and B[0..m-1] • Compare the left and right elements • A[i] v.s. B[j] The MergeSort D&C compare A[0] A[i] A[k-1] B[0] B[j] B[m-1] … … … … … … … … if A[i]>B[j] (i,j) is an inversion All (i’,j) are inversions (i’>i) B[j] is selected if A[i]<B[j] No inversion found A[i] is selected The MergeSort D&C • Max-sum subsequence • Maxima on a plane • Finding the frequent element • Integer/matrix multiplication • … Just evenly divide Linear-time combination T(n)=2T(n/2)+O(n) T(n)∈O(nlogn) Lower Bounds for Comparison-based Sorting • Upper bound, e.g., worst-case cost • For any possible input, the cost of the speciﬁc algorithm A is no more than the upper bound • Max{cost(i) | i is an input} • Lower bound, e.g., comparison-based sorting • For any possible (comparison-based) sorting algorithm A, the worst-case cost is no less than the lower bound • Min{worst-case(a) | a is an algorithm} 2-Tree • 2-Tree • Common Binary Tree internal nodes external nodes no child any type Both left and right children of these nodes are empty tree Decision Tree for Sorting An example for n=3 • Decision tree is a 2-tree (Assuming no same keys) • The action of Sort on a particular input corresponds to following on path in its decision tree from the root to a leaf associated to the speciﬁc output 2 : 3 1 : 3 2 : 3 1 : 2 1 : 3 x 1 , x 2 , x 3 x 2 , x 1 , x 3 x 1 , x 3 , x 2 x 3 , x 1 , x 2 x 2 , x 3 , x 1 x 3 , x 2 , x 1 Internal node External node Characterizing the Decision Tree • For a sequence of n distinct elements, there are n! different permutation • So, the decision tree has at least n! leaves, and exactly n! leaves can be reached from the root. • So, for the purpose of lower bounds evaluation, we use trees with exactly n! leaves. • The number of comparison done in the worst case is the height of the tree. • The average number of comparison done is the average of the lengths of all paths from the root to a leaf. Lower Bound for Worst Case • Theorem: Any algorithm to sort n items by comparisons of keys must do at least lgn!, or approximately nlgn-1.443n, key comparisons in the worst case. • Note: Let L=n!, which is the number of leaves, then L≤2 h , where h is the height of the tree, that is h≥ lgL=lgn! • For the asymptotic behavior: derived using: )l g( 2 l g 22 l g] 2 ) . . .1(l g [)!l g ( 2 nn nnnn nnn n Θ∈ ⎟ ⎠ ⎞ ⎜ ⎝ ⎛ = ⎟ ⎠ ⎞ ⎜ ⎝ ⎛ ≥ ⎟ ⎟ ⎠ ⎞ ⎜ ⎜ ⎝ ⎛ ⎥ ⎥ ⎤ ⎢ ⎢ ⎡ −≥ ∑ = = n j jn 1 )l g (!l g External Path Length (EPL) • The EPL of a 2-tree t is deﬁned as follows: • [Base case] 0 for a single external node • [Recursion] t is non-leaf with sub-trees L and R, then the sum of: • the external path length of L; • the number of external node of L; • the external path length of R; • the number of external node of R; More Balanced 2-tree, Less EPL X Y X Y level k level h - 1 level h level k +1 Guess and prove: More Balanced 2-tree, Less EPL Assuming that h-k>1, when calculating epl, h+h+k is replaced by (h-1)+2(k+1). The net change in epl is k-h+1<0, that is, the epl decreases. So, more balanced 2-tree has smaller epl. X Y X Y level k level h - 1 level h level k +1 Guess and prove: Properties of EPL • Let t is a 2-tree, then the epl of t is the sum of the paths from the root to each external node. • epl ≥mlg(m), where m is the number of external nodes in t • epl=epl L +epl R +m≥ m L lg(m L )+m R lg(m R )+m, • note f(x)+f(y)≥2f((x+y)/2) for f(x)=xlgx • so, epl ≥ 2((m L +m R )/2)lg((m L +m R )/2)+m = m(lg(m)-1)+m =mlgm. Lower Bound for Average Behavior • Since a decision tree with L leaves is a 2-tree, the average path length from the root to a leaf is • Recall that epl ≥ Llg(L). • Theorem: The average number of comparison done by an algorithm to sort n items by comparison of keys is at least lg(n!), which is about nlgn-1.443n. L e p l MergeSort Has Optimal Average Performance • The average number of comparisons done by an algorithm to sort n items by comparison of keys is at least about nlgn-1.443n • The worst complexity of MergeSort is in Θ(nlgn) • But, the average performance can not be worse than the worst case performance. • So, MergeSort is optimal as for its average performance. Thank you! Q & A","libVersion":"0.2.4","langs":""}