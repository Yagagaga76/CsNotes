{"path":"pdf/课件/L5 - HeapSort.pdf","text":"Introduction to Algorithm Design and Analysis [05] HeapSort Jingwei Xu http://cs.nju.edu.cn/ics/people/jingweixu Institute of Computer Software Nanjing University In the last class … • The sorting problem • Assumptions • InsertionSort • Design • Analysis: inverse • QuickSort • Design • Analysis HeapSort • Heap • HeapSort • FixHeap • ConstructHeap • Complexity of HeapSort • Accelerated HeapSort How HeapSort Works Priority Queue Elements to be sorted Elements sorted Heap Fibonacci Heap Binomial Heap Implementations Elementary Priority Queue ADT • “FIFO” in some special sense. The “ﬁrst” means some kind of “priority”, such as value (largest or smallest) • PriorityQ create() • Precondition: none • Postconditions: If pq=create(), then, pq refers to a newly created object and isEmpty(pt)=true • boolean isEmpty(PriorityQ pq) • precondition: none • int getMax(PriorityQ pq) • precondition: isEmpty(pq)=false • postconditions: ** • void insert(PriorityQ pq, int id, ﬂoat w) • preconditions: none • postconditions: isEmpty(pq)=false; ** • void delete(PriorityQ pq) • precondition: isEmpty(pq)=false • postconditions: value of isEmpty(pq) updated; ** • void increaseKey(PriorityQ pq, int id, ﬂoat newKey) **pq can always be thought as a sequence of pairs (id i , w i ), in non-decreasing order of w i Heap: an Implementation of Priority Queue • A binary tree T is a heap structure if: • T is complete at least though depth h-1 • All leaves are at depth h or h-1 • All paths to a leaf of depth h are to the left of all paths to a leaf of depth h-1 • Partial order tree property • A tree T is a (maximizing) partial order tree if and only if the key at any node is greater than or equal to the keys at each of its children (if it has any). Heap: Examples 9 5 7 1 4 3 6 50 24 30 20 21 18 3 12 5 6 The maximal key is always with the root Heap: an Implementation of Priority Queue Heap Heap structure Partial order property HeapSort: the Strategy heapSort(E, n) Construct H from E, the set of n elements to be sorted; for (i = n; i ≥ 1; i -=1){ curMax = getMax(H); deleteMax(H); E[i] = curMax; } deleteMax(H) copy the rightmost element on the lowest level of H into K; Delete the rightmost element on the lowest level of H; ﬁxHeap(H, K); FixHeap • Input: A nonempty binary tree H with a “vacant” root and its two subtrees in partial order. An element K to be inserted. • Output: H with K inserted and satisfying the partial order tree property. • Procedure: ﬁxheap(H, K) if(H is a leaf) insert K in root(H); else set largerSubHeap; if(K.key≥root(largerSubHeap).key) insert K in root(H); else insert root(largerSubHeap) in root(H); ﬁxHeap(largerSubHeap, K); return; One comparison: largerSubHeap is left- or right- Subtree(H), the one with larger key at its root. Special case: rightSubtree is empty. “Vacant” moving down FixHeap: an Example 50 24 30 20 21 18 3 12 5 6 24 30 20 21 18 3 12 5 Vacant K=6 30 24 20 21 18 3 12 5 K=6 30 24 18 20 21 3 12 5 K=6 Worst Case Analysis for ﬁxHeap • 2 comparisons at most in one activation of the procedure • The tree height decreases by one in the recursive call • So, 2h comparisons are needed in the worst case, where h is the height of the tree • Procedure: ﬁxheap(H, K) if(H is a leaf) insert K in root(H); else set largerSubHeap; if(K.key≥root(largerSubHeap).key) insert K in root(H); else insert root(largerSubHeap) in root(H); ﬁxHeap(largerSubHeap, K); return; One comparison: largerSubHeap is left- or right- Subtree(H), the one with larger key at its root. Special case: rightSubtree is empty. “Vacant” moving down recursion Heap Construction • Note: if left subtree and right subtree both satisfy the partial order tree property, then ﬁxHeap(H, root(H)) gets the thing done. • We begin from a Heap Structure H: void constructHeap(H) if(H is not a leaf) constructHeap(left subtree of H); constructHeap(right subtree of H); Element K = root(H); ﬁxHeap(H, K); return; root Post-order Traversal left right Correctness of constructHeap • Speciﬁcation • Input: A heap structure H, not necessarily having the partial order tree property. • Output: H with the same nodes rearranged to satisfy the partial order tree property. void constructHeap(H) if(H is not a leaf) constructHeap(left subtree of H); constructHeap(right subtree of H); Element K = root(H); ﬁxHeap(H, K); return; H is a leaf: base case, satisﬁed trivially. Preconditions hold respectively? Postcondition of constructHeap satisﬁed? Linear Time Heap Construction! • The recursion equation: • A special case: H is a complete binary tree: • The size N=2 d -1, • Note: • The Master Theorem applies, with b=c=2, and the critical exponent E=1, • Note: • When 0<ε<1, this limit is equal to zero • So, , case 1 satisﬁed, we have W(n) = W(n − r − 1) + W(r) + 2 log n W(N) = 2W((N − 1)/2) + 2 log N f(N) = 2 log N lim N→∞ 2 log N N 1−ϵ = lim N→∞ 2 log N N 1−ϵ log 2 = lim N→∞ 2N ϵ ((1 − ϵ)log 2)N 2 log N ∈ O(N E−ϵ ) W(n) ∈ Θ(N) (then, for arbitrary n, N/2<n<N≤2n, so W(n)≤W(N)≤W(2n)) Direct Analysis of Heap construction • Heap construction • From recursion to iteration • Sum of row sums cost = ⌊log n⌋ ∑ h=0 n O(h) 2 h+1 = O(n) c = logn ﬁx; h = logn; # = 1 c = 2 ﬁx; h = 2; # = n/8 c = 1 ﬁx; h = 1; # = n/4 c = 0 ﬁx; h = 0; # = n/2 1 ﬁx = 2 comparisons Understanding the Heap • Where is the k th element in the heap? • 1 st ? 2 nd ? 3 rd ? • k th ? at what cost? • Sum of heights • At most n-1 • When the sum reaches n-1? Implementing Heap Using Array 9 5 7 1 4 3 6 50 24 30 20 21 18 3 12 5 6 9 5 7 1 4 3 6 50 24 30 20 21 18 3 12 5 6 Looking for the Children Quickly 50 24 30 20 21 18 3 12 5 6 50 24 30 20 21 18 3 12 5 6 Starting from 1, not zero, then the j th level has 2 j-1 elements, and there are 2 j-1 -1 elements in the proceeding j-1 levels altogether. So, if E[i] is the kth element at level j, then i=(2 j-1 -1)+k, and the index of its left child (if existing) is i+(2 j-1 -k)+2(k-1)+1=2i The number of children of the nodes on level j on the left of E[i] The number of node on the right of E[i] on level j HeapSort: In-Space Implementation E[1]: The largest key to be moved to E[n] E[n]->K: removed to be inserted E[1]: The largest key in current heap, to be moved to E[heapsize] E[heapsize]->K: removed to be inserted Current heap: processed by ﬁxHeap Heap implemented as a array (initial) FixHeap: Using Array • void ﬁxHeap(Element[ ] E, int heapSize, int root, Element K) • int left = 2 * root; right = 2 * root + 1; • if(left > heapSize) E[root] = K; // root is a leaf. • else • int largerSubHeap; // right or left to ﬁlter down. • if(left == heapSize) largerSubHeap = left; // no right SubHeap; • else if(E[left].key > E[right].key) largerSubHeap = left; • else largerSubHeap = right; • if(K.key ≥ E[largerSubHeap].key) E[root] = K; • else E[root] = E[largerSubHeap]; // vacant ﬁltering down one level. • ﬁxHeap(E, heapSize, largerSubHeap, K); • return; HeapSort: the Algorithm • Input: E, an unsorted array with n (>0) elements, indexed from 1 • Sorted E, in non-decreasing order • Procedure: void heapSort(Element[ ] E, int n) int heapsize; constructHeap(E, n, root); for(heapsize = n; heapsize ≥ 2; heapsize -= 1) Element curMax = E[1]; Element K = E[heapsize]; ﬁxHeap(E, heapsize - 1, 1, K); E[heapsize] = curMax; return; “array version” Worst Case Analysis of HeapSort • We have: • It has been shown that: • Recall that: • So, W(n) = W cons (n) + n−1 ∑ k=1 W fix (k) W cons (n) ∈ Θ(n) W fix (k) ≤ 2 log k and 2n−1 ∑ k=1 ⌈log k⌉ ≤ 2 ∫ n 1 log e ln xdx = 2 log e(n ln n − n) = 2(n log n − 1.443n) W(n) ≤ 2n log n + Θ(n) , that is W(n) ∈ Θ(n log n) Coeﬃcient doubles that of mergeSort approximately HeapSort: the Right Choice • For heapSort, • Of course, • More good news: HeapSort is an in-space algorithm (using iteration instead of recursion) • It will be more competitive if only the coefﬁcient of the leading term can be decreased to 1 W(n) ∈ Θ(n log n) A(n) ∈ Θ(n log n) Number of Comparisons in ﬁxHeap Procedure: ﬁxHeap(H, K) if(H is a leaf) insert K in root (H); else Set largerSubHeap; if(K.key ≥ root(largerSubHeap).key) insert K in root(H) else insert root(largerSubHeap) in root(H); ﬁxHeap(largerSubHeap, K); return 2 comparisons are done in ﬁltering down for one level. A One-Comparison-per- Level Fixing Bubble-Up Heap Algorithm: void bubbleUpHeap(Element [ ]E, int root, Element K, int vacant) if(vacant == root) E[vacant] = K; else int parent = vacant/2; if(K.key ≤ E[parent].key) E[vacant] = K; else E[vacant] = E[parent]; bubbleUpHeap(E, root, K, parent); return Bubbling up from vacant through to the root, recursively Risky FixHeap 90 80 75 25 45 70 35 60 50 40 15 65 80 25 45 70 35 60 80 65 70 75 25 45 60 35 50 90 65 75 25 45 35 40 15 “Vacant” ﬁltering down: left vs. right In fact, the “risk” is no more than “no improvement” Element(55) to be inserted bubbling up: element vs. parent Step 1 Step 2 90 80 75 25 45 70 35 60 50 40 15 65 80 25 45 70 35 60 80 65 70 75 25 45 35 60 90 65 75 25 45 35 50 40 15 “Vacant” ﬁltering down only half-way If the element is smaller, ﬁltering down half-half-way Improvement by Divide- and-Conquer The bubbling up will not beyond last vacStop Step 1 Step 2 Depth Bounded Filtering Down int promote(Element [ ]E, int hStop, int vacant, int h) int vacStop; if(h ≤ hStop) vacStop = vacant; else if(E[2*vacant].key ≤ E[2*vacant+1].key) E[vacant] = E[2*vacant + 1]; vacStop = promote(E, hStop, 2*vacant + 1, h - 1); else E[vacant] = E[2*vacant]; vacStop = promote(E, hStop, 2*vacant, h - 1); return vacStop; Depth bound FixHeap Using Divide-and- Conquer void ﬁxHeapFast(Element [ ]E, Element K, int vacant, int h) // in uppermost call if(h ≤ 1) Process heap of height 0 or 1; else int hStop = h/2; Int vacStop = promote(E, hStop, vacant, h); int vacParent = vacStop/2; if(E[vacParent].key ≤ K.key) E[vacStop] = E[vacParent]; bubbleUpHeap(E, vacant, K, vacParent); else ﬁxHeapFast(E, K, vacStop, hStop); h = ⌈log(n + 1)/2⌉ Number of Comparisons in Accelerated FixHeap • Moving the vacant one level up or down need one comparison exactly in promote or bubbleUpHeap. • In a cycle, t calls of promote and 1 call of bubbleUpHeap are executed at most. So, the number of comparisons in promote and bubbleUpHeap calls are: • At most, lg(h) checks for reverse direction are executed. So, the number of comparisons in a cycle is at most h+log(h) • So, for accelerated heapSort: t ∑ k=1 ⌈ h 2 k ⌉ + ⌈ h 2 t ⌉ = h = log(n + 1) Wn(n) = n log n + Θ(n log log n) Recursion Equation of Accelerated heapSort • The recurrence equation about h, which is about log(n+1) • Assuming T(h)≥h, then: T(1) = 2 T(h) = ⌈ h 2 ⌉ + max (⌈ h 2 ⌉ ,1 + T (⌊ h 2 ⌋)) T(h) = ⌈ h 2 ⌉ + 1 + T (⌊ h 2 ⌋) T(1) = 2 Solving the Recurrence Equation by Recursive Tree T(n) ⌈h/2⌉ + 1 T(⌊n/2⌋) ⌈h/4⌉ + 1 T(⌊n/4⌋) ⌈h/8⌉ + 1 T(1) 1 + 1 ⌈log(h + 1)⌉ levels For sorting a sequence of size n, n cycles of ﬁxHeap are executed, so: n(h + ⌈log(h + 1)⌉) Inductive Proof • The recurrence equation for ﬁxHeapFast: • Proving the following solution by induction: • According to the recurrence equation: • Applying the inductive assumption to the last term: T(h) = h + ⌈log(h + 1)⌉ T(h + 1) = ⌈(h + 1)/2⌉ + 1 + ⌊(h + 1)/2⌋ + ⌈log(⌊(h + 1)/2⌋ + 1)⌉ T(h + 1) = ⌈(h + 1)/2⌉ + 1 + T(⌊(h + 1)/2⌋) (It can be proved that for any positive integer: ) ⌈log(⌊(h)/2⌋ + 1)⌉ + 1 = ⌈log(h + 1)⌉ Wn(n) = n log n + Θ(n log log n) For Accelerated Heap T(1) = 2 T(h) = ⌈ h 2 ⌉ + 1 + T (⌊ h 2 ⌋) Generalization of a Heap • d-ary heap • Structure / partial order • How to choose “d”? • Top-down: ﬁx the parent node • Cost: d comparisons in the worst case • Bottom-up: ﬁx the child node • Cos: always 1 4-art heap Not only for Sorting • Eg1: how to ﬁnd the k th max element? • The cost should be f(k) • Eg2: how to ﬁnd the ﬁrst k elements? • In sorted order? • Eg3: how to merge k sorted lists? • Eg4: how to ﬁnd the median dynamically? • ... Thank you! Q & A","libVersion":"0.2.4","langs":""}