{"path":"pdf/算法设计与分析/L10 - Union-Find.pdf","text":"Introduction to Algorithm Design and Analysis [10] Union-Find Jingwei Xu https://cs.nju.edu.cn/ics/people/jingweixu/ index.html Institute of Computer Software Nanjing University In the last class … • Hashing • Basic idea • Collision handling for hashing • Closed address • Open address • Amortized analysis • Array doubling • Stack operations • Binary counter Union-Find • Dynamic Equivalence Relation • Examples • Deﬁnitions • Brute force implementations • Disjoint Set • Straightforward Union-Find • Weighted Union + Straightforward Find • Weighted Union + Path-compressing Find Minimum Spanning Tree • Kruskal’s algorithm, greedy strategy: • Select one edge • With the minimum weight • Not in the tree • Evaluate this edge • This edge will NOT result in a cycle • Critical issue: • How to know “NO CYCLE”? Maze Generation Black Pixels • Maximum black pixel component • Let ⍺ be the size of the component • Color one pixel black • How ⍺ changes? • How to choose the pixel, to accelerate the change in ⍺ Jigsaw Puzzle • Multiple pieces may be glued together • From “one player” to “two players” • Each group can only be moved in mutual exclusive way • How to decide the relation of “in the same group” Dynamic Equivalence Relations • Equivalence • Reﬂexive, symmetric, transitive • Equivalent classes forming a partition • Dynamic equivalence relation • Changing in the process of computation • IS instruction: yes or no (in the same equivalence class) • MAKE instruction: combining two equivalent classes, by relating two unrelated elements, and inﬂuencing the results of subsequent IS instructions. • Starting as equality relation Implementation: How to Measure • The number of basic operations for processing a sequence of m MAKE and/or IS instructions on a set S with n elements. • An example: S={1, 2, 3, 4, 5} • 0. [create] {{1}, {2}, {3}, {4}, {5}} • 1. IS 2≡4? • 2. IS 3≡5? • 3. MAKE 3≡5. {{1}, {2}, {3, 5}, {4}} • 4. MAKE 2≡5. {{1}, {2, 3, 5}, {4}} • 5. IS 2≡3? • 6. MAKE 4≡1. {{1, 4}, {2, 3, 5}} • 7. IS 2≡4? NO NO YES NO Union-Find based Implementation • The maze problem • Randomly delete a wall and union two cells • Loop until you ﬁnd the inlet and outlet are in one equivalent class • The Kruskal algorithm • Find whether u and v are in the same equivalent class • If not, add the edge and union the two nodes • The black pixels problem • Find two black pixels not in the same group • How the union will increase ⍺ Implementation: Choices • Matrix (relation matrix) • Space in Θ(n 2 ), and worst-case cost in Ω(mn) (mainly for row copying for MAKE/union) • Array (for equivalence class ID) • Space in Θ(n), and worst-case cost in Ω(mn) (mainly for search and change for MAKE/union) • Forest of rooted trees • A collection of disjoint sets, supporting Union and Find operations • Not necessary to traverse all the elements in one set Union-Find ADT • Constructor: Union-Find create(int n) • sets = create(n) refers to a newly created group of sets {1}, {2}, …, {n} (n singletons) • Access Function: int ﬁnd(UnionFind sets, e) • ﬁnd(sets, e) = <e> • Manipulation Procedures • void makeSet(UnionFind sets, int e) • void union(UnionFind sets, int s, int t) Using Rooted TreeUnion-Find Program • A union-ﬁnd program of length m • is (a create(n) operation followed by) a sequence of m union and/or ﬁnd operations in any order • A union-ﬁnd program is considered an input • The object on which the analysis is conducted • The measure: number of accesses to the parent • assignments: for union operations • lookups: for ﬁnd operations link operation Worst-case Analysis for Union-Find Program • Assuming each lookup/assignment take O(1) • Each makeSet/union does one assignment, and each ﬁnd does d+1 lookups, where d is the depth of the node. Weighted Union: for Short Trees • Weighted union (wUnion) • always have the tree with fewer nodes as subtree Upper Bound of Tree Height • After any sequence of Union instructions, implemented by wUnion, any tree that has k nodes will have height at most logk • Proof by induction on k: • base case: k=1, the height is 0 • by inductive hypothesis: • h 1 ≤lgk 1 , h 2 ≤lgk 2 • h=max(h 1 ,h 2 +1) k=k 1 +k 2 • if h=h 1 , h 1 ≤lgk 1 ≤lgk • if h=h 2 +1, note: k 2 ≤k/2, so h 2 +1≤lgk 2 +1≤lgk t u T 1 k 1 nodes height h 1 T 2 k 2 nodes height h 2 T k nodes height h Upper Bound for Union-Find Program • A Union-Find program of size m, on a set of n elements, performs O(n+mlogn) link operations in the worst case if wUnion and straight find are used • Proof: • At most n‐1 wUnion can be done, building a tree with height at most logn, • Then, each ﬁnd costs at mostlogn+1. • Each union costs in O(1), so, the upper bound on the cost of any combination of m wUnion/ﬁnd operations is the cost of m ﬁnd operations, that is m(logn+1)∈O (n+mlogn) • There do exist programs requiring Ω(n+(m‐n)logn) steps. Path Compression Path compressed Change their parents to the root x w v x v w Challenges for the Analysis Path compressed cFind does twice as many link operations as the ﬁnd does for a given node in a given tree x w v x v w cFind will traverse shorter paths but… Analysis: the Basic Idea • cFind may be an expensive operation • in the case that ﬁnd(i) is executed and the node i has great depth. • However, such cFind can be executed only for limited times • Path compressions depends on previous unions • So, amortized analysis applies Co-Strength of wUnion and cFind • O((n+m)log*(n)) • Link operations for a Union-Find program of length m on a set of n elements is in the worst case. • Implemented with wUnion and cFind • What’s log*(n)? • Deﬁne the function H as following: (Ackermann) • Then, log*(j) for j≥1 is deﬁned as: H(0) = 1 H(i) = 2 H(i−1) log*( j) = min{k | H(k) ≥ j} A function Growing Extremely Slowly • Function H: H(0) = 1 H(i) = 2 H(i−1) That is: H(k) = 2 2 . . . . . . 2 k 2’s Note: H grows extremely fast: H(4) = 2 16 = 65536 H(5) = 2 65536 • Function log-star log*(j) is deﬁned as the least i such that: H(i) ≥ j for j>0 • log-star grows extremely slowly p is any ﬁxed nonnegative constant For any x: 2 16 ≤x≤2 65536 -1, log*(x)=5 lim n→∞ log * (n) log (p) n = 0 Deﬁnitions with a Union-Find Program P • Forest F: the forest constructed by the sequence of union instructions in P, assuming: • wUnion is used; • the ﬁnds in the P are ignored • Height of a node v in any tree: the height of the subtree rooted at v • Rank of v: the height of v in F Note: cFind changes the height of a node, but the rank for any node is invariable. Constraints on Ranks in F • The upper bound of the number of nodes with rank r(r≥0) is n/2 r • Remember that the height of the tree built by wUnion is at mostlogn, which means the subtree of height r has at least 2 r nodes. • The subtrees with root at rank r are disjoint. • There are at mostlogndifferent ranks. • There are altogether n elements in S, that is, n nodes in F. Increasing Sequence of Ranks • The ranks of the nodes on a path from a leaf to a root of a tree in F form a strictly increasing sequence. • When a cFind operation changes the parent of a node, the new parent has higher rank than the old parent of that node. • Note: the new parent was an ancestor of the previous parent. Grouping Nodes by Ranks • Node v∈s i (i≥0) iff. log*(1+rank of v)=i • which means that: if node v is in group i, then r v ≤H(i)-1, but not in group with smaller labels • So, • Group 0: all nodes with rank 0 • Group 1: all nodes with rank 1 • Group 2: all nodes with rank 2 or 3 • Group 3: all nodes with its rank in [4, 15] • Group 4: all nodes with its rank in [16, 65535] • Group 5: all nodes with its rank in [65535, ???] Group 5 exists only when n is at least 2 65536 . What is that? Very Few Groups • Node v∈S i (i≥0) iff. • Upper bound of the number of distinct node groups is log*(n+1) • The rank of any node in F is at mostlogn, so the largest group index is log*(1+logn)=log* (logn+1) = log*(n+1)‐1 log*(1 + rank of v)=i Amortized Cost of Union- Find • Amortized Equation Recalled • amortized cost = actual cost + accounting cost • The operations to be considered: • n makeSets • m union & ﬁnd (with at most n‐1 unions) One Execution of cFind(w 0 ) Amortizing Scheme for wUnion-cFind • makeSet • Accounting cost is 4log*(n+1) • So, the amortized cost is 1+4log*(n+1) • wUnion • Accounting cost is 0 • So the amortized cost is 1 • cFind • Accounting cost is describes as in the previous page. • Amortized cost ≤ 2k‐2((k‐1)‐(log*(n+1)‐1))=2log*(n+1) (Compare with the worst case cost of cFind, 2logn) Number of withdrawal Validation of the Amortizing Scheme • We must be assure that the sum of the accounting costs is never negative. • The sum of the negative charges, incurred by cFind, does not exceed 4nlog*(n+1) • We prove this by showing that at most 2nlog*(n+1) withdrawals on nodes occur during all the executions of cFind. Key Idea in the Derivation • For any node, the number of withdrawal will be less than the number of different ranks in the group it belongs to • When a cFind changes the parent of a node, the new parent is always has higher rank than the old parent. • Once a node is assigned a new parent in a higher group, no more negative amortized cost will incurred for it again. • The number of different ranks is limited within a group. Derivation • Bounding the number of withdrawals Conclusion • The number of link operations done by a Union-Find program implemented with wUnion and cFind, of length m on a set of n elements is in O((n+m)log*(n)) in the worst case. • Note: since the sum of accounting cost is never negative, the actual cost is always not less than amortized cost. The upper bound of amortized cost is: (n+m)(1+4log*(n+1)) • Thank you! Q & A","libVersion":"0.2.4","langs":""}