{"path":"pdf/ÁÆóÊ≥ïËÆæËÆ°‰∏éÂàÜÊûê/L8 - logn search.pdf","text":"Introduction to Algorithm Design and Analysis [08] logn search Jingwei Xu http://cs.nju.edu.cn/ics/people/jingweixu Institute of Computer Software Nanjing University In the last class ‚Ä¶ ‚Ä¢ Selection - warm up ‚Ä¢ Max and min ‚Ä¢ Second largest ‚Ä¢ Selection - rank k (median) ‚Ä¢ Expected linear time ‚Ä¢ Worst-case linear time ‚Ä¢ Adversary argument ‚Ä¢ Lower bound The Searching Problem ‚Ä¢ Searching v.s. Selection ‚Ä¢ Search for ‚ÄúAlice‚Äù or ‚ÄúBob‚Äù ‚Ä¢ The key itself matters ‚Ä¢ Select the ‚Äúrank 2‚Äù student ‚Ä¢ The partial order relation matters ‚Ä¢ Expected cost for searching ‚Ä¢ Brute force case: O(n) ‚Ä¢ Ideal case: O(1) ‚Ä¢ Can we achieve O(logn)? The Searching Problem ‚Ä¢ Essential of searching ‚Ä¢ How to organize the data to enable eÔ¨Écient search ‚Ä¢ logn search ‚Ä¢ Each search cuts oÔ¨Ä half of the search space ‚Ä¢ How to organize the data to enable logn search ‚Ä¢ logn search techniques ‚Ä¢ Warmup ‚Ä¢ Binary search over sorted sequences ‚Ä¢ Balanced Binary Search Tree (BST) ‚Ä¢ Red-black tree Binary Search by Example ‚Ä¢ Binary search for ‚Äú24‚Äù ‚Ä¢ Divide the search space ‚Ä¢ Cut oÔ¨Ä half the space after each search 3 5 6 20 21 24 30 40 45 50 The sequence is already sorted 1 st 2 nd 3 rd Binary Search Generalized ‚Ä¢ Peak-number ‚Ä¢ Uni-modal array ‚Ä¢ Least number not in the array ‚Ä¢ Sorted array of natural numbers ‚Ä¢ A[i]=i ‚Ä¢ Sorted array of integers Balanced Binary Search Tree ‚Ä¢ Binary search tree (BST) ‚Ä¢ DeÔ¨Ånitions and basic operations ‚Ä¢ DeÔ¨Ånition of Red-Black Tree (RBT) ‚Ä¢ Black height ‚Ä¢ RBT operations ‚Ä¢ Insertion into a red-black tree ‚Ä¢ Deletion from a red-black tree Binary Search Tree Revisited 40 20 60 30 50 80 30 20 80 40 60 50 Good balancing Œò(logn) Poor balancing Œò(n) Each node has a key, belonging to a linear ordered set An inorder traversal produces a sorted list of the keys In a properly drawn tree, pushing forward to get the ordered list. Node Group 50 15 70 80 70 60 80 75 5 principal subtrees As in 2-tree, the number of external node is one more than that of internal node 10 25 20 40 30 60 65 75 90 Node group Balancing by Rotation 50 15 The middle principal subtree changes parent 10 25 20 40 30 The node group to be rotated 50 15 10 25 20 40 30 Root of the group is changed Red-Black Tree: DeÔ¨Ånition ‚Ä¢ If T is a binary search tree in which each node has a color, red or black, and all external nodes are black, then T is a red-black tree if and only if: ‚Ä¢ [Color constraint] No red node has a red child ‚Ä¢ [Black height constraint] The black length of all external paths from a given node u is the same (the black height of u) ‚Ä¢ The root is black. ‚Ä¢ Almost-red-black tree (ARB tree) ‚Ä¢ Root is red, satisfying the other constraints. Balancing is under control Recursive DeÔ¨Ånition of RBT ‚Ä¢ DeÔ¨Ånition ‚Ä¢ An external node is an RB 0 tree, and the node is black. ‚Ä¢ A binary tree is an ARB h (h‚â•1) tree if: ‚Ä¢ Its root is red, and ‚Ä¢ Its left and right sub trees are each an RB h-1 tree. ‚Ä¢ A binary tree is an RB h (h‚â•1) tree if: ‚Ä¢ Its root is black, and ‚Ä¢ Its left and right sub trees are each either an RB h-1 tree or an ARB h tree. (A red-black tree of black height h is denoted as RB h ) (1) RB i and ARB i 20 RB 0 ARB 1 (2) (3) (4) Red-Black Tree with 6 Nodes 20 40 20 60 50 8030 20 40 20 60 50 8030 20 30 20 60 50 80 40 Black edge poorest balancing: height(normal) is 4 Black-depth Convention 40 20 6050 8030 40 20 60 50 8030 30 20 60 50 80 40 All with the same largest black depth: 2 ARB Trees Properties of Red-Black Tree ‚Ä¢ The black height of any RB h tree or ARB h tree is well-deÔ¨Åned and is h. ‚Ä¢ Let T be an RB h tree, then: ‚Ä¢ T has at least 2 h -1 internal black nodes. ‚Ä¢ T has at most 4 h -1 internal nodes. ‚Ä¢ The depth of any black node is at most twice its black depth. ‚Ä¢ Let A be an ARB h tree, then: ‚Ä¢ A has at least 2 h -2 internal black nodes. ‚Ä¢ A has at most (4 h )/2-1 internal nodes. ‚Ä¢ The depth of any black node is at most twice its black depth. Well-deÔ¨Åned Black Height ‚Ä¢ That ‚Äúthe black height of any RB h tree or ARB h tree is well deÔ¨Åned‚Äù means the black length of all external paths from the root is the same. ‚Ä¢ Proof: induction on h ‚Ä¢ Base case: h=0, that is RB 0 (there is no ARB 0 ) ‚Ä¢ In ARB h+1 , its two subtrees are both RB h . Since the root is red, the black length of all external paths from the root is h, that‚Äôs the same as its two subtrees. ‚Ä¢ In RB h+1 : ‚Ä¢ Case 1: two subtrees are RB h ‚Äôs ‚Ä¢ Case 2: two subtrees are ARB h+1 ‚Äôs ‚Ä¢ Case 3: one subtree is an RB h (black height=h), and the another is an ARB h+1 (black height=h+1) Bound on Depth of Node in RBTree ‚Ä¢ Let T be a red-black tree with n internal nodes. Then no node has black depth greater than log(n+1), which means that the height of T in the usual sense is at most 2log(n+1). ‚Ä¢ Proof: ‚Ä¢ Let h be the black height of T. The number of internal nodes, n, is at least the number of internal black nodes, which is at least 2 h -1, so h‚â§log(n+1). The node with greatest depth is some external node. All external nodes are with black depth h. So, the depth is at most 2h. InÔ¨Çuences of Insertion to an RBT ‚Ä¢ Black height constraint: ‚Ä¢ No violation if inserting a red node. ‚Ä¢ Color constraint: 40 20 6050 8030 40 20 6050 80 30 Critical clusters (external nodes excluded), which originated by color violation, with 3 or 4 nodes 70 Inserting 70 Repairing 4-node Critical Cluster 40 20 6050 80 30 No new critical cluster occurs, inserting Ô¨Ånished 70 40 20 60 50 80 30 70 Color Ô¨Çip: Root of the critical cluster exchanges color with its subtrees Repairing 4-node Critical Cluster 2 more insertions 40 20 60 50 80 30 70 New critical cluster with 3 nodes. Color Ô¨Çip doesn‚Äôt work, why? 85 90 Critical cluster 40 20 60 50 80 30 70 85 90 Patterns of 3-node Critical Cluster L LL M LR R RL RR L LL M LR R RL RR L LL M LR R RL RR L LL M LR R RL RR DC BA Repairing 3-node Critical Cluster Root of the critical cluster is changed to M, and the parent ship is adjusted accordingly The incurred critical cluster is of pattern A L LL M LR R RL RR A 40 20 60 50 80 30 70 85 90 Implementing Insertion: Class class RBTree Element root; RBTree leftSubtree; RBTree rightSubtree; int color; /*red, black*/; static class InsReturn public RBTree newTree; public int status /* ok, rbr, brb, rrb, brr */ Implementing Insertion: Procedure RBTree rbtInsert(RBtree oldRBtree, Element newNode) InsReturn ans = rbtIns(oldREtree, newNode); if(ans.newTree.color != black) ans.newTree.color = black; return ans.newTree; Implementing Insertion: Procedure InsReturn rbtIns(RBtree oldRBtree, Element newNode) InsReturn ans, ansLeft, ansRight; if (oldRBtree = nil) then <Inserting simply>; else if (newNode.key < oldRBtree.root.key) ansLeft = rbtIns(oldRBtree.leftSubtree, newNode); ans = repairLeft(oldRBtree, ansLeft); else ansRight = rbtIns(oldRBtree.rightSubtree, newNode); ans = repairRight(oldRBtree, ansRight); return ans Correctness of Insertion ‚Ä¢ If the parameter oldRBtree of rbtIns is an RB h tree or an ARB h+1 tree (which is true for the recursive calls on rbtIns), then the newTree and status Ô¨Åelds returned are one of the following combinations: ‚Ä¢ Status=ok, and newTree is an RB h or an ARB h+1 tree, ‚Ä¢ Status=rbr, and newTree is an RB h , ‚Ä¢ Status=brb, and newTree is an ARB h+1 tree, ‚Ä¢ Status=rrb, and newTree.color=red, newTree.leftSubtree is an ARB h+1 tree and newTree.rightSubtree is an RB h tree, ‚Ä¢ Status=brr, and newTree.color=red, newTree.rightSubtree is an ARB h+1 tree and newTree.leftSubtree is an RB h tree ‚Ä¢ For those cases with red root, the color will be changed to black, with other constraints satisÔ¨Åed by repairing subroutines. Deletion: Logical and Structural 40 20 60 50 80 30 70 85 90 u: to be deleted logically œÄ is parent of ùúé 40 20 70 50 80 30 85 90 ùúé: tree successor of u, to be deleted structurally, with information moved into u right subtree of S, to replace S œÄ After deletion Deletion from RBT - Examples 40 20 60 50 80 30 70 85 90 original tree 40 20 60 50 85 30 70 90 80 u, œÄ 50 20 60 80 30 70 85 90 u, œÄ 40 40 20 60 50 80 30 70 90 85 u, œÄ Deletion in RBT 40 20 60 50 80 30 70 85 90 To be deleted 40 20 70 50 80 30 85 90 The black height of œÄ is not well-deÔ¨Åned! œÄ One deletion black depth=1 black depth=2 Procedure of Red-Black Deletion ‚Ä¢ Do a standard BST search to locate the node to be logically deleted, call it u ‚Ä¢ If the right child of u is an external node, identify u as the node to be structurally deleted. ‚Ä¢ If the right child of u is an internal node, Ô¨Ånd the tree successor of u, call it ùúé, copy the key and information from ùúé to u. (color of u not changed) Identify ùúé as the node to be deleted structurally. ‚Ä¢ Carry out the structural deletion and repair any imbalance of black height. Imbalance of Black Height 40 20 60 50 80 30 70 85 90 85 70 90 deleting 80 50 20 30 deleting 40 80 90 deleting 85 70 80 85 90 Black height has to be restored deleting 60 Analysis of Black Imbalance ‚Ä¢ The imbalance occurs when: ‚Ä¢ A black node is deleted structurally, and ‚Ä¢ Its right subtree is black (external) ‚Ä¢ The result is: ‚Ä¢ An RB h-1 occupies the position of an RB h as required by its parent, coloring it as a ‚Äúgray‚Äù node. ‚Ä¢ Solution: ‚Ä¢ Find a red node and turn it black as locally as possible. ‚Ä¢ The gray color might propagate up the tree. Propagation of Gray Node s l p r g s l p r g s l p rg G-subtree gets well-deÔ¨Åned black height, but that is less than that required by its parent Map of the vicinity of g, the gray node The pattern for which propagation is needed In the worst case, up to the root of the tree, and successful Gray up Repairing without Propagation s b p rg Deletion Rebalance group Restructured a l s b l r p ag Restructuring the deletion rebalance group: Red p: form an RB 1 or ARB 2 tree Black p: form an RB 2 tree 4 principal subtrees, RB h-1 Repairing without Propagation s b p rg Deletion Rebalance group Restructured a l s b l r p ag Restructuring the deletion rebalance group: Red p: form an RB 1 or ARB 2 tree Black p: form an RB 2 tree 4 principal subtrees, RB h-1 Complexity of Operations on RBT ‚Ä¢ With reasonable implementation ‚Ä¢ A new node can be inserted correctly in a red- black tree with n nodes in (logn) time in the worst case. ‚Ä¢ Repairs for deletion do O(1) structural changes, but may do O(logn) color changes. Thank you! Q & A","libVersion":"0.2.4","langs":""}