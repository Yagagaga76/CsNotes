{"path":"pdf/课件/第4章  贪心算法.pdf","text":"0 第 4 章  贪⼼算法 顾名思义，贪⼼算法总是作出在当前看来最好的选 择。也就是说贪⼼算法并不从整体最优考虑，它所作 出的选择只是在某种意义上的 局部最优 选择。当然， 希望贪⼼算法得到的最终结果也是整体最优的。虽然 贪⼼算法不能对所有问题都得到整体最优解，但对许 多问题它能产⽣整体最优解。如单源最短路经问题， 最⼩⽣成树问题等。在⼀些情况下，即使贪⼼算法不 能得到整体最优解，其最终结果却是最优解的很好近 似。 0 第 4 章  贪⼼算法 • 4.1 活动安排问题 • 4.2 贪⼼算法的基本要素 • 4.3 最优装载 • 4.4 哈夫曼编码 • 4.5 单源最短路径 • 4.6 最⼩⽣成树 • 4.7 多机调度问题 • 4.8 贪⼼算法的理论基础 本章主要知识点： 0 4.1 活动安排问题 活动安排问题就是要在所给的活动集合中选出最 ⼤的相容活动⼦集合，是可以⽤贪⼼算法有效求解的 很好例⼦。该问题要求⾼效地安排⼀系列争⽤某⼀公 共资源的活动。贪⼼算法提供了⼀个简单、漂亮的⽅ 法使得尽可能多的活动能兼容地使⽤公共资源。 0 4.1 活动安排问题 设有 n 个活动的集合 E ={1,2,…,n} ，其中每个活动都要求 使⽤同⼀资源，如演讲会场等，⽽在同⼀时间内只有⼀个 活动能使⽤这⼀资源。每个活动 i 都有⼀个要求使⽤该资源 的起始时间 si 和⼀个结束时间 fi , 且 si < fi 。如果选择了活动 i ，则它在半开时间区间 [ si , fi ) 内占⽤资源。若区间 [ si , fi ) 与 区间 [ sj , fj ) 不相交，则称活动 i 与活动 j 是相容的。也就是 说，当 si ≥ fj 或 sj ≥ fi 时，活动 i 与活动 j 相容。 0 4.1 活动安排问题 • publ i c s t a t i c i nt gr e e d yS e l e c tor ( i nt [] s , i nt [] f, bool e a n a []) • { • i nt n=s .l e ngt h-1; • a [1]=t rue ; • i nt j =1; • i nt c ount =1; • for ( i nt i =2; i <=n; i ++) { • i f (s [i ]>=f[j ]) { • a [i ]=t rue ; • j =i ; • c ount ++; • } • e l s e a [i ]=fa l s e ; • } • re t urn c ount ; • } 在下⾯所给出的解活动安排问题的贪⼼算法 greedySelector : 各活动的起始时间和结束 时间存储于数组 s 和 f 中且 按结束时间的⾮减序排列 0 4.1 活动安排问题 由于输⼊的活动以其完成时间的 ⾮减序 排列，所以 算法 gr e e d yS e l e c tor 每次总是选择 具有最早完成时间 的 相容活动加⼊集合 A 中。直观上，按这种⽅法选择相 容活动为未安排活动留下尽可能多的时间。也就是 说，该算法的贪⼼选择的意义是 使剩余的可安排时间 段极⼤化 ，以便安排尽可能多的相容活动。 算法 gr e e d yS e l e c tor 的效率极⾼。当输⼊的活动已 按结束时间的⾮减序排列，算法只需 O (n ) 的时间安排 n 个活动，使最多的活动能相容地使⽤公共资源。如 果所给出的活动未按⾮减序排列，可以⽤ O( n l ogn ) 的 时间重排。 0 4.1 活动安排问题 例： 设待安排的 11 个活动的开始时间和结束时间按结 束时间的⾮减序排列如下： 1413121110987654f[i ] 122886535031S [i ] 1110987654321i 0 4.1 活动安排问题 算法 gr e e d yS e l e c tor 的计算 过程 如左图所示。图中 每⾏相应于算法的⼀次 迭代。阴影⻓条表示的 活动是已选⼊集合 A 的活 动，⽽空⽩⻓条表示的 活动是当前正在检查相 容性的活动。 0 4.1 活动安排问题 若被检查的活动 i 的开始时间 Si ⼩于最近选择的活动 j 的 结束时间 fi ，则不选择活动 i ，否则选择活动 i 加⼊集 合 A 中。 贪⼼算法并不总能求得问题的 整体最优解 。但对于 活动安排问题，贪⼼算法 gre e dyS e l e c t or 却总能求得的 整体最优解，即它最终所确定的相容活动集合 A 的规模 最⼤。这个结论可以⽤数学归纳法证明。 0 4.2 贪⼼算法的基本要素 本节着重讨论可以⽤贪⼼算法求解的问题的⼀般特 征。 对于⼀个具体的问题，怎么知道是否可⽤贪⼼算法 解此问题，以及能否得到问题的最优解呢 ? 这个问题很 难给予肯定的回答。 但是，从许多可以⽤贪⼼算法求解的问题中看到这类 问题⼀般具有 2 个重要的性质： 贪⼼选择性质 和 最优⼦ 结构性质 。 0 4.2 贪⼼算法的基本要素 1 、贪⼼选择性质 所谓 贪⼼选择性质 是指所求问题的 整体最优解 可以通 过⼀系列 局部最优 的选择，即贪⼼选择来达到。这是贪 ⼼算法可⾏的第⼀个基本要素，也是贪⼼算法与动态规 划算法的主要区别。 动态规划算法通常以 ⾃底向上 的⽅式解各⼦问题，⽽ 贪⼼算法则通常以 ⾃顶向下 的⽅式进⾏，以迭代的⽅式 作出相继的贪⼼选择，每作⼀次贪⼼选择就将所求问题 简化为规模更⼩的⼦问题。 对于⼀个具体问题，要确定它是否具有贪⼼选择性 质，必须证明每⼀步所作的贪⼼选择最终导致问题的整 体最优解。 0 4.2 贪⼼算法的基本要素 当⼀个问题的最优解包含其⼦问题的最优解时， 称此问题具有 最优⼦结构性质 。问题的最优⼦结构性 质是该问题可⽤动态规划算法或贪⼼算法求解的关键 特征。 2 、最优⼦结构性质 0 4.2 贪⼼算法的基本要素 贪⼼算法和动态规划算法都要求问题具有最优⼦结构 性质，这是 2 类算法的⼀个共同点。但是，对于具有 最 优⼦结构 的问题应该选⽤贪⼼算法还是动态规划算法 求解 ? 是否能⽤动态规划算法求解的问题也能⽤贪⼼算 法求解 ? 下⾯研究 2 个经典的 组合优化问题 ，并以此说 明贪⼼算法与动态规划算法的主要差别。 3 、贪⼼算法与动态规划算法的差异 0 4.2 贪⼼算法的基本要素 • 0-1 背包问题： 给定 n 种物品和⼀个背包。物品 i 的重量是 Wi ，其价值 为 Vi ，背包的容量为 C 。应如何选择装⼊背包的物品， 使得装⼊背包中物品的总价值最⼤ ? 在选择装⼊背包的物品时，对每种物品 i 只有 2 种选择，即装⼊背 包或不装⼊背包。不能将物品 i 装⼊背包多次，也不能只装⼊部分 的物品 i 。 0 4.2 贪⼼算法的基本要素 • 背包问题： 与 0-1 背包问题类似，所不同的是在选择物品 i 装⼊ 背包时， 可以选择物品 i 的⼀部分 ，⽽不⼀定要全部装 ⼊背包， 1 ≤ i ≤ n 。 这 2 类问题都具有 最优⼦结构 性质，极为相似，但背 包问题可以⽤贪⼼算法求解，⽽ 0-1 背包问题却不能⽤ 贪⼼算法求解。 0 4.2 贪⼼算法的基本要素 ⾸先计算每种物品单位重量的价值 Vi / Wi ，然后，依贪⼼选 择策略，将尽可能多的 单位重量价值最⾼ 的物品装⼊背包。 若将这种物品全部装⼊背包后，背包内的物品总重量未超过 C ，则选择单位重量价值次⾼的物品并尽可能多地装⼊背 包。依此策略⼀直地进⾏下去，直到背包装满为⽌。 具体算法可描述如下⻚： ⽤贪⼼算法解背包问题的基本步骤：   0 4.2 贪⼼算法的基本要素 • publ i c s t a t i c fl oa t k n ap s ac k (fl oa t c ,fl oa t [] w , fl oa t [] v ,fl oa t [] x) • { • i nt n=v .l e ngt h; • E l e m e nt [] d = ne w E l e m e nt [n]; • for ( i nt i = 0; i < n; i ++) d[i ] = ne w E l e m e nt (w [i ],v[i ],i ); • M e r ge S ort . m e r ge S ort (d); • i nt i ; • fl oa t opt =0; • for (i =0; i <n; i ++) x[i ]=0; • for (i =0; i <n; i ++) { • i f (d[i ].w >c ) bre a k; • x[d[i ].i ]=1; • opt +=d[i ].v; • c -=d[i ].w ; • } • i f (i <n){ • x[d[i ].i ]=c / d[i ].w ; • opt +=x[d[i ].i ]*d[i ].v; • } • re t urn opt ; • } 算法 k n ap s ac k 的主要 计算时间在于将各种 物品依其单位重量的 价值从⼤到⼩排序。 因此，算法的计算时 间上界为 O （ n l ogn ）。当然， 为了证明算法的正确 性，还必须证明背包 问题具有贪⼼选择性 质 。 0 第 4 章  贪⼼算法 顾名思义，贪⼼算法总是作出在当前看来最好的选 择。也就是说贪⼼算法并不从整体最优考虑，它所作 出的选择只是在某种意义上的 局部最优 选择。当然， 希望贪⼼算法得到的最终结果也是整体最优的。虽然 贪⼼算法不能对所有问题都得到整体最优解，但对许 多问题它能产⽣整体最优解。如单源最短路经问题， 最⼩⽣成树问题等。在⼀些情况下，即使贪⼼算法不 能得到整体最优解，其最终结果却是最优解的很好近 似。 0 第 4 章  贪⼼算法 • 4.1 活动安排问题 • 4.2 贪⼼算法的基本要素 • 4.3 最优装载 • 4.4 哈夫曼编码 • 4.5 单源最短路径 • 4.6 最⼩⽣成树 • 4.7 多机调度问题 • 4.8 贪⼼算法的理论基础 本章主要知识点： 0 4.1 活动安排问题 活动安排问题就是要在所给的活动集合中选出最 ⼤的相容活动⼦集合，是可以⽤贪⼼算法有效求解的 很好例⼦。该问题要求⾼效地安排⼀系列争⽤某⼀公 共资源的活动。贪⼼算法提供了⼀个简单、漂亮的⽅ 法使得尽可能多的活动能兼容地使⽤公共资源。 0 4.1 活动安排问题 设有 n 个活动的集合 E ={1,2,…,n} ，其中每个活动都要求 使⽤同⼀资源，如演讲会场等，⽽在同⼀时间内只有⼀个 活动能使⽤这⼀资源。每个活动 i 都有⼀个要求使⽤该资源 的起始时间 si 和⼀个结束时间 fi , 且 si < fi 。如果选择了活动 i ，则它在半开时间区间 [ si , fi ) 内占⽤资源。若区间 [ si , fi ) 与 区间 [ sj , fj ) 不相交，则称活动 i 与活动 j 是相容的。也就是 说，当 si ≥ fj 或 sj ≥ fi 时，活动 i 与活动 j 相容。 0 4.1 活动安排问题 • publ i c s t a t i c i nt gr e e d yS e l e c tor ( i nt [] s , i nt [] f, bool e a n a []) • { • i nt n=s .l e ngt h-1; • a [1]=t rue ; • i nt j =1; • i nt c ount =1; • for ( i nt i =2; i <=n; i ++) { • i f (s [i ]>=f[j ]) { • a [i ]=t rue ; • j =i ; • c ount ++; • } • e l s e a [i ]=fa l s e ; • } • re t urn c ount ; • } 在下⾯所给出的解活动安排问题的贪⼼算法 greedySelector : 各活动的起始时间和结束 时间存储于数组 s 和 f 中且 按结束时间的⾮减序排列 0 4.1 活动安排问题 由于输⼊的活动以其完成时间的 ⾮减序 排列，所以 算法 gr e e d yS e l e c tor 每次总是选择 具有最早完成时间 的 相容活动加⼊集合 A 中。直观上，按这种⽅法选择相 容活动为未安排活动留下尽可能多的时间。也就是 说，该算法的贪⼼选择的意义是 使剩余的可安排时间 段极⼤化 ，以便安排尽可能多的相容活动。 算法 gr e e d yS e l e c tor 的效率极⾼。当输⼊的活动已 按结束时间的⾮减序排列，算法只需 O (n ) 的时间安排 n 个活动，使最多的活动能相容地使⽤公共资源。如 果所给出的活动未按⾮减序排列，可以⽤ O( n l ogn ) 的 时间重排。 0 4.1 活动安排问题 例： 设待安排的 11 个活动的开始时间和结束时间按结 束时间的⾮减序排列如下： 1413121110987654f[i ] 122886535031S [i ] 1110987654321i 0 4.1 活动安排问题 算法 gr e e d yS e l e c tor 的计算 过程 如左图所示。图中 每⾏相应于算法的⼀次 迭代。阴影⻓条表示的 活动是已选⼊集合 A 的活 动，⽽空⽩⻓条表示的 活动是当前正在检查相 容性的活动。 0 4.1 活动安排问题 若被检查的活动 i 的开始时间 Si ⼩于最近选择的活动 j 的 结束时间 fi ，则不选择活动 i ，否则选择活动 i 加⼊集 合 A 中。 贪⼼算法并不总能求得问题的 整体最优解 。但对于 活动安排问题，贪⼼算法 gre e dyS e l e c t or 却总能求得的 整体最优解，即它最终所确定的相容活动集合 A 的规模 最⼤。这个结论可以⽤数学归纳法证明。 0 4.2 贪⼼算法的基本要素 本节着重讨论可以⽤贪⼼算法求解的问题的⼀般特 征。 对于⼀个具体的问题，怎么知道是否可⽤贪⼼算法 解此问题，以及能否得到问题的最优解呢 ? 这个问题很 难给予肯定的回答。 但是，从许多可以⽤贪⼼算法求解的问题中看到这类 问题⼀般具有 2 个重要的性质： 贪⼼选择性质 和 最优⼦ 结构性质 。 0 4.2 贪⼼算法的基本要素 1 、贪⼼选择性质 所谓 贪⼼选择性质 是指所求问题的 整体最优解 可以通 过⼀系列 局部最优 的选择，即贪⼼选择来达到。这是贪 ⼼算法可⾏的第⼀个基本要素，也是贪⼼算法与动态规 划算法的主要区别。 动态规划算法通常以 ⾃底向上 的⽅式解各⼦问题，⽽ 贪⼼算法则通常以 ⾃顶向下 的⽅式进⾏，以迭代的⽅式 作出相继的贪⼼选择，每作⼀次贪⼼选择就将所求问题 简化为规模更⼩的⼦问题。 对于⼀个具体问题，要确定它是否具有贪⼼选择性 质，必须证明每⼀步所作的贪⼼选择最终导致问题的整 体最优解。 0 4.2 贪⼼算法的基本要素 当⼀个问题的最优解包含其⼦问题的最优解时， 称此问题具有 最优⼦结构性质 。问题的最优⼦结构性 质是该问题可⽤动态规划算法或贪⼼算法求解的关键 特征。 2 、最优⼦结构性质 0 4.2 贪⼼算法的基本要素 贪⼼算法和动态规划算法都要求问题具有最优⼦结构 性质，这是 2 类算法的⼀个共同点。但是，对于具有 最 优⼦结构 的问题应该选⽤贪⼼算法还是动态规划算法 求解 ? 是否能⽤动态规划算法求解的问题也能⽤贪⼼算 法求解 ? 下⾯研究 2 个经典的 组合优化问题 ，并以此说 明贪⼼算法与动态规划算法的主要差别。 3 、贪⼼算法与动态规划算法的差异 0 4.2 贪⼼算法的基本要素 • 0-1 背包问题： 给定 n 种物品和⼀个背包。物品 i 的重量是 Wi ，其价值 为 Vi ，背包的容量为 C 。应如何选择装⼊背包的物品， 使得装⼊背包中物品的总价值最⼤ ? 在选择装⼊背包的物品时，对每种物品 i 只有 2 种选择，即装⼊背 包或不装⼊背包。不能将物品 i 装⼊背包多次，也不能只装⼊部分 的物品 i 。 0 4.2 贪⼼算法的基本要素 • 背包问题： 与 0-1 背包问题类似，所不同的是在选择物品 i 装⼊ 背包时， 可以选择物品 i 的⼀部分 ，⽽不⼀定要全部装 ⼊背包， 1 ≤ i ≤ n 。 这 2 类问题都具有 最优⼦结构 性质，极为相似，但背 包问题可以⽤贪⼼算法求解，⽽ 0-1 背包问题却不能⽤ 贪⼼算法求解。 0 4.2 贪⼼算法的基本要素 ⾸先计算每种物品单位重量的价值 Vi / Wi ，然后，依贪⼼选 择策略，将尽可能多的 单位重量价值最⾼ 的物品装⼊背包。 若将这种物品全部装⼊背包后，背包内的物品总重量未超过 C ，则选择单位重量价值次⾼的物品并尽可能多地装⼊背 包。依此策略⼀直地进⾏下去，直到背包装满为⽌。 具体算法可描述如下⻚： ⽤贪⼼算法解背包问题的基本步骤：   0 4.2 贪⼼算法的基本要素 • publ i c s t a t i c fl oa t k n ap s ac k (fl oa t c ,fl oa t [] w , fl oa t [] v ,fl oa t [] x) • { • i nt n=v .l e ngt h; • E l e m e nt [] d = ne w E l e m e nt [n]; • for ( i nt i = 0; i < n; i ++) d[i ] = ne w E l e m e nt (w [i ],v[i ],i ); • M e r ge S ort . m e r ge S ort (d); • i nt i ; • fl oa t opt =0; • for (i =0; i <n; i ++) x[i ]=0; • for (i =0; i <n; i ++) { • i f (d[i ].w >c ) bre a k; • x[d[i ].i ]=1; • opt +=d[i ].v; • c -=d[i ].w ; • } • i f (i <n){ • x[d[i ].i ]=c / d[i ].w ; • opt +=x[d[i ].i ]*d[i ].v; • } • re t urn opt ; • } 算法 k n ap s ac k 的主要 计算时间在于将各种 物品依其单位重量的 价值从⼤到⼩排序。 因此，算法的计算时 间上界为 O （ n l ogn ）。当然， 为了证明算法的正确 性，还必须证明背包 问题具有贪⼼选择性 质 。 0 第 4 章  贪⼼算法 顾名思义，贪⼼算法总是作出在当前看来最好的选 择。也就是说贪⼼算法并不从整体最优考虑，它所作 出的选择只是在某种意义上的 局部最优 选择。当然， 希望贪⼼算法得到的最终结果也是整体最优的。虽然 贪⼼算法不能对所有问题都得到整体最优解，但对许 多问题它能产⽣整体最优解。如单源最短路经问题， 最⼩⽣成树问题等。在⼀些情况下，即使贪⼼算法不 能得到整体最优解，其最终结果却是最优解的很好近 似。 0 第 4 章  贪⼼算法 • 4.1 活动安排问题 • 4.2 贪⼼算法的基本要素 • 4.3 最优装载 • 4.4 哈夫曼编码 • 4.5 单源最短路径 • 4.6 最⼩⽣成树 • 4.7 多机调度问题 • 4.8 贪⼼算法的理论基础 本章主要知识点： 0 4.1 活动安排问题 活动安排问题就是要在所给的活动集合中选出最 ⼤的相容活动⼦集合，是可以⽤贪⼼算法有效求解的 很好例⼦。该问题要求⾼效地安排⼀系列争⽤某⼀公 共资源的活动。贪⼼算法提供了⼀个简单、漂亮的⽅ 法使得尽可能多的活动能兼容地使⽤公共资源。 0 4.1 活动安排问题 设有 n 个活动的集合 E ={1,2,…,n} ，其中每个活动都要求 使⽤同⼀资源，如演讲会场等，⽽在同⼀时间内只有⼀个 活动能使⽤这⼀资源。每个活动 i 都有⼀个要求使⽤该资源 的起始时间 si 和⼀个结束时间 fi , 且 si < fi 。如果选择了活动 i ，则它在半开时间区间 [ si , fi ) 内占⽤资源。若区间 [ si , fi ) 与 区间 [ sj , fj ) 不相交，则称活动 i 与活动 j 是相容的。也就是 说，当 si ≥ fj 或 sj ≥ fi 时，活动 i 与活动 j 相容。 0 4.1 活动安排问题 • publ i c s t a t i c i nt gr e e d yS e l e c tor ( i nt [] s , i nt [] f, bool e a n a []) • { • i nt n=s .l e ngt h-1; • a [1]=t rue ; • i nt j =1; • i nt c ount =1; • for ( i nt i =2; i <=n; i ++) { • i f (s [i ]>=f[j ]) { • a [i ]=t rue ; • j =i ; • c ount ++; • } • e l s e a [i ]=fa l s e ; • } • re t urn c ount ; • } 在下⾯所给出的解活动安排问题的贪⼼算法 greedySelector : 各活动的起始时间和结束 时间存储于数组 s 和 f 中且 按结束时间的⾮减序排列 0 4.1 活动安排问题 由于输⼊的活动以其完成时间的 ⾮减序 排列，所以 算法 gr e e d yS e l e c tor 每次总是选择 具有最早完成时间 的 相容活动加⼊集合 A 中。直观上，按这种⽅法选择相 容活动为未安排活动留下尽可能多的时间。也就是 说，该算法的贪⼼选择的意义是 使剩余的可安排时间 段极⼤化 ，以便安排尽可能多的相容活动。 算法 gr e e d yS e l e c tor 的效率极⾼。当输⼊的活动已 按结束时间的⾮减序排列，算法只需 O (n ) 的时间安排 n 个活动，使最多的活动能相容地使⽤公共资源。如 果所给出的活动未按⾮减序排列，可以⽤ O( n l ogn ) 的 时间重排。 0 4.1 活动安排问题 例： 设待安排的 11 个活动的开始时间和结束时间按结 束时间的⾮减序排列如下： 1413121110987654f[i ] 122886535031S [i ] 1110987654321i 0 4.1 活动安排问题 算法 gr e e d yS e l e c tor 的计算 过程 如左图所示。图中 每⾏相应于算法的⼀次 迭代。阴影⻓条表示的 活动是已选⼊集合 A 的活 动，⽽空⽩⻓条表示的 活动是当前正在检查相 容性的活动。 0 4.1 活动安排问题 若被检查的活动 i 的开始时间 Si ⼩于最近选择的活动 j 的 结束时间 fi ，则不选择活动 i ，否则选择活动 i 加⼊集 合 A 中。 贪⼼算法并不总能求得问题的 整体最优解 。但对于 活动安排问题，贪⼼算法 gre e dyS e l e c t or 却总能求得的 整体最优解，即它最终所确定的相容活动集合 A 的规模 最⼤。这个结论可以⽤数学归纳法证明。 0 4.2 贪⼼算法的基本要素 本节着重讨论可以⽤贪⼼算法求解的问题的⼀般特 征。 对于⼀个具体的问题，怎么知道是否可⽤贪⼼算法 解此问题，以及能否得到问题的最优解呢 ? 这个问题很 难给予肯定的回答。 但是，从许多可以⽤贪⼼算法求解的问题中看到这类 问题⼀般具有 2 个重要的性质： 贪⼼选择性质 和 最优⼦ 结构性质 。 0 4.2 贪⼼算法的基本要素 1 、贪⼼选择性质 所谓 贪⼼选择性质 是指所求问题的 整体最优解 可以通 过⼀系列 局部最优 的选择，即贪⼼选择来达到。这是贪 ⼼算法可⾏的第⼀个基本要素，也是贪⼼算法与动态规 划算法的主要区别。 动态规划算法通常以 ⾃底向上 的⽅式解各⼦问题，⽽ 贪⼼算法则通常以 ⾃顶向下 的⽅式进⾏，以迭代的⽅式 作出相继的贪⼼选择，每作⼀次贪⼼选择就将所求问题 简化为规模更⼩的⼦问题。 对于⼀个具体问题，要确定它是否具有贪⼼选择性 质，必须证明每⼀步所作的贪⼼选择最终导致问题的整 体最优解。 0 4.2 贪⼼算法的基本要素 当⼀个问题的最优解包含其⼦问题的最优解时， 称此问题具有 最优⼦结构性质 。问题的最优⼦结构性 质是该问题可⽤动态规划算法或贪⼼算法求解的关键 特征。 2 、最优⼦结构性质 0 4.2 贪⼼算法的基本要素 贪⼼算法和动态规划算法都要求问题具有最优⼦结构 性质，这是 2 类算法的⼀个共同点。但是，对于具有 最 优⼦结构 的问题应该选⽤贪⼼算法还是动态规划算法 求解 ? 是否能⽤动态规划算法求解的问题也能⽤贪⼼算 法求解 ? 下⾯研究 2 个经典的 组合优化问题 ，并以此说 明贪⼼算法与动态规划算法的主要差别。 3 、贪⼼算法与动态规划算法的差异 0 4.2 贪⼼算法的基本要素 • 0-1 背包问题： 给定 n 种物品和⼀个背包。物品 i 的重量是 Wi ，其价值 为 Vi ，背包的容量为 C 。应如何选择装⼊背包的物品， 使得装⼊背包中物品的总价值最⼤ ? 在选择装⼊背包的物品时，对每种物品 i 只有 2 种选择，即装⼊背 包或不装⼊背包。不能将物品 i 装⼊背包多次，也不能只装⼊部分 的物品 i 。 0 4.2 贪⼼算法的基本要素 • 背包问题： 与 0-1 背包问题类似，所不同的是在选择物品 i 装⼊ 背包时， 可以选择物品 i 的⼀部分 ，⽽不⼀定要全部装 ⼊背包， 1 ≤ i ≤ n 。 这 2 类问题都具有 最优⼦结构 性质，极为相似，但背 包问题可以⽤贪⼼算法求解，⽽ 0-1 背包问题却不能⽤ 贪⼼算法求解。 0 4.2 贪⼼算法的基本要素 ⾸先计算每种物品单位重量的价值 Vi / Wi ，然后，依贪⼼选 择策略，将尽可能多的 单位重量价值最⾼ 的物品装⼊背包。 若将这种物品全部装⼊背包后，背包内的物品总重量未超过 C ，则选择单位重量价值次⾼的物品并尽可能多地装⼊背 包。依此策略⼀直地进⾏下去，直到背包装满为⽌。 具体算法可描述如下⻚： ⽤贪⼼算法解背包问题的基本步骤：   0 4.2 贪⼼算法的基本要素 • publ i c s t a t i c fl oa t k n ap s ac k (fl oa t c ,fl oa t [] w , fl oa t [] v ,fl oa t [] x) • { • i nt n=v .l e ngt h; • E l e m e nt [] d = ne w E l e m e nt [n]; • for ( i nt i = 0; i < n; i ++) d[i ] = ne w E l e m e nt (w [i ],v[i ],i ); • M e r ge S ort . m e r ge S ort (d); • i nt i ; • fl oa t opt =0; • for (i =0; i <n; i ++) x[i ]=0; • for (i =0; i <n; i ++) { • i f (d[i ].w >c ) bre a k; • x[d[i ].i ]=1; • opt +=d[i ].v; • c -=d[i ].w ; • } • i f (i <n){ • x[d[i ].i ]=c / d[i ].w ; • opt +=x[d[i ].i ]*d[i ].v; • } • re t urn opt ; • } 算法 k n ap s ac k 的主要 计算时间在于将各种 物品依其单位重量的 价值从⼤到⼩排序。 因此，算法的计算时 间上界为 O （ n l ogn ）。当然， 为了证明算法的正确 性，还必须证明背包 问题具有贪⼼选择性 质 。 0 第 4 章  贪⼼算法 顾名思义，贪⼼算法总是作出在当前看来最好的选 择。也就是说贪⼼算法并不从整体最优考虑，它所作 出的选择只是在某种意义上的 局部最优 选择。当然， 希望贪⼼算法得到的最终结果也是整体最优的。虽然 贪⼼算法不能对所有问题都得到整体最优解，但对许 多问题它能产⽣整体最优解。如单源最短路经问题， 最⼩⽣成树问题等。在⼀些情况下，即使贪⼼算法不 能得到整体最优解，其最终结果却是最优解的很好近 似。 0 第 4 章  贪⼼算法 • 4.1 活动安排问题 • 4.2 贪⼼算法的基本要素 • 4.3 最优装载 • 4.4 哈夫曼编码 • 4.5 单源最短路径 • 4.6 最⼩⽣成树 • 4.7 多机调度问题 • 4.8 贪⼼算法的理论基础 本章主要知识点： 0 4.1 活动安排问题 活动安排问题就是要在所给的活动集合中选出最 ⼤的相容活动⼦集合，是可以⽤贪⼼算法有效求解的 很好例⼦。该问题要求⾼效地安排⼀系列争⽤某⼀公 共资源的活动。贪⼼算法提供了⼀个简单、漂亮的⽅ 法使得尽可能多的活动能兼容地使⽤公共资源。 0 4.1 活动安排问题 设有 n 个活动的集合 E ={1,2,…,n} ，其中每个活动都要求 使⽤同⼀资源，如演讲会场等，⽽在同⼀时间内只有⼀个 活动能使⽤这⼀资源。每个活动 i 都有⼀个要求使⽤该资源 的起始时间 si 和⼀个结束时间 fi , 且 si < fi 。如果选择了活动 i ，则它在半开时间区间 [ si , fi ) 内占⽤资源。若区间 [ si , fi ) 与 区间 [ sj , fj ) 不相交，则称活动 i 与活动 j 是相容的。也就是 说，当 si ≥ fj 或 sj ≥ fi 时，活动 i 与活动 j 相容。 0 4.1 活动安排问题 • publ i c s t a t i c i nt gr e e d yS e l e c tor ( i nt [] s , i nt [] f, bool e a n a []) • { • i nt n=s .l e ngt h-1; • a [1]=t rue ; • i nt j =1; • i nt c ount =1; • for ( i nt i =2; i <=n; i ++) { • i f (s [i ]>=f[j ]) { • a [i ]=t rue ; • j =i ; • c ount ++; • } • e l s e a [i ]=fa l s e ; • } • re t urn c ount ; • } 在下⾯所给出的解活动安排问题的贪⼼算法 greedySelector : 各活动的起始时间和结束 时间存储于数组 s 和 f 中且 按结束时间的⾮减序排列 0 4.1 活动安排问题 由于输⼊的活动以其完成时间的 ⾮减序 排列，所以 算法 gr e e d yS e l e c tor 每次总是选择 具有最早完成时间 的 相容活动加⼊集合 A 中。直观上，按这种⽅法选择相 容活动为未安排活动留下尽可能多的时间。也就是 说，该算法的贪⼼选择的意义是 使剩余的可安排时间 段极⼤化 ，以便安排尽可能多的相容活动。 算法 gr e e d yS e l e c tor 的效率极⾼。当输⼊的活动已 按结束时间的⾮减序排列，算法只需 O (n ) 的时间安排 n 个活动，使最多的活动能相容地使⽤公共资源。如 果所给出的活动未按⾮减序排列，可以⽤ O( n l ogn ) 的 时间重排。 0 4.1 活动安排问题 例： 设待安排的 11 个活动的开始时间和结束时间按结 束时间的⾮减序排列如下： 1413121110987654f[i ] 122886535031S [i ] 1110987654321i 0 4.1 活动安排问题 算法 gr e e d yS e l e c tor 的计算 过程 如左图所示。图中 每⾏相应于算法的⼀次 迭代。阴影⻓条表示的 活动是已选⼊集合 A 的活 动，⽽空⽩⻓条表示的 活动是当前正在检查相 容性的活动。 0 4.1 活动安排问题 若被检查的活动 i 的开始时间 Si ⼩于最近选择的活动 j 的 结束时间 fi ，则不选择活动 i ，否则选择活动 i 加⼊集 合 A 中。 贪⼼算法并不总能求得问题的 整体最优解 。但对于 活动安排问题，贪⼼算法 gre e dyS e l e c t or 却总能求得的 整体最优解，即它最终所确定的相容活动集合 A 的规模 最⼤。这个结论可以⽤数学归纳法证明。 0 4.2 贪⼼算法的基本要素 本节着重讨论可以⽤贪⼼算法求解的问题的⼀般特 征。 对于⼀个具体的问题，怎么知道是否可⽤贪⼼算法 解此问题，以及能否得到问题的最优解呢 ? 这个问题很 难给予肯定的回答。 但是，从许多可以⽤贪⼼算法求解的问题中看到这类 问题⼀般具有 2 个重要的性质： 贪⼼选择性质 和 最优⼦ 结构性质 。 0 4.2 贪⼼算法的基本要素 1 、贪⼼选择性质 所谓 贪⼼选择性质 是指所求问题的 整体最优解 可以通 过⼀系列 局部最优 的选择，即贪⼼选择来达到。这是贪 ⼼算法可⾏的第⼀个基本要素，也是贪⼼算法与动态规 划算法的主要区别。 动态规划算法通常以 ⾃底向上 的⽅式解各⼦问题，⽽ 贪⼼算法则通常以 ⾃顶向下 的⽅式进⾏，以迭代的⽅式 作出相继的贪⼼选择，每作⼀次贪⼼选择就将所求问题 简化为规模更⼩的⼦问题。 对于⼀个具体问题，要确定它是否具有贪⼼选择性 质，必须证明每⼀步所作的贪⼼选择最终导致问题的整 体最优解。 0 4.2 贪⼼算法的基本要素 当⼀个问题的最优解包含其⼦问题的最优解时， 称此问题具有 最优⼦结构性质 。问题的最优⼦结构性 质是该问题可⽤动态规划算法或贪⼼算法求解的关键 特征。 2 、最优⼦结构性质 0 4.2 贪⼼算法的基本要素 贪⼼算法和动态规划算法都要求问题具有最优⼦结构 性质，这是 2 类算法的⼀个共同点。但是，对于具有 最 优⼦结构 的问题应该选⽤贪⼼算法还是动态规划算法 求解 ? 是否能⽤动态规划算法求解的问题也能⽤贪⼼算 法求解 ? 下⾯研究 2 个经典的 组合优化问题 ，并以此说 明贪⼼算法与动态规划算法的主要差别。 3 、贪⼼算法与动态规划算法的差异 0 4.2 贪⼼算法的基本要素 • 0-1 背包问题： 给定 n 种物品和⼀个背包。物品 i 的重量是 Wi ，其价值 为 Vi ，背包的容量为 C 。应如何选择装⼊背包的物品， 使得装⼊背包中物品的总价值最⼤ ? 在选择装⼊背包的物品时，对每种物品 i 只有 2 种选择，即装⼊背 包或不装⼊背包。不能将物品 i 装⼊背包多次，也不能只装⼊部分 的物品 i 。 0 4.2 贪⼼算法的基本要素 • 背包问题： 与 0-1 背包问题类似，所不同的是在选择物品 i 装⼊ 背包时， 可以选择物品 i 的⼀部分 ，⽽不⼀定要全部装 ⼊背包， 1 ≤ i ≤ n 。 这 2 类问题都具有 最优⼦结构 性质，极为相似，但背 包问题可以⽤贪⼼算法求解，⽽ 0-1 背包问题却不能⽤ 贪⼼算法求解。 0 4.2 贪⼼算法的基本要素 ⾸先计算每种物品单位重量的价值 Vi / Wi ，然后，依贪⼼选 择策略，将尽可能多的 单位重量价值最⾼ 的物品装⼊背包。 若将这种物品全部装⼊背包后，背包内的物品总重量未超过 C ，则选择单位重量价值次⾼的物品并尽可能多地装⼊背 包。依此策略⼀直地进⾏下去，直到背包装满为⽌。 具体算法可描述如下⻚： ⽤贪⼼算法解背包问题的基本步骤：   0 4.2 贪⼼算法的基本要素 • publ i c s t a t i c fl oa t k n ap s ac k (fl oa t c ,fl oa t [] w , fl oa t [] v ,fl oa t [] x) • { • i nt n=v .l e ngt h; • E l e m e nt [] d = ne w E l e m e nt [n]; • for ( i nt i = 0; i < n; i ++) d[i ] = ne w E l e m e nt (w [i ],v[i ],i ); • M e r ge S ort . m e r ge S ort (d); • i nt i ; • fl oa t opt =0; • for (i =0; i <n; i ++) x[i ]=0; • for (i =0; i <n; i ++) { • i f (d[i ].w >c ) bre a k; • x[d[i ].i ]=1; • opt +=d[i ].v; • c -=d[i ].w ; • } • i f (i <n){ • x[d[i ].i ]=c / d[i ].w ; • opt +=x[d[i ].i ]*d[i ].v; • } • re t urn opt ; • } 算法 k n ap s ac k 的主要 计算时间在于将各种 物品依其单位重量的 价值从⼤到⼩排序。 因此，算法的计算时 间上界为 O （ n l ogn ）。当然， 为了证明算法的正确 性，还必须证明背包 问题具有贪⼼选择性 质 。 0 第 4 章  贪⼼算法 顾名思义，贪⼼算法总是作出在当前看来最好的选 择。也就是说贪⼼算法并不从整体最优考虑，它所作 出的选择只是在某种意义上的 局部最优 选择。当然， 希望贪⼼算法得到的最终结果也是整体最优的。虽然 贪⼼算法不能对所有问题都得到整体最优解，但对许 多问题它能产⽣整体最优解。如单源最短路经问题， 最⼩⽣成树问题等。在⼀些情况下，即使贪⼼算法不 能得到整体最优解，其最终结果却是最优解的很好近 似。 0 第 4 章  贪⼼算法 • 4.1 活动安排问题 • 4.2 贪⼼算法的基本要素 • 4.3 最优装载 • 4.4 哈夫曼编码 • 4.5 单源最短路径 • 4.6 最⼩⽣成树 • 4.7 多机调度问题 • 4.8 贪⼼算法的理论基础 本章主要知识点： 0 4.1 活动安排问题 活动安排问题就是要在所给的活动集合中选出最 ⼤的相容活动⼦集合，是可以⽤贪⼼算法有效求解的 很好例⼦。该问题要求⾼效地安排⼀系列争⽤某⼀公 共资源的活动。贪⼼算法提供了⼀个简单、漂亮的⽅ 法使得尽可能多的活动能兼容地使⽤公共资源。 0 4.1 活动安排问题 设有 n 个活动的集合 E ={1,2,…,n} ，其中每个活动都要求 使⽤同⼀资源，如演讲会场等，⽽在同⼀时间内只有⼀个 活动能使⽤这⼀资源。每个活动 i 都有⼀个要求使⽤该资源 的起始时间 si 和⼀个结束时间 fi , 且 si < fi 。如果选择了活动 i ，则它在半开时间区间 [ si , fi ) 内占⽤资源。若区间 [ si , fi ) 与 区间 [ sj , fj ) 不相交，则称活动 i 与活动 j 是相容的。也就是 说，当 si ≥ fj 或 sj ≥ fi 时，活动 i 与活动 j 相容。 0 4.1 活动安排问题 • publ i c s t a t i c i nt gr e e d yS e l e c tor ( i nt [] s , i nt [] f, bool e a n a []) • { • i nt n=s .l e ngt h-1; • a [1]=t rue ; • i nt j =1; • i nt c ount =1; • for ( i nt i =2; i <=n; i ++) { • i f (s [i ]>=f[j ]) { • a [i ]=t rue ; • j =i ; • c ount ++; • } • e l s e a [i ]=fa l s e ; • } • re t urn c ount ; • } 在下⾯所给出的解活动安排问题的贪⼼算法 greedySelector : 各活动的起始时间和结束 时间存储于数组 s 和 f 中且 按结束时间的⾮减序排列 0 4.1 活动安排问题 由于输⼊的活动以其完成时间的 ⾮减序 排列，所以 算法 gr e e d yS e l e c tor 每次总是选择 具有最早完成时间 的 相容活动加⼊集合 A 中。直观上，按这种⽅法选择相 容活动为未安排活动留下尽可能多的时间。也就是 说，该算法的贪⼼选择的意义是 使剩余的可安排时间 段极⼤化 ，以便安排尽可能多的相容活动。 算法 gr e e d yS e l e c tor 的效率极⾼。当输⼊的活动已 按结束时间的⾮减序排列，算法只需 O (n ) 的时间安排 n 个活动，使最多的活动能相容地使⽤公共资源。如 果所给出的活动未按⾮减序排列，可以⽤ O( n l ogn ) 的 时间重排。 0 4.1 活动安排问题 例： 设待安排的 11 个活动的开始时间和结束时间按结 束时间的⾮减序排列如下： 1413121110987654f[i ] 122886535031S [i ] 1110987654321i 0 4.1 活动安排问题 算法 gr e e d yS e l e c tor 的计算 过程 如左图所示。图中 每⾏相应于算法的⼀次 迭代。阴影⻓条表示的 活动是已选⼊集合 A 的活 动，⽽空⽩⻓条表示的 活动是当前正在检查相 容性的活动。 0 4.1 活动安排问题 若被检查的活动 i 的开始时间 Si ⼩于最近选择的活动 j 的 结束时间 fi ，则不选择活动 i ，否则选择活动 i 加⼊集 合 A 中。 贪⼼算法并不总能求得问题的 整体最优解 。但对于 活动安排问题，贪⼼算法 gre e dyS e l e c t or 却总能求得的 整体最优解，即它最终所确定的相容活动集合 A 的规模 最⼤。这个结论可以⽤数学归纳法证明。 0 4.2 贪⼼算法的基本要素 本节着重讨论可以⽤贪⼼算法求解的问题的⼀般特 征。 对于⼀个具体的问题，怎么知道是否可⽤贪⼼算法 解此问题，以及能否得到问题的最优解呢 ? 这个问题很 难给予肯定的回答。 但是，从许多可以⽤贪⼼算法求解的问题中看到这类 问题⼀般具有 2 个重要的性质： 贪⼼选择性质 和 最优⼦ 结构性质 。 0 4.2 贪⼼算法的基本要素 1 、贪⼼选择性质 所谓 贪⼼选择性质 是指所求问题的 整体最优解 可以通 过⼀系列 局部最优 的选择，即贪⼼选择来达到。这是贪 ⼼算法可⾏的第⼀个基本要素，也是贪⼼算法与动态规 划算法的主要区别。 动态规划算法通常以 ⾃底向上 的⽅式解各⼦问题，⽽ 贪⼼算法则通常以 ⾃顶向下 的⽅式进⾏，以迭代的⽅式 作出相继的贪⼼选择，每作⼀次贪⼼选择就将所求问题 简化为规模更⼩的⼦问题。 对于⼀个具体问题，要确定它是否具有贪⼼选择性 质，必须证明每⼀步所作的贪⼼选择最终导致问题的整 体最优解。 0 4.2 贪⼼算法的基本要素 当⼀个问题的最优解包含其⼦问题的最优解时， 称此问题具有 最优⼦结构性质 。问题的最优⼦结构性 质是该问题可⽤动态规划算法或贪⼼算法求解的关键 特征。 2 、最优⼦结构性质 0 4.2 贪⼼算法的基本要素 贪⼼算法和动态规划算法都要求问题具有最优⼦结构 性质，这是 2 类算法的⼀个共同点。但是，对于具有 最 优⼦结构 的问题应该选⽤贪⼼算法还是动态规划算法 求解 ? 是否能⽤动态规划算法求解的问题也能⽤贪⼼算 法求解 ? 下⾯研究 2 个经典的 组合优化问题 ，并以此说 明贪⼼算法与动态规划算法的主要差别。 3 、贪⼼算法与动态规划算法的差异 0 4.2 贪⼼算法的基本要素 • 0-1 背包问题： 给定 n 种物品和⼀个背包。物品 i 的重量是 Wi ，其价值 为 Vi ，背包的容量为 C 。应如何选择装⼊背包的物品， 使得装⼊背包中物品的总价值最⼤ ? 在选择装⼊背包的物品时，对每种物品 i 只有 2 种选择，即装⼊背 包或不装⼊背包。不能将物品 i 装⼊背包多次，也不能只装⼊部分 的物品 i 。 0 4.2 贪⼼算法的基本要素 • 背包问题： 与 0-1 背包问题类似，所不同的是在选择物品 i 装⼊ 背包时， 可以选择物品 i 的⼀部分 ，⽽不⼀定要全部装 ⼊背包， 1 ≤ i ≤ n 。 这 2 类问题都具有 最优⼦结构 性质，极为相似，但背 包问题可以⽤贪⼼算法求解，⽽ 0-1 背包问题却不能⽤ 贪⼼算法求解。 0 4.2 贪⼼算法的基本要素 ⾸先计算每种物品单位重量的价值 Vi / Wi ，然后，依贪⼼选 择策略，将尽可能多的 单位重量价值最⾼ 的物品装⼊背包。 若将这种物品全部装⼊背包后，背包内的物品总重量未超过 C ，则选择单位重量价值次⾼的物品并尽可能多地装⼊背 包。依此策略⼀直地进⾏下去，直到背包装满为⽌。 具体算法可描述如下⻚： ⽤贪⼼算法解背包问题的基本步骤：   0 4.2 贪⼼算法的基本要素 • publ i c s t a t i c fl oa t k n ap s ac k (fl oa t c ,fl oa t [] w , fl oa t [] v ,fl oa t [] x) • { • i nt n=v .l e ngt h; • E l e m e nt [] d = ne w E l e m e nt [n]; • for ( i nt i = 0; i < n; i ++) d[i ] = ne w E l e m e nt (w [i ],v[i ],i ); • M e r ge S ort . m e r ge S ort (d); • i nt i ; • fl oa t opt =0; • for (i =0; i <n; i ++) x[i ]=0; • for (i =0; i <n; i ++) { • i f (d[i ].w >c ) bre a k; • x[d[i ].i ]=1; • opt +=d[i ].v; • c -=d[i ].w ; • } • i f (i <n){ • x[d[i ].i ]=c / d[i ].w ; • opt +=x[d[i ].i ]*d[i ].v; • } • re t urn opt ; • } 算法 k n ap s ac k 的主要 计算时间在于将各种 物品依其单位重量的 价值从⼤到⼩排序。 因此，算法的计算时 间上界为 O （ n l ogn ）。当然， 为了证明算法的正确 性，还必须证明背包 问题具有贪⼼选择性 质 。 0 第 4 章  贪⼼算法 顾名思义，贪⼼算法总是作出在当前看来最好的选 择。也就是说贪⼼算法并不从整体最优考虑，它所作 出的选择只是在某种意义上的 局部最优 选择。当然， 希望贪⼼算法得到的最终结果也是整体最优的。虽然 贪⼼算法不能对所有问题都得到整体最优解，但对许 多问题它能产⽣整体最优解。如单源最短路经问题， 最⼩⽣成树问题等。在⼀些情况下，即使贪⼼算法不 能得到整体最优解，其最终结果却是最优解的很好近 似。 0 第 4 章  贪⼼算法 • 4.1 活动安排问题 • 4.2 贪⼼算法的基本要素 • 4.3 最优装载 • 4.4 哈夫曼编码 • 4.5 单源最短路径 • 4.6 最⼩⽣成树 • 4.7 多机调度问题 • 4.8 贪⼼算法的理论基础 本章主要知识点： 0 4.1 活动安排问题 活动安排问题就是要在所给的活动集合中选出最 ⼤的相容活动⼦集合，是可以⽤贪⼼算法有效求解的 很好例⼦。该问题要求⾼效地安排⼀系列争⽤某⼀公 共资源的活动。贪⼼算法提供了⼀个简单、漂亮的⽅ 法使得尽可能多的活动能兼容地使⽤公共资源。 0 4.1 活动安排问题 设有 n 个活动的集合 E ={1,2,…,n} ，其中每个活动都要求 使⽤同⼀资源，如演讲会场等，⽽在同⼀时间内只有⼀个 活动能使⽤这⼀资源。每个活动 i 都有⼀个要求使⽤该资源 的起始时间 si 和⼀个结束时间 fi , 且 si < fi 。如果选择了活动 i ，则它在半开时间区间 [ si , fi ) 内占⽤资源。若区间 [ si , fi ) 与 区间 [ sj , fj ) 不相交，则称活动 i 与活动 j 是相容的。也就是 说，当 si ≥ fj 或 sj ≥ fi 时，活动 i 与活动 j 相容。 0 4.1 活动安排问题 • publ i c s t a t i c i nt gr e e d yS e l e c tor ( i nt [] s , i nt [] f, bool e a n a []) • { • i nt n=s .l e ngt h-1; • a [1]=t rue ; • i nt j =1; • i nt c ount =1; • for ( i nt i =2; i <=n; i ++) { • i f (s [i ]>=f[j ]) { • a [i ]=t rue ; • j =i ; • c ount ++; • } • e l s e a [i ]=fa l s e ; • } • re t urn c ount ; • } 在下⾯所给出的解活动安排问题的贪⼼算法 greedySelector : 各活动的起始时间和结束 时间存储于数组 s 和 f 中且 按结束时间的⾮减序排列 0 4.1 活动安排问题 由于输⼊的活动以其完成时间的 ⾮减序 排列，所以 算法 gr e e d yS e l e c tor 每次总是选择 具有最早完成时间 的 相容活动加⼊集合 A 中。直观上，按这种⽅法选择相 容活动为未安排活动留下尽可能多的时间。也就是 说，该算法的贪⼼选择的意义是 使剩余的可安排时间 段极⼤化 ，以便安排尽可能多的相容活动。 算法 gr e e d yS e l e c tor 的效率极⾼。当输⼊的活动已 按结束时间的⾮减序排列，算法只需 O (n ) 的时间安排 n 个活动，使最多的活动能相容地使⽤公共资源。如 果所给出的活动未按⾮减序排列，可以⽤ O( n l ogn ) 的 时间重排。 0 4.1 活动安排问题 例： 设待安排的 11 个活动的开始时间和结束时间按结 束时间的⾮减序排列如下： 1413121110987654f[i ] 122886535031S [i ] 1110987654321i 0 4.1 活动安排问题 算法 gr e e d yS e l e c tor 的计算 过程 如左图所示。图中 每⾏相应于算法的⼀次 迭代。阴影⻓条表示的 活动是已选⼊集合 A 的活 动，⽽空⽩⻓条表示的 活动是当前正在检查相 容性的活动。 0 4.1 活动安排问题 若被检查的活动 i 的开始时间 Si ⼩于最近选择的活动 j 的 结束时间 fi ，则不选择活动 i ，否则选择活动 i 加⼊集 合 A 中。 贪⼼算法并不总能求得问题的 整体最优解 。但对于 活动安排问题，贪⼼算法 gre e dyS e l e c t or 却总能求得的 整体最优解，即它最终所确定的相容活动集合 A 的规模 最⼤。这个结论可以⽤数学归纳法证明。 0 4.2 贪⼼算法的基本要素 本节着重讨论可以⽤贪⼼算法求解的问题的⼀般特 征。 对于⼀个具体的问题，怎么知道是否可⽤贪⼼算法 解此问题，以及能否得到问题的最优解呢 ? 这个问题很 难给予肯定的回答。 但是，从许多可以⽤贪⼼算法求解的问题中看到这类 问题⼀般具有 2 个重要的性质： 贪⼼选择性质 和 最优⼦ 结构性质 。 0 4.2 贪⼼算法的基本要素 1 、贪⼼选择性质 所谓 贪⼼选择性质 是指所求问题的 整体最优解 可以通 过⼀系列 局部最优 的选择，即贪⼼选择来达到。这是贪 ⼼算法可⾏的第⼀个基本要素，也是贪⼼算法与动态规 划算法的主要区别。 动态规划算法通常以 ⾃底向上 的⽅式解各⼦问题，⽽ 贪⼼算法则通常以 ⾃顶向下 的⽅式进⾏，以迭代的⽅式 作出相继的贪⼼选择，每作⼀次贪⼼选择就将所求问题 简化为规模更⼩的⼦问题。 对于⼀个具体问题，要确定它是否具有贪⼼选择性 质，必须证明每⼀步所作的贪⼼选择最终导致问题的整 体最优解。 0 4.2 贪⼼算法的基本要素 当⼀个问题的最优解包含其⼦问题的最优解时， 称此问题具有 最优⼦结构性质 。问题的最优⼦结构性 质是该问题可⽤动态规划算法或贪⼼算法求解的关键 特征。 2 、最优⼦结构性质 0 4.2 贪⼼算法的基本要素 贪⼼算法和动态规划算法都要求问题具有最优⼦结构 性质，这是 2 类算法的⼀个共同点。但是，对于具有 最 优⼦结构 的问题应该选⽤贪⼼算法还是动态规划算法 求解 ? 是否能⽤动态规划算法求解的问题也能⽤贪⼼算 法求解 ? 下⾯研究 2 个经典的 组合优化问题 ，并以此说 明贪⼼算法与动态规划算法的主要差别。 3 、贪⼼算法与动态规划算法的差异 0 4.2 贪⼼算法的基本要素 • 0-1 背包问题： 给定 n 种物品和⼀个背包。物品 i 的重量是 Wi ，其价值 为 Vi ，背包的容量为 C 。应如何选择装⼊背包的物品， 使得装⼊背包中物品的总价值最⼤ ? 在选择装⼊背包的物品时，对每种物品 i 只有 2 种选择，即装⼊背 包或不装⼊背包。不能将物品 i 装⼊背包多次，也不能只装⼊部分 的物品 i 。 0 4.2 贪⼼算法的基本要素 • 背包问题： 与 0-1 背包问题类似，所不同的是在选择物品 i 装⼊ 背包时， 可以选择物品 i 的⼀部分 ，⽽不⼀定要全部装 ⼊背包， 1 ≤ i ≤ n 。 这 2 类问题都具有 最优⼦结构 性质，极为相似，但背 包问题可以⽤贪⼼算法求解，⽽ 0-1 背包问题却不能⽤ 贪⼼算法求解。 0 4.2 贪⼼算法的基本要素 ⾸先计算每种物品单位重量的价值 Vi / Wi ，然后，依贪⼼选 择策略，将尽可能多的 单位重量价值最⾼ 的物品装⼊背包。 若将这种物品全部装⼊背包后，背包内的物品总重量未超过 C ，则选择单位重量价值次⾼的物品并尽可能多地装⼊背 包。依此策略⼀直地进⾏下去，直到背包装满为⽌。 具体算法可描述如下⻚： ⽤贪⼼算法解背包问题的基本步骤：   0 4.2 贪⼼算法的基本要素 • publ i c s t a t i c fl oa t k n ap s ac k (fl oa t c ,fl oa t [] w , fl oa t [] v ,fl oa t [] x) • { • i nt n=v .l e ngt h; • E l e m e nt [] d = ne w E l e m e nt [n]; • for ( i nt i = 0; i < n; i ++) d[i ] = ne w E l e m e nt (w [i ],v[i ],i ); • M e r ge S ort . m e r ge S ort (d); • i nt i ; • fl oa t opt =0; • for (i =0; i <n; i ++) x[i ]=0; • for (i =0; i <n; i ++) { • i f (d[i ].w >c ) bre a k; • x[d[i ].i ]=1; • opt +=d[i ].v; • c -=d[i ].w ; • } • i f (i <n){ • x[d[i ].i ]=c / d[i ].w ; • opt +=x[d[i ].i ]*d[i ].v; • } • re t urn opt ; • } 算法 k n ap s ac k 的主要 计算时间在于将各种 物品依其单位重量的 价值从⼤到⼩排序。 因此，算法的计算时 间上界为 O （ n l ogn ）。当然， 为了证明算法的正确 性，还必须证明背包 问题具有贪⼼选择性 质 。 0 第 4 章  贪⼼算法 顾名思义，贪⼼算法总是作出在当前看来最好的选 择。也就是说贪⼼算法并不从整体最优考虑，它所作 出的选择只是在某种意义上的 局部最优 选择。当然， 希望贪⼼算法得到的最终结果也是整体最优的。虽然 贪⼼算法不能对所有问题都得到整体最优解，但对许 多问题它能产⽣整体最优解。如单源最短路经问题， 最⼩⽣成树问题等。在⼀些情况下，即使贪⼼算法不 能得到整体最优解，其最终结果却是最优解的很好近 似。 0 第 4 章  贪⼼算法 • 4.1 活动安排问题 • 4.2 贪⼼算法的基本要素 • 4.3 最优装载 • 4.4 哈夫曼编码 • 4.5 单源最短路径 • 4.6 最⼩⽣成树 • 4.7 多机调度问题 • 4.8 贪⼼算法的理论基础 本章主要知识点： 0 4.1 活动安排问题 活动安排问题就是要在所给的活动集合中选出最 ⼤的相容活动⼦集合，是可以⽤贪⼼算法有效求解的 很好例⼦。该问题要求⾼效地安排⼀系列争⽤某⼀公 共资源的活动。贪⼼算法提供了⼀个简单、漂亮的⽅ 法使得尽可能多的活动能兼容地使⽤公共资源。 0 4.1 活动安排问题 设有 n 个活动的集合 E ={1,2,…,n} ，其中每个活动都要求 使⽤同⼀资源，如演讲会场等，⽽在同⼀时间内只有⼀个 活动能使⽤这⼀资源。每个活动 i 都有⼀个要求使⽤该资源 的起始时间 si 和⼀个结束时间 fi , 且 si < fi 。如果选择了活动 i ，则它在半开时间区间 [ si , fi ) 内占⽤资源。若区间 [ si , fi ) 与 区间 [ sj , fj ) 不相交，则称活动 i 与活动 j 是相容的。也就是 说，当 si ≥ fj 或 sj ≥ fi 时，活动 i 与活动 j 相容。 0 4.1 活动安排问题 • publ i c s t a t i c i nt gr e e d yS e l e c tor ( i nt [] s , i nt [] f, bool e a n a []) • { • i nt n=s .l e ngt h-1; • a [1]=t rue ; • i nt j =1; • i nt c ount =1; • for ( i nt i =2; i <=n; i ++) { • i f (s [i ]>=f[j ]) { • a [i ]=t rue ; • j =i ; • c ount ++; • } • e l s e a [i ]=fa l s e ; • } • re t urn c ount ; • } 在下⾯所给出的解活动安排问题的贪⼼算法 greedySelector : 各活动的起始时间和结束 时间存储于数组 s 和 f 中且 按结束时间的⾮减序排列 0 4.1 活动安排问题 由于输⼊的活动以其完成时间的 ⾮减序 排列，所以 算法 gr e e d yS e l e c tor 每次总是选择 具有最早完成时间 的 相容活动加⼊集合 A 中。直观上，按这种⽅法选择相 容活动为未安排活动留下尽可能多的时间。也就是 说，该算法的贪⼼选择的意义是 使剩余的可安排时间 段极⼤化 ，以便安排尽可能多的相容活动。 算法 gr e e d yS e l e c tor 的效率极⾼。当输⼊的活动已 按结束时间的⾮减序排列，算法只需 O (n ) 的时间安排 n 个活动，使最多的活动能相容地使⽤公共资源。如 果所给出的活动未按⾮减序排列，可以⽤ O( n l ogn ) 的 时间重排。 0 4.1 活动安排问题 例： 设待安排的 11 个活动的开始时间和结束时间按结 束时间的⾮减序排列如下： 1413121110987654f[i ] 122886535031S [i ] 1110987654321i 0 4.1 活动安排问题 算法 gr e e d yS e l e c tor 的计算 过程 如左图所示。图中 每⾏相应于算法的⼀次 迭代。阴影⻓条表示的 活动是已选⼊集合 A 的活 动，⽽空⽩⻓条表示的 活动是当前正在检查相 容性的活动。 0 4.1 活动安排问题 若被检查的活动 i 的开始时间 Si ⼩于最近选择的活动 j 的 结束时间 fi ，则不选择活动 i ，否则选择活动 i 加⼊集 合 A 中。 贪⼼算法并不总能求得问题的 整体最优解 。但对于 活动安排问题，贪⼼算法 gre e dyS e l e c t or 却总能求得的 整体最优解，即它最终所确定的相容活动集合 A 的规模 最⼤。这个结论可以⽤数学归纳法证明。 0 4.2 贪⼼算法的基本要素 本节着重讨论可以⽤贪⼼算法求解的问题的⼀般特 征。 对于⼀个具体的问题，怎么知道是否可⽤贪⼼算法 解此问题，以及能否得到问题的最优解呢 ? 这个问题很 难给予肯定的回答。 但是，从许多可以⽤贪⼼算法求解的问题中看到这类 问题⼀般具有 2 个重要的性质： 贪⼼选择性质 和 最优⼦ 结构性质 。 0 4.2 贪⼼算法的基本要素 1 、贪⼼选择性质 所谓 贪⼼选择性质 是指所求问题的 整体最优解 可以通 过⼀系列 局部最优 的选择，即贪⼼选择来达到。这是贪 ⼼算法可⾏的第⼀个基本要素，也是贪⼼算法与动态规 划算法的主要区别。 动态规划算法通常以 ⾃底向上 的⽅式解各⼦问题，⽽ 贪⼼算法则通常以 ⾃顶向下 的⽅式进⾏，以迭代的⽅式 作出相继的贪⼼选择，每作⼀次贪⼼选择就将所求问题 简化为规模更⼩的⼦问题。 对于⼀个具体问题，要确定它是否具有贪⼼选择性 质，必须证明每⼀步所作的贪⼼选择最终导致问题的整 体最优解。 0 4.2 贪⼼算法的基本要素 当⼀个问题的最优解包含其⼦问题的最优解时， 称此问题具有 最优⼦结构性质 。问题的最优⼦结构性 质是该问题可⽤动态规划算法或贪⼼算法求解的关键 特征。 2 、最优⼦结构性质 0 4.2 贪⼼算法的基本要素 贪⼼算法和动态规划算法都要求问题具有最优⼦结构 性质，这是 2 类算法的⼀个共同点。但是，对于具有 最 优⼦结构 的问题应该选⽤贪⼼算法还是动态规划算法 求解 ? 是否能⽤动态规划算法求解的问题也能⽤贪⼼算 法求解 ? 下⾯研究 2 个经典的 组合优化问题 ，并以此说 明贪⼼算法与动态规划算法的主要差别。 3 、贪⼼算法与动态规划算法的差异 0 4.2 贪⼼算法的基本要素 • 0-1 背包问题： 给定 n 种物品和⼀个背包。物品 i 的重量是 Wi ，其价值 为 Vi ，背包的容量为 C 。应如何选择装⼊背包的物品， 使得装⼊背包中物品的总价值最⼤ ? 在选择装⼊背包的物品时，对每种物品 i 只有 2 种选择，即装⼊背 包或不装⼊背包。不能将物品 i 装⼊背包多次，也不能只装⼊部分 的物品 i 。 0 4.2 贪⼼算法的基本要素 • 背包问题： 与 0-1 背包问题类似，所不同的是在选择物品 i 装⼊ 背包时， 可以选择物品 i 的⼀部分 ，⽽不⼀定要全部装 ⼊背包， 1 ≤ i ≤ n 。 这 2 类问题都具有 最优⼦结构 性质，极为相似，但背 包问题可以⽤贪⼼算法求解，⽽ 0-1 背包问题却不能⽤ 贪⼼算法求解。 0 4.2 贪⼼算法的基本要素 ⾸先计算每种物品单位重量的价值 Vi / Wi ，然后，依贪⼼选 择策略，将尽可能多的 单位重量价值最⾼ 的物品装⼊背包。 若将这种物品全部装⼊背包后，背包内的物品总重量未超过 C ，则选择单位重量价值次⾼的物品并尽可能多地装⼊背 包。依此策略⼀直地进⾏下去，直到背包装满为⽌。 具体算法可描述如下⻚： ⽤贪⼼算法解背包问题的基本步骤：   0 4.2 贪⼼算法的基本要素 • publ i c s t a t i c fl oa t k n ap s ac k (fl oa t c ,fl oa t [] w , fl oa t [] v ,fl oa t [] x) • { • i nt n=v .l e ngt h; • E l e m e nt [] d = ne w E l e m e nt [n]; • for ( i nt i = 0; i < n; i ++) d[i ] = ne w E l e m e nt (w [i ],v[i ],i ); • M e r ge S ort . m e r ge S ort (d); • i nt i ; • fl oa t opt =0; • for (i =0; i <n; i ++) x[i ]=0; • for (i =0; i <n; i ++) { • i f (d[i ].w >c ) bre a k; • x[d[i ].i ]=1; • opt +=d[i ].v; • c -=d[i ].w ; • } • i f (i <n){ • x[d[i ].i ]=c / d[i ].w ; • opt +=x[d[i ].i ]*d[i ].v; • } • re t urn opt ; • } 算法 k n ap s ac k 的主要 计算时间在于将各种 物品依其单位重量的 价值从⼤到⼩排序。 因此，算法的计算时 间上界为 O （ n l ogn ）。当然， 为了证明算法的正确 性，还必须证明背包 问题具有贪⼼选择性 质 。 0 第 4 章  贪⼼算法 顾名思义，贪⼼算法总是作出在当前看来最好的选 择。也就是说贪⼼算法并不从整体最优考虑，它所作 出的选择只是在某种意义上的 局部最优 选择。当然， 希望贪⼼算法得到的最终结果也是整体最优的。虽然 贪⼼算法不能对所有问题都得到整体最优解，但对许 多问题它能产⽣整体最优解。如单源最短路经问题， 最⼩⽣成树问题等。在⼀些情况下，即使贪⼼算法不 能得到整体最优解，其最终结果却是最优解的很好近 似。 0 第 4 章  贪⼼算法 • 4.1 活动安排问题 • 4.2 贪⼼算法的基本要素 • 4.3 最优装载 • 4.4 哈夫曼编码 • 4.5 单源最短路径 • 4.6 最⼩⽣成树 • 4.7 多机调度问题 • 4.8 贪⼼算法的理论基础 本章主要知识点： 0 4.1 活动安排问题 活动安排问题就是要在所给的活动集合中选出最 ⼤的相容活动⼦集合，是可以⽤贪⼼算法有效求解的 很好例⼦。该问题要求⾼效地安排⼀系列争⽤某⼀公 共资源的活动。贪⼼算法提供了⼀个简单、漂亮的⽅ 法使得尽可能多的活动能兼容地使⽤公共资源。 0 4.1 活动安排问题 设有 n 个活动的集合 E ={1,2,…,n} ，其中每个活动都要求 使⽤同⼀资源，如演讲会场等，⽽在同⼀时间内只有⼀个 活动能使⽤这⼀资源。每个活动 i 都有⼀个要求使⽤该资源 的起始时间 si 和⼀个结束时间 fi , 且 si < fi 。如果选择了活动 i ，则它在半开时间区间 [ si , fi ) 内占⽤资源。若区间 [ si , fi ) 与 区间 [ sj , fj ) 不相交，则称活动 i 与活动 j 是相容的。也就是 说，当 si ≥ fj 或 sj ≥ fi 时，活动 i 与活动 j 相容。 0 4.1 活动安排问题 • publ i c s t a t i c i nt gr e e d yS e l e c tor ( i nt [] s , i nt [] f, bool e a n a []) • { • i nt n=s .l e ngt h-1; • a [1]=t rue ; • i nt j =1; • i nt c ount =1; • for ( i nt i =2; i <=n; i ++) { • i f (s [i ]>=f[j ]) { • a [i ]=t rue ; • j =i ; • c ount ++; • } • e l s e a [i ]=fa l s e ; • } • re t urn c ount ; • } 在下⾯所给出的解活动安排问题的贪⼼算法 greedySelector : 各活动的起始时间和结束 时间存储于数组 s 和 f 中且 按结束时间的⾮减序排列 0 4.1 活动安排问题 由于输⼊的活动以其完成时间的 ⾮减序 排列，所以 算法 gr e e d yS e l e c tor 每次总是选择 具有最早完成时间 的 相容活动加⼊集合 A 中。直观上，按这种⽅法选择相 容活动为未安排活动留下尽可能多的时间。也就是 说，该算法的贪⼼选择的意义是 使剩余的可安排时间 段极⼤化 ，以便安排尽可能多的相容活动。 算法 gr e e d yS e l e c tor 的效率极⾼。当输⼊的活动已 按结束时间的⾮减序排列，算法只需 O (n ) 的时间安排 n 个活动，使最多的活动能相容地使⽤公共资源。如 果所给出的活动未按⾮减序排列，可以⽤ O( n l ogn ) 的 时间重排。 0 4.1 活动安排问题 例： 设待安排的 11 个活动的开始时间和结束时间按结 束时间的⾮减序排列如下： 1413121110987654f[i ] 122886535031S [i ] 1110987654321i 0 4.1 活动安排问题 算法 gr e e d yS e l e c tor 的计算 过程 如左图所示。图中 每⾏相应于算法的⼀次 迭代。阴影⻓条表示的 活动是已选⼊集合 A 的活 动，⽽空⽩⻓条表示的 活动是当前正在检查相 容性的活动。 0 4.1 活动安排问题 若被检查的活动 i 的开始时间 Si ⼩于最近选择的活动 j 的 结束时间 fi ，则不选择活动 i ，否则选择活动 i 加⼊集 合 A 中。 贪⼼算法并不总能求得问题的 整体最优解 。但对于 活动安排问题，贪⼼算法 gre e dyS e l e c t or 却总能求得的 整体最优解，即它最终所确定的相容活动集合 A 的规模 最⼤。这个结论可以⽤数学归纳法证明。 0 4.2 贪⼼算法的基本要素 本节着重讨论可以⽤贪⼼算法求解的问题的⼀般特 征。 对于⼀个具体的问题，怎么知道是否可⽤贪⼼算法 解此问题，以及能否得到问题的最优解呢 ? 这个问题很 难给予肯定的回答。 但是，从许多可以⽤贪⼼算法求解的问题中看到这类 问题⼀般具有 2 个重要的性质： 贪⼼选择性质 和 最优⼦ 结构性质 。 0 4.2 贪⼼算法的基本要素 1 、贪⼼选择性质 所谓 贪⼼选择性质 是指所求问题的 整体最优解 可以通 过⼀系列 局部最优 的选择，即贪⼼选择来达到。这是贪 ⼼算法可⾏的第⼀个基本要素，也是贪⼼算法与动态规 划算法的主要区别。 动态规划算法通常以 ⾃底向上 的⽅式解各⼦问题，⽽ 贪⼼算法则通常以 ⾃顶向下 的⽅式进⾏，以迭代的⽅式 作出相继的贪⼼选择，每作⼀次贪⼼选择就将所求问题 简化为规模更⼩的⼦问题。 对于⼀个具体问题，要确定它是否具有贪⼼选择性 质，必须证明每⼀步所作的贪⼼选择最终导致问题的整 体最优解。 0 4.2 贪⼼算法的基本要素 当⼀个问题的最优解包含其⼦问题的最优解时， 称此问题具有 最优⼦结构性质 。问题的最优⼦结构性 质是该问题可⽤动态规划算法或贪⼼算法求解的关键 特征。 2 、最优⼦结构性质 0 4.2 贪⼼算法的基本要素 贪⼼算法和动态规划算法都要求问题具有最优⼦结构 性质，这是 2 类算法的⼀个共同点。但是，对于具有 最 优⼦结构 的问题应该选⽤贪⼼算法还是动态规划算法 求解 ? 是否能⽤动态规划算法求解的问题也能⽤贪⼼算 法求解 ? 下⾯研究 2 个经典的 组合优化问题 ，并以此说 明贪⼼算法与动态规划算法的主要差别。 3 、贪⼼算法与动态规划算法的差异 0 4.2 贪⼼算法的基本要素 • 0-1 背包问题： 给定 n 种物品和⼀个背包。物品 i 的重量是 Wi ，其价值 为 Vi ，背包的容量为 C 。应如何选择装⼊背包的物品， 使得装⼊背包中物品的总价值最⼤ ? 在选择装⼊背包的物品时，对每种物品 i 只有 2 种选择，即装⼊背 包或不装⼊背包。不能将物品 i 装⼊背包多次，也不能只装⼊部分 的物品 i 。 0 4.2 贪⼼算法的基本要素 • 背包问题： 与 0-1 背包问题类似，所不同的是在选择物品 i 装⼊ 背包时， 可以选择物品 i 的⼀部分 ，⽽不⼀定要全部装 ⼊背包， 1 ≤ i ≤ n 。 这 2 类问题都具有 最优⼦结构 性质，极为相似，但背 包问题可以⽤贪⼼算法求解，⽽ 0-1 背包问题却不能⽤ 贪⼼算法求解。 0 4.2 贪⼼算法的基本要素 ⾸先计算每种物品单位重量的价值 Vi / Wi ，然后，依贪⼼选 择策略，将尽可能多的 单位重量价值最⾼ 的物品装⼊背包。 若将这种物品全部装⼊背包后，背包内的物品总重量未超过 C ，则选择单位重量价值次⾼的物品并尽可能多地装⼊背 包。依此策略⼀直地进⾏下去，直到背包装满为⽌。 具体算法可描述如下⻚： ⽤贪⼼算法解背包问题的基本步骤：   0 4.2 贪⼼算法的基本要素 • publ i c s t a t i c fl oa t k n ap s ac k (fl oa t c ,fl oa t [] w , fl oa t [] v ,fl oa t [] x) • { • i nt n=v .l e ngt h; • E l e m e nt [] d = ne w E l e m e nt [n]; • for ( i nt i = 0; i < n; i ++) d[i ] = ne w E l e m e nt (w [i ],v[i ],i ); • M e r ge S ort . m e r ge S ort (d); • i nt i ; • fl oa t opt =0; • for (i =0; i <n; i ++) x[i ]=0; • for (i =0; i <n; i ++) { • i f (d[i ].w >c ) bre a k; • x[d[i ].i ]=1; • opt +=d[i ].v; • c -=d[i ].w ; • } • i f (i <n){ • x[d[i ].i ]=c / d[i ].w ; • opt +=x[d[i ].i ]*d[i ].v; • } • re t urn opt ; • } 算法 k n ap s ac k 的主要 计算时间在于将各种 物品依其单位重量的 价值从⼤到⼩排序。 因此，算法的计算时 间上界为 O （ n l ogn ）。当然， 为了证明算法的正确 性，还必须证明背包 问题具有贪⼼选择性 质 。 0 第 4 章  贪⼼算法 顾名思义，贪⼼算法总是作出在当前看来最好的选 择。也就是说贪⼼算法并不从整体最优考虑，它所作 出的选择只是在某种意义上的 局部最优 选择。当然， 希望贪⼼算法得到的最终结果也是整体最优的。虽然 贪⼼算法不能对所有问题都得到整体最优解，但对许 多问题它能产⽣整体最优解。如单源最短路经问题， 最⼩⽣成树问题等。在⼀些情况下，即使贪⼼算法不 能得到整体最优解，其最终结果却是最优解的很好近 似。 0 第 4 章  贪⼼算法 • 4.1 活动安排问题 • 4.2 贪⼼算法的基本要素 • 4.3 最优装载 • 4.4 哈夫曼编码 • 4.5 单源最短路径 • 4.6 最⼩⽣成树 • 4.7 多机调度问题 • 4.8 贪⼼算法的理论基础 本章主要知识点： 0 4.1 活动安排问题 活动安排问题就是要在所给的活动集合中选出最 ⼤的相容活动⼦集合，是可以⽤贪⼼算法有效求解的 很好例⼦。该问题要求⾼效地安排⼀系列争⽤某⼀公 共资源的活动。贪⼼算法提供了⼀个简单、漂亮的⽅ 法使得尽可能多的活动能兼容地使⽤公共资源。 0 4.1 活动安排问题 设有 n 个活动的集合 E ={1,2,…,n} ，其中每个活动都要求 使⽤同⼀资源，如演讲会场等，⽽在同⼀时间内只有⼀个 活动能使⽤这⼀资源。每个活动 i 都有⼀个要求使⽤该资源 的起始时间 si 和⼀个结束时间 fi , 且 si < fi 。如果选择了活动 i ，则它在半开时间区间 [ si , fi ) 内占⽤资源。若区间 [ si , fi ) 与 区间 [ sj , fj ) 不相交，则称活动 i 与活动 j 是相容的。也就是 说，当 si ≥ fj 或 sj ≥ fi 时，活动 i 与活动 j 相容。 0 4.1 活动安排问题 • publ i c s t a t i c i nt gr e e d yS e l e c tor ( i nt [] s , i nt [] f, bool e a n a []) • { • i nt n=s .l e ngt h-1; • a [1]=t rue ; • i nt j =1; • i nt c ount =1; • for ( i nt i =2; i <=n; i ++) { • i f (s [i ]>=f[j ]) { • a [i ]=t rue ; • j =i ; • c ount ++; • } • e l s e a [i ]=fa l s e ; • } • re t urn c ount ; • } 在下⾯所给出的解活动安排问题的贪⼼算法 greedySelector : 各活动的起始时间和结束 时间存储于数组 s 和 f 中且 按结束时间的⾮减序排列 0 4.1 活动安排问题 由于输⼊的活动以其完成时间的 ⾮减序 排列，所以 算法 gr e e d yS e l e c tor 每次总是选择 具有最早完成时间 的 相容活动加⼊集合 A 中。直观上，按这种⽅法选择相 容活动为未安排活动留下尽可能多的时间。也就是 说，该算法的贪⼼选择的意义是 使剩余的可安排时间 段极⼤化 ，以便安排尽可能多的相容活动。 算法 gr e e d yS e l e c tor 的效率极⾼。当输⼊的活动已 按结束时间的⾮减序排列，算法只需 O (n ) 的时间安排 n 个活动，使最多的活动能相容地使⽤公共资源。如 果所给出的活动未按⾮减序排列，可以⽤ O( n l ogn ) 的 时间重排。 0 4.1 活动安排问题 例： 设待安排的 11 个活动的开始时间和结束时间按结 束时间的⾮减序排列如下： 1413121110987654f[i ] 122886535031S [i ] 1110987654321i 0 4.1 活动安排问题 算法 gr e e d yS e l e c tor 的计算 过程 如左图所示。图中 每⾏相应于算法的⼀次 迭代。阴影⻓条表示的 活动是已选⼊集合 A 的活 动，⽽空⽩⻓条表示的 活动是当前正在检查相 容性的活动。 0 4.1 活动安排问题 若被检查的活动 i 的开始时间 Si ⼩于最近选择的活动 j 的 结束时间 fi ，则不选择活动 i ，否则选择活动 i 加⼊集 合 A 中。 贪⼼算法并不总能求得问题的 整体最优解 。但对于 活动安排问题，贪⼼算法 gre e dyS e l e c t or 却总能求得的 整体最优解，即它最终所确定的相容活动集合 A 的规模 最⼤。这个结论可以⽤数学归纳法证明。 0 4.2 贪⼼算法的基本要素 本节着重讨论可以⽤贪⼼算法求解的问题的⼀般特 征。 对于⼀个具体的问题，怎么知道是否可⽤贪⼼算法 解此问题，以及能否得到问题的最优解呢 ? 这个问题很 难给予肯定的回答。 但是，从许多可以⽤贪⼼算法求解的问题中看到这类 问题⼀般具有 2 个重要的性质： 贪⼼选择性质 和 最优⼦ 结构性质 。 0 4.2 贪⼼算法的基本要素 1 、贪⼼选择性质 所谓 贪⼼选择性质 是指所求问题的 整体最优解 可以通 过⼀系列 局部最优 的选择，即贪⼼选择来达到。这是贪 ⼼算法可⾏的第⼀个基本要素，也是贪⼼算法与动态规 划算法的主要区别。 动态规划算法通常以 ⾃底向上 的⽅式解各⼦问题，⽽ 贪⼼算法则通常以 ⾃顶向下 的⽅式进⾏，以迭代的⽅式 作出相继的贪⼼选择，每作⼀次贪⼼选择就将所求问题 简化为规模更⼩的⼦问题。 对于⼀个具体问题，要确定它是否具有贪⼼选择性 质，必须证明每⼀步所作的贪⼼选择最终导致问题的整 体最优解。 0 4.2 贪⼼算法的基本要素 当⼀个问题的最优解包含其⼦问题的最优解时， 称此问题具有 最优⼦结构性质 。问题的最优⼦结构性 质是该问题可⽤动态规划算法或贪⼼算法求解的关键 特征。 2 、最优⼦结构性质 0 4.2 贪⼼算法的基本要素 贪⼼算法和动态规划算法都要求问题具有最优⼦结构 性质，这是 2 类算法的⼀个共同点。但是，对于具有 最 优⼦结构 的问题应该选⽤贪⼼算法还是动态规划算法 求解 ? 是否能⽤动态规划算法求解的问题也能⽤贪⼼算 法求解 ? 下⾯研究 2 个经典的 组合优化问题 ，并以此说 明贪⼼算法与动态规划算法的主要差别。 3 、贪⼼算法与动态规划算法的差异 0 4.2 贪⼼算法的基本要素 • 0-1 背包问题： 给定 n 种物品和⼀个背包。物品 i 的重量是 Wi ，其价值 为 Vi ，背包的容量为 C 。应如何选择装⼊背包的物品， 使得装⼊背包中物品的总价值最⼤ ? 在选择装⼊背包的物品时，对每种物品 i 只有 2 种选择，即装⼊背 包或不装⼊背包。不能将物品 i 装⼊背包多次，也不能只装⼊部分 的物品 i 。 0 4.2 贪⼼算法的基本要素 • 背包问题： 与 0-1 背包问题类似，所不同的是在选择物品 i 装⼊ 背包时， 可以选择物品 i 的⼀部分 ，⽽不⼀定要全部装 ⼊背包， 1 ≤ i ≤ n 。 这 2 类问题都具有 最优⼦结构 性质，极为相似，但背 包问题可以⽤贪⼼算法求解，⽽ 0-1 背包问题却不能⽤ 贪⼼算法求解。 0 4.2 贪⼼算法的基本要素 ⾸先计算每种物品单位重量的价值 Vi / Wi ，然后，依贪⼼选 择策略，将尽可能多的 单位重量价值最⾼ 的物品装⼊背包。 若将这种物品全部装⼊背包后，背包内的物品总重量未超过 C ，则选择单位重量价值次⾼的物品并尽可能多地装⼊背 包。依此策略⼀直地进⾏下去，直到背包装满为⽌。 具体算法可描述如下⻚： ⽤贪⼼算法解背包问题的基本步骤：   0 4.2 贪⼼算法的基本要素 • publ i c s t a t i c fl oa t k n ap s ac k (fl oa t c ,fl oa t [] w , fl oa t [] v ,fl oa t [] x) • { • i nt n=v .l e ngt h; • E l e m e nt [] d = ne w E l e m e nt [n]; • for ( i nt i = 0; i < n; i ++) d[i ] = ne w E l e m e nt (w [i ],v[i ],i ); • M e r ge S ort . m e r ge S ort (d); • i nt i ; • fl oa t opt =0; • for (i =0; i <n; i ++) x[i ]=0; • for (i =0; i <n; i ++) { • i f (d[i ].w >c ) bre a k; • x[d[i ].i ]=1; • opt +=d[i ].v; • c -=d[i ].w ; • } • i f (i <n){ • x[d[i ].i ]=c / d[i ].w ; • opt +=x[d[i ].i ]*d[i ].v; • } • re t urn opt ; • } 算法 k n ap s ac k 的主要 计算时间在于将各种 物品依其单位重量的 价值从⼤到⼩排序。 因此，算法的计算时 间上界为 O （ n l ogn ）。当然， 为了证明算法的正确 性，还必须证明背包 问题具有贪⼼选择性 质 。 0 第 4 章  贪⼼算法 顾名思义，贪⼼算法总是作出在当前看来最好的选 择。也就是说贪⼼算法并不从整体最优考虑，它所作 出的选择只是在某种意义上的 局部最优 选择。当然， 希望贪⼼算法得到的最终结果也是整体最优的。虽然 贪⼼算法不能对所有问题都得到整体最优解，但对许 多问题它能产⽣整体最优解。如单源最短路经问题， 最⼩⽣成树问题等。在⼀些情况下，即使贪⼼算法不 能得到整体最优解，其最终结果却是最优解的很好近 似。 0 第 4 章  贪⼼算法 • 4.1 活动安排问题 • 4.2 贪⼼算法的基本要素 • 4.3 最优装载 • 4.4 哈夫曼编码 • 4.5 单源最短路径 • 4.6 最⼩⽣成树 • 4.7 多机调度问题 • 4.8 贪⼼算法的理论基础 本章主要知识点： 0 4.1 活动安排问题 活动安排问题就是要在所给的活动集合中选出最 ⼤的相容活动⼦集合，是可以⽤贪⼼算法有效求解的 很好例⼦。该问题要求⾼效地安排⼀系列争⽤某⼀公 共资源的活动。贪⼼算法提供了⼀个简单、漂亮的⽅ 法使得尽可能多的活动能兼容地使⽤公共资源。 0 4.1 活动安排问题 设有 n 个活动的集合 E ={1,2,…,n} ，其中每个活动都要求 使⽤同⼀资源，如演讲会场等，⽽在同⼀时间内只有⼀个 活动能使⽤这⼀资源。每个活动 i 都有⼀个要求使⽤该资源 的起始时间 si 和⼀个结束时间 fi , 且 si < fi 。如果选择了活动 i ，则它在半开时间区间 [ si , fi ) 内占⽤资源。若区间 [ si , fi ) 与 区间 [ sj , fj ) 不相交，则称活动 i 与活动 j 是相容的。也就是 说，当 si ≥ fj 或 sj ≥ fi 时，活动 i 与活动 j 相容。 0 4.1 活动安排问题 • publ i c s t a t i c i nt gr e e d yS e l e c tor ( i nt [] s , i nt [] f, bool e a n a []) • { • i nt n=s .l e ngt h-1; • a [1]=t rue ; • i nt j =1; • i nt c ount =1; • for ( i nt i =2; i <=n; i ++) { • i f (s [i ]>=f[j ]) { • a [i ]=t rue ; • j =i ; • c ount ++; • } • e l s e a [i ]=fa l s e ; • } • re t urn c ount ; • } 在下⾯所给出的解活动安排问题的贪⼼算法 greedySelector : 各活动的起始时间和结束 时间存储于数组 s 和 f 中且 按结束时间的⾮减序排列 0 4.1 活动安排问题 由于输⼊的活动以其完成时间的 ⾮减序 排列，所以 算法 gr e e d yS e l e c tor 每次总是选择 具有最早完成时间 的 相容活动加⼊集合 A 中。直观上，按这种⽅法选择相 容活动为未安排活动留下尽可能多的时间。也就是 说，该算法的贪⼼选择的意义是 使剩余的可安排时间 段极⼤化 ，以便安排尽可能多的相容活动。 算法 gr e e d yS e l e c tor 的效率极⾼。当输⼊的活动已 按结束时间的⾮减序排列，算法只需 O (n ) 的时间安排 n 个活动，使最多的活动能相容地使⽤公共资源。如 果所给出的活动未按⾮减序排列，可以⽤ O( n l ogn ) 的 时间重排。 0 4.1 活动安排问题 例： 设待安排的 11 个活动的开始时间和结束时间按结 束时间的⾮减序排列如下： 1413121110987654f[i ] 122886535031S [i ] 1110987654321i 0 4.1 活动安排问题 算法 gr e e d yS e l e c tor 的计算 过程 如左图所示。图中 每⾏相应于算法的⼀次 迭代。阴影⻓条表示的 活动是已选⼊集合 A 的活 动，⽽空⽩⻓条表示的 活动是当前正在检查相 容性的活动。 0 4.1 活动安排问题 若被检查的活动 i 的开始时间 Si ⼩于最近选择的活动 j 的 结束时间 fi ，则不选择活动 i ，否则选择活动 i 加⼊集 合 A 中。 贪⼼算法并不总能求得问题的 整体最优解 。但对于 活动安排问题，贪⼼算法 gre e dyS e l e c t or 却总能求得的 整体最优解，即它最终所确定的相容活动集合 A 的规模 最⼤。这个结论可以⽤数学归纳法证明。 0 4.2 贪⼼算法的基本要素 本节着重讨论可以⽤贪⼼算法求解的问题的⼀般特 征。 对于⼀个具体的问题，怎么知道是否可⽤贪⼼算法 解此问题，以及能否得到问题的最优解呢 ? 这个问题很 难给予肯定的回答。 但是，从许多可以⽤贪⼼算法求解的问题中看到这类 问题⼀般具有 2 个重要的性质： 贪⼼选择性质 和 最优⼦ 结构性质 。 0 4.2 贪⼼算法的基本要素 1 、贪⼼选择性质 所谓 贪⼼选择性质 是指所求问题的 整体最优解 可以通 过⼀系列 局部最优 的选择，即贪⼼选择来达到。这是贪 ⼼算法可⾏的第⼀个基本要素，也是贪⼼算法与动态规 划算法的主要区别。 动态规划算法通常以 ⾃底向上 的⽅式解各⼦问题，⽽ 贪⼼算法则通常以 ⾃顶向下 的⽅式进⾏，以迭代的⽅式 作出相继的贪⼼选择，每作⼀次贪⼼选择就将所求问题 简化为规模更⼩的⼦问题。 对于⼀个具体问题，要确定它是否具有贪⼼选择性 质，必须证明每⼀步所作的贪⼼选择最终导致问题的整 体最优解。 0 4.2 贪⼼算法的基本要素 当⼀个问题的最优解包含其⼦问题的最优解时， 称此问题具有 最优⼦结构性质 。问题的最优⼦结构性 质是该问题可⽤动态规划算法或贪⼼算法求解的关键 特征。 2 、最优⼦结构性质 0 4.2 贪⼼算法的基本要素 贪⼼算法和动态规划算法都要求问题具有最优⼦结构 性质，这是 2 类算法的⼀个共同点。但是，对于具有 最 优⼦结构 的问题应该选⽤贪⼼算法还是动态规划算法 求解 ? 是否能⽤动态规划算法求解的问题也能⽤贪⼼算 法求解 ? 下⾯研究 2 个经典的 组合优化问题 ，并以此说 明贪⼼算法与动态规划算法的主要差别。 3 、贪⼼算法与动态规划算法的差异 0 4.2 贪⼼算法的基本要素 • 0-1 背包问题： 给定 n 种物品和⼀个背包。物品 i 的重量是 Wi ，其价值 为 Vi ，背包的容量为 C 。应如何选择装⼊背包的物品， 使得装⼊背包中物品的总价值最⼤ ? 在选择装⼊背包的物品时，对每种物品 i 只有 2 种选择，即装⼊背 包或不装⼊背包。不能将物品 i 装⼊背包多次，也不能只装⼊部分 的物品 i 。 0 4.2 贪⼼算法的基本要素 • 背包问题： 与 0-1 背包问题类似，所不同的是在选择物品 i 装⼊ 背包时， 可以选择物品 i 的⼀部分 ，⽽不⼀定要全部装 ⼊背包， 1 ≤ i ≤ n 。 这 2 类问题都具有 最优⼦结构 性质，极为相似，但背 包问题可以⽤贪⼼算法求解，⽽ 0-1 背包问题却不能⽤ 贪⼼算法求解。 0 4.2 贪⼼算法的基本要素 ⾸先计算每种物品单位重量的价值 Vi / Wi ，然后，依贪⼼选 择策略，将尽可能多的 单位重量价值最⾼ 的物品装⼊背包。 若将这种物品全部装⼊背包后，背包内的物品总重量未超过 C ，则选择单位重量价值次⾼的物品并尽可能多地装⼊背 包。依此策略⼀直地进⾏下去，直到背包装满为⽌。 具体算法可描述如下⻚： ⽤贪⼼算法解背包问题的基本步骤：   0 4.2 贪⼼算法的基本要素 • publ i c s t a t i c fl oa t k n ap s ac k (fl oa t c ,fl oa t [] w , fl oa t [] v ,fl oa t [] x) • { • i nt n=v .l e ngt h; • E l e m e nt [] d = ne w E l e m e nt [n]; • for ( i nt i = 0; i < n; i ++) d[i ] = ne w E l e m e nt (w [i ],v[i ],i ); • M e r ge S ort . m e r ge S ort (d); • i nt i ; • fl oa t opt =0; • for (i =0; i <n; i ++) x[i ]=0; • for (i =0; i <n; i ++) { • i f (d[i ].w >c ) bre a k; • x[d[i ].i ]=1; • opt +=d[i ].v; • c -=d[i ].w ; • } • i f (i <n){ • x[d[i ].i ]=c / d[i ].w ; • opt +=x[d[i ].i ]*d[i ].v; • } • re t urn opt ; • } 算法 k n ap s ac k 的主要 计算时间在于将各种 物品依其单位重量的 价值从⼤到⼩排序。 因此，算法的计算时 间上界为 O （ n l ogn ）。当然， 为了证明算法的正确 性，还必须证明背包 问题具有贪⼼选择性 质 。 0 第 4 章  贪⼼算法 顾名思义，贪⼼算法总是作出在当前看来最好的选 择。也就是说贪⼼算法并不从整体最优考虑，它所作 出的选择只是在某种意义上的 局部最优 选择。当然， 希望贪⼼算法得到的最终结果也是整体最优的。虽然 贪⼼算法不能对所有问题都得到整体最优解，但对许 多问题它能产⽣整体最优解。如单源最短路经问题， 最⼩⽣成树问题等。在⼀些情况下，即使贪⼼算法不 能得到整体最优解，其最终结果却是最优解的很好近 似。 0 第 4 章  贪⼼算法 • 4.1 活动安排问题 • 4.2 贪⼼算法的基本要素 • 4.3 最优装载 • 4.4 哈夫曼编码 • 4.5 单源最短路径 • 4.6 最⼩⽣成树 • 4.7 多机调度问题 • 4.8 贪⼼算法的理论基础 本章主要知识点： 0 4.1 活动安排问题 活动安排问题就是要在所给的活动集合中选出最 ⼤的相容活动⼦集合，是可以⽤贪⼼算法有效求解的 很好例⼦。该问题要求⾼效地安排⼀系列争⽤某⼀公 共资源的活动。贪⼼算法提供了⼀个简单、漂亮的⽅ 法使得尽可能多的活动能兼容地使⽤公共资源。 0 4.1 活动安排问题 设有 n 个活动的集合 E ={1,2,…,n} ，其中每个活动都要求 使⽤同⼀资源，如演讲会场等，⽽在同⼀时间内只有⼀个 活动能使⽤这⼀资源。每个活动 i 都有⼀个要求使⽤该资源 的起始时间 si 和⼀个结束时间 fi , 且 si < fi 。如果选择了活动 i ，则它在半开时间区间 [ si , fi ) 内占⽤资源。若区间 [ si , fi ) 与 区间 [ sj , fj ) 不相交，则称活动 i 与活动 j 是相容的。也就是 说，当 si ≥ fj 或 sj ≥ fi 时，活动 i 与活动 j 相容。 0 4.1 活动安排问题 • publ i c s t a t i c i nt gr e e d yS e l e c tor ( i nt [] s , i nt [] f, bool e a n a []) • { • i nt n=s .l e ngt h-1; • a [1]=t rue ; • i nt j =1; • i nt c ount =1; • for ( i nt i =2; i <=n; i ++) { • i f (s [i ]>=f[j ]) { • a [i ]=t rue ; • j =i ; • c ount ++; • } • e l s e a [i ]=fa l s e ; • } • re t urn c ount ; • } 在下⾯所给出的解活动安排问题的贪⼼算法 greedySelector : 各活动的起始时间和结束 时间存储于数组 s 和 f 中且 按结束时间的⾮减序排列 0 4.1 活动安排问题 由于输⼊的活动以其完成时间的 ⾮减序 排列，所以 算法 gr e e d yS e l e c tor 每次总是选择 具有最早完成时间 的 相容活动加⼊集合 A 中。直观上，按这种⽅法选择相 容活动为未安排活动留下尽可能多的时间。也就是 说，该算法的贪⼼选择的意义是 使剩余的可安排时间 段极⼤化 ，以便安排尽可能多的相容活动。 算法 gr e e d yS e l e c tor 的效率极⾼。当输⼊的活动已 按结束时间的⾮减序排列，算法只需 O (n ) 的时间安排 n 个活动，使最多的活动能相容地使⽤公共资源。如 果所给出的活动未按⾮减序排列，可以⽤ O( n l ogn ) 的 时间重排。 0 4.1 活动安排问题 例： 设待安排的 11 个活动的开始时间和结束时间按结 束时间的⾮减序排列如下： 1413121110987654f[i ] 122886535031S [i ] 1110987654321i 0 4.1 活动安排问题 算法 gr e e d yS e l e c tor 的计算 过程 如左图所示。图中 每⾏相应于算法的⼀次 迭代。阴影⻓条表示的 活动是已选⼊集合 A 的活 动，⽽空⽩⻓条表示的 活动是当前正在检查相 容性的活动。 0 4.1 活动安排问题 若被检查的活动 i 的开始时间 Si ⼩于最近选择的活动 j 的 结束时间 fi ，则不选择活动 i ，否则选择活动 i 加⼊集 合 A 中。 贪⼼算法并不总能求得问题的 整体最优解 。但对于 活动安排问题，贪⼼算法 gre e dyS e l e c t or 却总能求得的 整体最优解，即它最终所确定的相容活动集合 A 的规模 最⼤。这个结论可以⽤数学归纳法证明。 0 4.2 贪⼼算法的基本要素 本节着重讨论可以⽤贪⼼算法求解的问题的⼀般特 征。 对于⼀个具体的问题，怎么知道是否可⽤贪⼼算法 解此问题，以及能否得到问题的最优解呢 ? 这个问题很 难给予肯定的回答。 但是，从许多可以⽤贪⼼算法求解的问题中看到这类 问题⼀般具有 2 个重要的性质： 贪⼼选择性质 和 最优⼦ 结构性质 。 0 4.2 贪⼼算法的基本要素 1 、贪⼼选择性质 所谓 贪⼼选择性质 是指所求问题的 整体最优解 可以通 过⼀系列 局部最优 的选择，即贪⼼选择来达到。这是贪 ⼼算法可⾏的第⼀个基本要素，也是贪⼼算法与动态规 划算法的主要区别。 动态规划算法通常以 ⾃底向上 的⽅式解各⼦问题，⽽ 贪⼼算法则通常以 ⾃顶向下 的⽅式进⾏，以迭代的⽅式 作出相继的贪⼼选择，每作⼀次贪⼼选择就将所求问题 简化为规模更⼩的⼦问题。 对于⼀个具体问题，要确定它是否具有贪⼼选择性 质，必须证明每⼀步所作的贪⼼选择最终导致问题的整 体最优解。 0 4.2 贪⼼算法的基本要素 当⼀个问题的最优解包含其⼦问题的最优解时， 称此问题具有 最优⼦结构性质 。问题的最优⼦结构性 质是该问题可⽤动态规划算法或贪⼼算法求解的关键 特征。 2 、最优⼦结构性质 0 4.2 贪⼼算法的基本要素 贪⼼算法和动态规划算法都要求问题具有最优⼦结构 性质，这是 2 类算法的⼀个共同点。但是，对于具有 最 优⼦结构 的问题应该选⽤贪⼼算法还是动态规划算法 求解 ? 是否能⽤动态规划算法求解的问题也能⽤贪⼼算 法求解 ? 下⾯研究 2 个经典的 组合优化问题 ，并以此说 明贪⼼算法与动态规划算法的主要差别。 3 、贪⼼算法与动态规划算法的差异 0 4.2 贪⼼算法的基本要素 • 0-1 背包问题： 给定 n 种物品和⼀个背包。物品 i 的重量是 Wi ，其价值 为 Vi ，背包的容量为 C 。应如何选择装⼊背包的物品， 使得装⼊背包中物品的总价值最⼤ ? 在选择装⼊背包的物品时，对每种物品 i 只有 2 种选择，即装⼊背 包或不装⼊背包。不能将物品 i 装⼊背包多次，也不能只装⼊部分 的物品 i 。 0 4.2 贪⼼算法的基本要素 • 背包问题： 与 0-1 背包问题类似，所不同的是在选择物品 i 装⼊ 背包时， 可以选择物品 i 的⼀部分 ，⽽不⼀定要全部装 ⼊背包， 1 ≤ i ≤ n 。 这 2 类问题都具有 最优⼦结构 性质，极为相似，但背 包问题可以⽤贪⼼算法求解，⽽ 0-1 背包问题却不能⽤ 贪⼼算法求解。 0 4.2 贪⼼算法的基本要素 ⾸先计算每种物品单位重量的价值 Vi / Wi ，然后，依贪⼼选 择策略，将尽可能多的 单位重量价值最⾼ 的物品装⼊背包。 若将这种物品全部装⼊背包后，背包内的物品总重量未超过 C ，则选择单位重量价值次⾼的物品并尽可能多地装⼊背 包。依此策略⼀直地进⾏下去，直到背包装满为⽌。 具体算法可描述如下⻚： ⽤贪⼼算法解背包问题的基本步骤：   0 4.2 贪⼼算法的基本要素 • publ i c s t a t i c fl oa t k n ap s ac k (fl oa t c ,fl oa t [] w , fl oa t [] v ,fl oa t [] x) • { • i nt n=v .l e ngt h; • E l e m e nt [] d = ne w E l e m e nt [n]; • for ( i nt i = 0; i < n; i ++) d[i ] = ne w E l e m e nt (w [i ],v[i ],i ); • M e r ge S ort . m e r ge S ort (d); • i nt i ; • fl oa t opt =0; • for (i =0; i <n; i ++) x[i ]=0; • for (i =0; i <n; i ++) { • i f (d[i ].w >c ) bre a k; • x[d[i ].i ]=1; • opt +=d[i ].v; • c -=d[i ].w ; • } • i f (i <n){ • x[d[i ].i ]=c / d[i ].w ; • opt +=x[d[i ].i ]*d[i ].v; • } • re t urn opt ; • } 算法 k n ap s ac k 的主要 计算时间在于将各种 物品依其单位重量的 价值从⼤到⼩排序。 因此，算法的计算时 间上界为 O （ n l ogn ）。当然， 为了证明算法的正确 性，还必须证明背包 问题具有贪⼼选择性 质 。 0 第 4 章  贪⼼算法 顾名思义，贪⼼算法总是作出在当前看来最好的选 择。也就是说贪⼼算法并不从整体最优考虑，它所作 出的选择只是在某种意义上的 局部最优 选择。当然， 希望贪⼼算法得到的最终结果也是整体最优的。虽然 贪⼼算法不能对所有问题都得到整体最优解，但对许 多问题它能产⽣整体最优解。如单源最短路经问题， 最⼩⽣成树问题等。在⼀些情况下，即使贪⼼算法不 能得到整体最优解，其最终结果却是最优解的很好近 似。 0 第 4 章  贪⼼算法 • 4.1 活动安排问题 • 4.2 贪⼼算法的基本要素 • 4.3 最优装载 • 4.4 哈夫曼编码 • 4.5 单源最短路径 • 4.6 最⼩⽣成树 • 4.7 多机调度问题 • 4.8 贪⼼算法的理论基础 本章主要知识点： 0 4.1 活动安排问题 活动安排问题就是要在所给的活动集合中选出最 ⼤的相容活动⼦集合，是可以⽤贪⼼算法有效求解的 很好例⼦。该问题要求⾼效地安排⼀系列争⽤某⼀公 共资源的活动。贪⼼算法提供了⼀个简单、漂亮的⽅ 法使得尽可能多的活动能兼容地使⽤公共资源。 0 4.1 活动安排问题 设有 n 个活动的集合 E ={1,2,…,n} ，其中每个活动都要求 使⽤同⼀资源，如演讲会场等，⽽在同⼀时间内只有⼀个 活动能使⽤这⼀资源。每个活动 i 都有⼀个要求使⽤该资源 的起始时间 si 和⼀个结束时间 fi , 且 si < fi 。如果选择了活动 i ，则它在半开时间区间 [ si , fi ) 内占⽤资源。若区间 [ si , fi ) 与 区间 [ sj , fj ) 不相交，则称活动 i 与活动 j 是相容的。也就是 说，当 si ≥ fj 或 sj ≥ fi 时，活动 i 与活动 j 相容。 0 4.1 活动安排问题 • publ i c s t a t i c i nt gr e e d yS e l e c tor ( i nt [] s , i nt [] f, bool e a n a []) • { • i nt n=s .l e ngt h-1; • a [1]=t rue ; • i nt j =1; • i nt c ount =1; • for ( i nt i =2; i <=n; i ++) { • i f (s [i ]>=f[j ]) { • a [i ]=t rue ; • j =i ; • c ount ++; • } • e l s e a [i ]=fa l s e ; • } • re t urn c ount ; • } 在下⾯所给出的解活动安排问题的贪⼼算法 greedySelector : 各活动的起始时间和结束 时间存储于数组 s 和 f 中且 按结束时间的⾮减序排列 0 4.1 活动安排问题 由于输⼊的活动以其完成时间的 ⾮减序 排列，所以 算法 gr e e d yS e l e c tor 每次总是选择 具有最早完成时间 的 相容活动加⼊集合 A 中。直观上，按这种⽅法选择相 容活动为未安排活动留下尽可能多的时间。也就是 说，该算法的贪⼼选择的意义是 使剩余的可安排时间 段极⼤化 ，以便安排尽可能多的相容活动。 算法 gr e e d yS e l e c tor 的效率极⾼。当输⼊的活动已 按结束时间的⾮减序排列，算法只需 O (n ) 的时间安排 n 个活动，使最多的活动能相容地使⽤公共资源。如 果所给出的活动未按⾮减序排列，可以⽤ O( n l ogn ) 的 时间重排。 0 4.1 活动安排问题 例： 设待安排的 11 个活动的开始时间和结束时间按结 束时间的⾮减序排列如下： 1413121110987654f[i ] 122886535031S [i ] 1110987654321i 0 4.1 活动安排问题 算法 gr e e d yS e l e c tor 的计算 过程 如左图所示。图中 每⾏相应于算法的⼀次 迭代。阴影⻓条表示的 活动是已选⼊集合 A 的活 动，⽽空⽩⻓条表示的 活动是当前正在检查相 容性的活动。 0 4.1 活动安排问题 若被检查的活动 i 的开始时间 Si ⼩于最近选择的活动 j 的 结束时间 fi ，则不选择活动 i ，否则选择活动 i 加⼊集 合 A 中。 贪⼼算法并不总能求得问题的 整体最优解 。但对于 活动安排问题，贪⼼算法 gre e dyS e l e c t or 却总能求得的 整体最优解，即它最终所确定的相容活动集合 A 的规模 最⼤。这个结论可以⽤数学归纳法证明。 0 4.2 贪⼼算法的基本要素 本节着重讨论可以⽤贪⼼算法求解的问题的⼀般特 征。 对于⼀个具体的问题，怎么知道是否可⽤贪⼼算法 解此问题，以及能否得到问题的最优解呢 ? 这个问题很 难给予肯定的回答。 但是，从许多可以⽤贪⼼算法求解的问题中看到这类 问题⼀般具有 2 个重要的性质： 贪⼼选择性质 和 最优⼦ 结构性质 。 0 4.2 贪⼼算法的基本要素 1 、贪⼼选择性质 所谓 贪⼼选择性质 是指所求问题的 整体最优解 可以通 过⼀系列 局部最优 的选择，即贪⼼选择来达到。这是贪 ⼼算法可⾏的第⼀个基本要素，也是贪⼼算法与动态规 划算法的主要区别。 动态规划算法通常以 ⾃底向上 的⽅式解各⼦问题，⽽ 贪⼼算法则通常以 ⾃顶向下 的⽅式进⾏，以迭代的⽅式 作出相继的贪⼼选择，每作⼀次贪⼼选择就将所求问题 简化为规模更⼩的⼦问题。 对于⼀个具体问题，要确定它是否具有贪⼼选择性 质，必须证明每⼀步所作的贪⼼选择最终导致问题的整 体最优解。 0 4.2 贪⼼算法的基本要素 当⼀个问题的最优解包含其⼦问题的最优解时， 称此问题具有 最优⼦结构性质 。问题的最优⼦结构性 质是该问题可⽤动态规划算法或贪⼼算法求解的关键 特征。 2 、最优⼦结构性质 0 4.2 贪⼼算法的基本要素 贪⼼算法和动态规划算法都要求问题具有最优⼦结构 性质，这是 2 类算法的⼀个共同点。但是，对于具有 最 优⼦结构 的问题应该选⽤贪⼼算法还是动态规划算法 求解 ? 是否能⽤动态规划算法求解的问题也能⽤贪⼼算 法求解 ? 下⾯研究 2 个经典的 组合优化问题 ，并以此说 明贪⼼算法与动态规划算法的主要差别。 3 、贪⼼算法与动态规划算法的差异 0 4.2 贪⼼算法的基本要素 • 0-1 背包问题： 给定 n 种物品和⼀个背包。物品 i 的重量是 Wi ，其价值 为 Vi ，背包的容量为 C 。应如何选择装⼊背包的物品， 使得装⼊背包中物品的总价值最⼤ ? 在选择装⼊背包的物品时，对每种物品 i 只有 2 种选择，即装⼊背 包或不装⼊背包。不能将物品 i 装⼊背包多次，也不能只装⼊部分 的物品 i 。 0 4.2 贪⼼算法的基本要素 • 背包问题： 与 0-1 背包问题类似，所不同的是在选择物品 i 装⼊ 背包时， 可以选择物品 i 的⼀部分 ，⽽不⼀定要全部装 ⼊背包， 1 ≤ i ≤ n 。 这 2 类问题都具有 最优⼦结构 性质，极为相似，但背 包问题可以⽤贪⼼算法求解，⽽ 0-1 背包问题却不能⽤ 贪⼼算法求解。 0 4.2 贪⼼算法的基本要素 ⾸先计算每种物品单位重量的价值 Vi / Wi ，然后，依贪⼼选 择策略，将尽可能多的 单位重量价值最⾼ 的物品装⼊背包。 若将这种物品全部装⼊背包后，背包内的物品总重量未超过 C ，则选择单位重量价值次⾼的物品并尽可能多地装⼊背 包。依此策略⼀直地进⾏下去，直到背包装满为⽌。 具体算法可描述如下⻚： ⽤贪⼼算法解背包问题的基本步骤：   0 4.2 贪⼼算法的基本要素 • publ i c s t a t i c fl oa t k n ap s ac k (fl oa t c ,fl oa t [] w , fl oa t [] v ,fl oa t [] x) • { • i nt n=v .l e ngt h; • E l e m e nt [] d = ne w E l e m e nt [n]; • for ( i nt i = 0; i < n; i ++) d[i ] = ne w E l e m e nt (w [i ],v[i ],i ); • M e r ge S ort . m e r ge S ort (d); • i nt i ; • fl oa t opt =0; • for (i =0; i <n; i ++) x[i ]=0; • for (i =0; i <n; i ++) { • i f (d[i ].w >c ) bre a k; • x[d[i ].i ]=1; • opt +=d[i ].v; • c -=d[i ].w ; • } • i f (i <n){ • x[d[i ].i ]=c / d[i ].w ; • opt +=x[d[i ].i ]*d[i ].v; • } • re t urn opt ; • } 算法 k n ap s ac k 的主要 计算时间在于将各种 物品依其单位重量的 价值从⼤到⼩排序。 因此，算法的计算时 间上界为 O （ n l ogn ）。当然， 为了证明算法的正确 性，还必须证明背包 问题具有贪⼼选择性 质 。 0 第 4 章  贪⼼算法 顾名思义，贪⼼算法总是作出在当前看来最好的选 择。也就是说贪⼼算法并不从整体最优考虑，它所作 出的选择只是在某种意义上的 局部最优 选择。当然， 希望贪⼼算法得到的最终结果也是整体最优的。虽然 贪⼼算法不能对所有问题都得到整体最优解，但对许 多问题它能产⽣整体最优解。如单源最短路经问题， 最⼩⽣成树问题等。在⼀些情况下，即使贪⼼算法不 能得到整体最优解，其最终结果却是最优解的很好近 似。 0 第 4 章  贪⼼算法 • 4.1 活动安排问题 • 4.2 贪⼼算法的基本要素 • 4.3 最优装载 • 4.4 哈夫曼编码 • 4.5 单源最短路径 • 4.6 最⼩⽣成树 • 4.7 多机调度问题 • 4.8 贪⼼算法的理论基础 本章主要知识点： 0 4.1 活动安排问题 活动安排问题就是要在所给的活动集合中选出最 ⼤的相容活动⼦集合，是可以⽤贪⼼算法有效求解的 很好例⼦。该问题要求⾼效地安排⼀系列争⽤某⼀公 共资源的活动。贪⼼算法提供了⼀个简单、漂亮的⽅ 法使得尽可能多的活动能兼容地使⽤公共资源。 0 4.1 活动安排问题 设有 n 个活动的集合 E ={1,2,…,n} ，其中每个活动都要求 使⽤同⼀资源，如演讲会场等，⽽在同⼀时间内只有⼀个 活动能使⽤这⼀资源。每个活动 i 都有⼀个要求使⽤该资源 的起始时间 si 和⼀个结束时间 fi , 且 si < fi 。如果选择了活动 i ，则它在半开时间区间 [ si , fi ) 内占⽤资源。若区间 [ si , fi ) 与 区间 [ sj , fj ) 不相交，则称活动 i 与活动 j 是相容的。也就是 说，当 si ≥ fj 或 sj ≥ fi 时，活动 i 与活动 j 相容。 0 4.1 活动安排问题 • publ i c s t a t i c i nt gr e e d yS e l e c tor ( i nt [] s , i nt [] f, bool e a n a []) • { • i nt n=s .l e ngt h-1; • a [1]=t rue ; • i nt j =1; • i nt c ount =1; • for ( i nt i =2; i <=n; i ++) { • i f (s [i ]>=f[j ]) { • a [i ]=t rue ; • j =i ; • c ount ++; • } • e l s e a [i ]=fa l s e ; • } • re t urn c ount ; • } 在下⾯所给出的解活动安排问题的贪⼼算法 greedySelector : 各活动的起始时间和结束 时间存储于数组 s 和 f 中且 按结束时间的⾮减序排列 0 4.1 活动安排问题 由于输⼊的活动以其完成时间的 ⾮减序 排列，所以 算法 gr e e d yS e l e c tor 每次总是选择 具有最早完成时间 的 相容活动加⼊集合 A 中。直观上，按这种⽅法选择相 容活动为未安排活动留下尽可能多的时间。也就是 说，该算法的贪⼼选择的意义是 使剩余的可安排时间 段极⼤化 ，以便安排尽可能多的相容活动。 算法 gr e e d yS e l e c tor 的效率极⾼。当输⼊的活动已 按结束时间的⾮减序排列，算法只需 O (n ) 的时间安排 n 个活动，使最多的活动能相容地使⽤公共资源。如 果所给出的活动未按⾮减序排列，可以⽤ O( n l ogn ) 的 时间重排。 0 4.1 活动安排问题 例： 设待安排的 11 个活动的开始时间和结束时间按结 束时间的⾮减序排列如下： 1413121110987654f[i ] 122886535031S [i ] 1110987654321i 0 4.1 活动安排问题 算法 gr e e d yS e l e c tor 的计算 过程 如左图所示。图中 每⾏相应于算法的⼀次 迭代。阴影⻓条表示的 活动是已选⼊集合 A 的活 动，⽽空⽩⻓条表示的 活动是当前正在检查相 容性的活动。 0 4.1 活动安排问题 若被检查的活动 i 的开始时间 Si ⼩于最近选择的活动 j 的 结束时间 fi ，则不选择活动 i ，否则选择活动 i 加⼊集 合 A 中。 贪⼼算法并不总能求得问题的 整体最优解 。但对于 活动安排问题，贪⼼算法 gre e dyS e l e c t or 却总能求得的 整体最优解，即它最终所确定的相容活动集合 A 的规模 最⼤。这个结论可以⽤数学归纳法证明。 0 4.2 贪⼼算法的基本要素 本节着重讨论可以⽤贪⼼算法求解的问题的⼀般特 征。 对于⼀个具体的问题，怎么知道是否可⽤贪⼼算法 解此问题，以及能否得到问题的最优解呢 ? 这个问题很 难给予肯定的回答。 但是，从许多可以⽤贪⼼算法求解的问题中看到这类 问题⼀般具有 2 个重要的性质： 贪⼼选择性质 和 最优⼦ 结构性质 。 0 4.2 贪⼼算法的基本要素 1 、贪⼼选择性质 所谓 贪⼼选择性质 是指所求问题的 整体最优解 可以通 过⼀系列 局部最优 的选择，即贪⼼选择来达到。这是贪 ⼼算法可⾏的第⼀个基本要素，也是贪⼼算法与动态规 划算法的主要区别。 动态规划算法通常以 ⾃底向上 的⽅式解各⼦问题，⽽ 贪⼼算法则通常以 ⾃顶向下 的⽅式进⾏，以迭代的⽅式 作出相继的贪⼼选择，每作⼀次贪⼼选择就将所求问题 简化为规模更⼩的⼦问题。 对于⼀个具体问题，要确定它是否具有贪⼼选择性 质，必须证明每⼀步所作的贪⼼选择最终导致问题的整 体最优解。 0 4.2 贪⼼算法的基本要素 当⼀个问题的最优解包含其⼦问题的最优解时， 称此问题具有 最优⼦结构性质 。问题的最优⼦结构性 质是该问题可⽤动态规划算法或贪⼼算法求解的关键 特征。 2 、最优⼦结构性质 0 4.2 贪⼼算法的基本要素 贪⼼算法和动态规划算法都要求问题具有最优⼦结构 性质，这是 2 类算法的⼀个共同点。但是，对于具有 最 优⼦结构 的问题应该选⽤贪⼼算法还是动态规划算法 求解 ? 是否能⽤动态规划算法求解的问题也能⽤贪⼼算 法求解 ? 下⾯研究 2 个经典的 组合优化问题 ，并以此说 明贪⼼算法与动态规划算法的主要差别。 3 、贪⼼算法与动态规划算法的差异 0 4.2 贪⼼算法的基本要素 • 0-1 背包问题： 给定 n 种物品和⼀个背包。物品 i 的重量是 Wi ，其价值 为 Vi ，背包的容量为 C 。应如何选择装⼊背包的物品， 使得装⼊背包中物品的总价值最⼤ ? 在选择装⼊背包的物品时，对每种物品 i 只有 2 种选择，即装⼊背 包或不装⼊背包。不能将物品 i 装⼊背包多次，也不能只装⼊部分 的物品 i 。 0 4.2 贪⼼算法的基本要素 • 背包问题： 与 0-1 背包问题类似，所不同的是在选择物品 i 装⼊ 背包时， 可以选择物品 i 的⼀部分 ，⽽不⼀定要全部装 ⼊背包， 1 ≤ i ≤ n 。 这 2 类问题都具有 最优⼦结构 性质，极为相似，但背 包问题可以⽤贪⼼算法求解，⽽ 0-1 背包问题却不能⽤ 贪⼼算法求解。 0 4.2 贪⼼算法的基本要素 ⾸先计算每种物品单位重量的价值 Vi / Wi ，然后，依贪⼼选 择策略，将尽可能多的 单位重量价值最⾼ 的物品装⼊背包。 若将这种物品全部装⼊背包后，背包内的物品总重量未超过 C ，则选择单位重量价值次⾼的物品并尽可能多地装⼊背 包。依此策略⼀直地进⾏下去，直到背包装满为⽌。 具体算法可描述如下⻚： ⽤贪⼼算法解背包问题的基本步骤：   0 4.2 贪⼼算法的基本要素 • publ i c s t a t i c fl oa t k n ap s ac k (fl oa t c ,fl oa t [] w , fl oa t [] v ,fl oa t [] x) • { • i nt n=v .l e ngt h; • E l e m e nt [] d = ne w E l e m e nt [n]; • for ( i nt i = 0; i < n; i ++) d[i ] = ne w E l e m e nt (w [i ],v[i ],i ); • M e r ge S ort . m e r ge S ort (d); • i nt i ; • fl oa t opt =0; • for (i =0; i <n; i ++) x[i ]=0; • for (i =0; i <n; i ++) { • i f (d[i ].w >c ) bre a k; • x[d[i ].i ]=1; • opt +=d[i ].v; • c -=d[i ].w ; • } • i f (i <n){ • x[d[i ].i ]=c / d[i ].w ; • opt +=x[d[i ].i ]*d[i ].v; • } • re t urn opt ; • } 算法 k n ap s ac k 的主要 计算时间在于将各种 物品依其单位重量的 价值从⼤到⼩排序。 因此，算法的计算时 间上界为 O （ n l ogn ）。当然， 为了证明算法的正确 性，还必须证明背包 问题具有贪⼼选择性 质 。 0 第 4 章  贪⼼算法 顾名思义，贪⼼算法总是作出在当前看来最好的选 择。也就是说贪⼼算法并不从整体最优考虑，它所作 出的选择只是在某种意义上的 局部最优 选择。当然， 希望贪⼼算法得到的最终结果也是整体最优的。虽然 贪⼼算法不能对所有问题都得到整体最优解，但对许 多问题它能产⽣整体最优解。如单源最短路经问题， 最⼩⽣成树问题等。在⼀些情况下，即使贪⼼算法不 能得到整体最优解，其最终结果却是最优解的很好近 似。 0 第 4 章  贪⼼算法 • 4.1 活动安排问题 • 4.2 贪⼼算法的基本要素 • 4.3 最优装载 • 4.4 哈夫曼编码 • 4.5 单源最短路径 • 4.6 最⼩⽣成树 • 4.7 多机调度问题 • 4.8 贪⼼算法的理论基础 本章主要知识点： 0 4.1 活动安排问题 活动安排问题就是要在所给的活动集合中选出最 ⼤的相容活动⼦集合，是可以⽤贪⼼算法有效求解的 很好例⼦。该问题要求⾼效地安排⼀系列争⽤某⼀公 共资源的活动。贪⼼算法提供了⼀个简单、漂亮的⽅ 法使得尽可能多的活动能兼容地使⽤公共资源。 0 4.1 活动安排问题 设有 n 个活动的集合 E ={1,2,…,n} ，其中每个活动都要求 使⽤同⼀资源，如演讲会场等，⽽在同⼀时间内只有⼀个 活动能使⽤这⼀资源。每个活动 i 都有⼀个要求使⽤该资源 的起始时间 si 和⼀个结束时间 fi , 且 si < fi 。如果选择了活动 i ，则它在半开时间区间 [ si , fi ) 内占⽤资源。若区间 [ si , fi ) 与 区间 [ sj , fj ) 不相交，则称活动 i 与活动 j 是相容的。也就是 说，当 si ≥ fj 或 sj ≥ fi 时，活动 i 与活动 j 相容。 0 4.1 活动安排问题 • publ i c s t a t i c i nt gr e e d yS e l e c tor ( i nt [] s , i nt [] f, bool e a n a []) • { • i nt n=s .l e ngt h-1; • a [1]=t rue ; • i nt j =1; • i nt c ount =1; • for ( i nt i =2; i <=n; i ++) { • i f (s [i ]>=f[j ]) { • a [i ]=t rue ; • j =i ; • c ount ++; • } • e l s e a [i ]=fa l s e ; • } • re t urn c ount ; • } 在下⾯所给出的解活动安排问题的贪⼼算法 greedySelector : 各活动的起始时间和结束 时间存储于数组 s 和 f 中且 按结束时间的⾮减序排列 0 4.1 活动安排问题 由于输⼊的活动以其完成时间的 ⾮减序 排列，所以 算法 gr e e d yS e l e c tor 每次总是选择 具有最早完成时间 的 相容活动加⼊集合 A 中。直观上，按这种⽅法选择相 容活动为未安排活动留下尽可能多的时间。也就是 说，该算法的贪⼼选择的意义是 使剩余的可安排时间 段极⼤化 ，以便安排尽可能多的相容活动。 算法 gr e e d yS e l e c tor 的效率极⾼。当输⼊的活动已 按结束时间的⾮减序排列，算法只需 O (n ) 的时间安排 n 个活动，使最多的活动能相容地使⽤公共资源。如 果所给出的活动未按⾮减序排列，可以⽤ O( n l ogn ) 的 时间重排。 0 4.1 活动安排问题 例： 设待安排的 11 个活动的开始时间和结束时间按结 束时间的⾮减序排列如下： 1413121110987654f[i ] 122886535031S [i ] 1110987654321i 0 4.1 活动安排问题 算法 gr e e d yS e l e c tor 的计算 过程 如左图所示。图中 每⾏相应于算法的⼀次 迭代。阴影⻓条表示的 活动是已选⼊集合 A 的活 动，⽽空⽩⻓条表示的 活动是当前正在检查相 容性的活动。 0 4.1 活动安排问题 若被检查的活动 i 的开始时间 Si ⼩于最近选择的活动 j 的 结束时间 fi ，则不选择活动 i ，否则选择活动 i 加⼊集 合 A 中。 贪⼼算法并不总能求得问题的 整体最优解 。但对于 活动安排问题，贪⼼算法 gre e dyS e l e c t or 却总能求得的 整体最优解，即它最终所确定的相容活动集合 A 的规模 最⼤。这个结论可以⽤数学归纳法证明。 0 4.2 贪⼼算法的基本要素 本节着重讨论可以⽤贪⼼算法求解的问题的⼀般特 征。 对于⼀个具体的问题，怎么知道是否可⽤贪⼼算法 解此问题，以及能否得到问题的最优解呢 ? 这个问题很 难给予肯定的回答。 但是，从许多可以⽤贪⼼算法求解的问题中看到这类 问题⼀般具有 2 个重要的性质： 贪⼼选择性质 和 最优⼦ 结构性质 。 0 4.2 贪⼼算法的基本要素 1 、贪⼼选择性质 所谓 贪⼼选择性质 是指所求问题的 整体最优解 可以通 过⼀系列 局部最优 的选择，即贪⼼选择来达到。这是贪 ⼼算法可⾏的第⼀个基本要素，也是贪⼼算法与动态规 划算法的主要区别。 动态规划算法通常以 ⾃底向上 的⽅式解各⼦问题，⽽ 贪⼼算法则通常以 ⾃顶向下 的⽅式进⾏，以迭代的⽅式 作出相继的贪⼼选择，每作⼀次贪⼼选择就将所求问题 简化为规模更⼩的⼦问题。 对于⼀个具体问题，要确定它是否具有贪⼼选择性 质，必须证明每⼀步所作的贪⼼选择最终导致问题的整 体最优解。 0 4.2 贪⼼算法的基本要素 当⼀个问题的最优解包含其⼦问题的最优解时， 称此问题具有 最优⼦结构性质 。问题的最优⼦结构性 质是该问题可⽤动态规划算法或贪⼼算法求解的关键 特征。 2 、最优⼦结构性质 0 4.2 贪⼼算法的基本要素 贪⼼算法和动态规划算法都要求问题具有最优⼦结构 性质，这是 2 类算法的⼀个共同点。但是，对于具有 最 优⼦结构 的问题应该选⽤贪⼼算法还是动态规划算法 求解 ? 是否能⽤动态规划算法求解的问题也能⽤贪⼼算 法求解 ? 下⾯研究 2 个经典的 组合优化问题 ，并以此说 明贪⼼算法与动态规划算法的主要差别。 3 、贪⼼算法与动态规划算法的差异 0 4.2 贪⼼算法的基本要素 • 0-1 背包问题： 给定 n 种物品和⼀个背包。物品 i 的重量是 Wi ，其价值 为 Vi ，背包的容量为 C 。应如何选择装⼊背包的物品， 使得装⼊背包中物品的总价值最⼤ ? 在选择装⼊背包的物品时，对每种物品 i 只有 2 种选择，即装⼊背 包或不装⼊背包。不能将物品 i 装⼊背包多次，也不能只装⼊部分 的物品 i 。 0 4.2 贪⼼算法的基本要素 • 背包问题： 与 0-1 背包问题类似，所不同的是在选择物品 i 装⼊ 背包时， 可以选择物品 i 的⼀部分 ，⽽不⼀定要全部装 ⼊背包， 1 ≤ i ≤ n 。 这 2 类问题都具有 最优⼦结构 性质，极为相似，但背 包问题可以⽤贪⼼算法求解，⽽ 0-1 背包问题却不能⽤ 贪⼼算法求解。 0 4.2 贪⼼算法的基本要素 ⾸先计算每种物品单位重量的价值 Vi / Wi ，然后，依贪⼼选 择策略，将尽可能多的 单位重量价值最⾼ 的物品装⼊背包。 若将这种物品全部装⼊背包后，背包内的物品总重量未超过 C ，则选择单位重量价值次⾼的物品并尽可能多地装⼊背 包。依此策略⼀直地进⾏下去，直到背包装满为⽌。 具体算法可描述如下⻚： ⽤贪⼼算法解背包问题的基本步骤：   0 4.2 贪⼼算法的基本要素 • publ i c s t a t i c fl oa t k n ap s ac k (fl oa t c ,fl oa t [] w , fl oa t [] v ,fl oa t [] x) • { • i nt n=v .l e ngt h; • E l e m e nt [] d = ne w E l e m e nt [n]; • for ( i nt i = 0; i < n; i ++) d[i ] = ne w E l e m e nt (w [i ],v[i ],i ); • M e r ge S ort . m e r ge S ort (d); • i nt i ; • fl oa t opt =0; • for (i =0; i <n; i ++) x[i ]=0; • for (i =0; i <n; i ++) { • i f (d[i ].w >c ) bre a k; • x[d[i ].i ]=1; • opt +=d[i ].v; • c -=d[i ].w ; • } • i f (i <n){ • x[d[i ].i ]=c / d[i ].w ; • opt +=x[d[i ].i ]*d[i ].v; • } • re t urn opt ; • } 算法 k n ap s ac k 的主要 计算时间在于将各种 物品依其单位重量的 价值从⼤到⼩排序。 因此，算法的计算时 间上界为 O （ n l ogn ）。当然， 为了证明算法的正确 性，还必须证明背包 问题具有贪⼼选择性 质 。 0 第 4 章  贪⼼算法 顾名思义，贪⼼算法总是作出在当前看来最好的选 择。也就是说贪⼼算法并不从整体最优考虑，它所作 出的选择只是在某种意义上的 局部最优 选择。当然， 希望贪⼼算法得到的最终结果也是整体最优的。虽然 贪⼼算法不能对所有问题都得到整体最优解，但对许 多问题它能产⽣整体最优解。如单源最短路经问题， 最⼩⽣成树问题等。在⼀些情况下，即使贪⼼算法不 能得到整体最优解，其最终结果却是最优解的很好近 似。 0 第 4 章  贪⼼算法 • 4.1 活动安排问题 • 4.2 贪⼼算法的基本要素 • 4.3 最优装载 • 4.4 哈夫曼编码 • 4.5 单源最短路径 • 4.6 最⼩⽣成树 • 4.7 多机调度问题 • 4.8 贪⼼算法的理论基础 本章主要知识点： 0 4.1 活动安排问题 活动安排问题就是要在所给的活动集合中选出最 ⼤的相容活动⼦集合，是可以⽤贪⼼算法有效求解的 很好例⼦。该问题要求⾼效地安排⼀系列争⽤某⼀公 共资源的活动。贪⼼算法提供了⼀个简单、漂亮的⽅ 法使得尽可能多的活动能兼容地使⽤公共资源。 0 4.1 活动安排问题 设有 n 个活动的集合 E ={1,2,…,n} ，其中每个活动都要求 使⽤同⼀资源，如演讲会场等，⽽在同⼀时间内只有⼀个 活动能使⽤这⼀资源。每个活动 i 都有⼀个要求使⽤该资源 的起始时间 si 和⼀个结束时间 fi , 且 si < fi 。如果选择了活动 i ，则它在半开时间区间 [ si , fi ) 内占⽤资源。若区间 [ si , fi ) 与 区间 [ sj , fj ) 不相交，则称活动 i 与活动 j 是相容的。也就是 说，当 si ≥ fj 或 sj ≥ fi 时，活动 i 与活动 j 相容。 0 4.1 活动安排问题 • publ i c s t a t i c i nt gr e e d yS e l e c tor ( i nt [] s , i nt [] f, bool e a n a []) • { • i nt n=s .l e ngt h-1; • a [1]=t rue ; • i nt j =1; • i nt c ount =1; • for ( i nt i =2; i <=n; i ++) { • i f (s [i ]>=f[j ]) { • a [i ]=t rue ; • j =i ; • c ount ++; • } • e l s e a [i ]=fa l s e ; • } • re t urn c ount ; • } 在下⾯所给出的解活动安排问题的贪⼼算法 greedySelector : 各活动的起始时间和结束 时间存储于数组 s 和 f 中且 按结束时间的⾮减序排列 0 4.1 活动安排问题 由于输⼊的活动以其完成时间的 ⾮减序 排列，所以 算法 gr e e d yS e l e c tor 每次总是选择 具有最早完成时间 的 相容活动加⼊集合 A 中。直观上，按这种⽅法选择相 容活动为未安排活动留下尽可能多的时间。也就是 说，该算法的贪⼼选择的意义是 使剩余的可安排时间 段极⼤化 ，以便安排尽可能多的相容活动。 算法 gr e e d yS e l e c tor 的效率极⾼。当输⼊的活动已 按结束时间的⾮减序排列，算法只需 O (n ) 的时间安排 n 个活动，使最多的活动能相容地使⽤公共资源。如 果所给出的活动未按⾮减序排列，可以⽤ O( n l ogn ) 的 时间重排。 0 4.1 活动安排问题 例： 设待安排的 11 个活动的开始时间和结束时间按结 束时间的⾮减序排列如下： 1413121110987654f[i ] 122886535031S [i ] 1110987654321i 0 4.1 活动安排问题 算法 gr e e d yS e l e c tor 的计算 过程 如左图所示。图中 每⾏相应于算法的⼀次 迭代。阴影⻓条表示的 活动是已选⼊集合 A 的活 动，⽽空⽩⻓条表示的 活动是当前正在检查相 容性的活动。 0 4.1 活动安排问题 若被检查的活动 i 的开始时间 Si ⼩于最近选择的活动 j 的 结束时间 fi ，则不选择活动 i ，否则选择活动 i 加⼊集 合 A 中。 贪⼼算法并不总能求得问题的 整体最优解 。但对于 活动安排问题，贪⼼算法 gre e dyS e l e c t or 却总能求得的 整体最优解，即它最终所确定的相容活动集合 A 的规模 最⼤。这个结论可以⽤数学归纳法证明。 0 4.2 贪⼼算法的基本要素 本节着重讨论可以⽤贪⼼算法求解的问题的⼀般特 征。 对于⼀个具体的问题，怎么知道是否可⽤贪⼼算法 解此问题，以及能否得到问题的最优解呢 ? 这个问题很 难给予肯定的回答。 但是，从许多可以⽤贪⼼算法求解的问题中看到这类 问题⼀般具有 2 个重要的性质： 贪⼼选择性质 和 最优⼦ 结构性质 。 0 4.2 贪⼼算法的基本要素 1 、贪⼼选择性质 所谓 贪⼼选择性质 是指所求问题的 整体最优解 可以通 过⼀系列 局部最优 的选择，即贪⼼选择来达到。这是贪 ⼼算法可⾏的第⼀个基本要素，也是贪⼼算法与动态规 划算法的主要区别。 动态规划算法通常以 ⾃底向上 的⽅式解各⼦问题，⽽ 贪⼼算法则通常以 ⾃顶向下 的⽅式进⾏，以迭代的⽅式 作出相继的贪⼼选择，每作⼀次贪⼼选择就将所求问题 简化为规模更⼩的⼦问题。 对于⼀个具体问题，要确定它是否具有贪⼼选择性 质，必须证明每⼀步所作的贪⼼选择最终导致问题的整 体最优解。 0 4.2 贪⼼算法的基本要素 当⼀个问题的最优解包含其⼦问题的最优解时， 称此问题具有 最优⼦结构性质 。问题的最优⼦结构性 质是该问题可⽤动态规划算法或贪⼼算法求解的关键 特征。 2 、最优⼦结构性质 0 4.2 贪⼼算法的基本要素 贪⼼算法和动态规划算法都要求问题具有最优⼦结构 性质，这是 2 类算法的⼀个共同点。但是，对于具有 最 优⼦结构 的问题应该选⽤贪⼼算法还是动态规划算法 求解 ? 是否能⽤动态规划算法求解的问题也能⽤贪⼼算 法求解 ? 下⾯研究 2 个经典的 组合优化问题 ，并以此说 明贪⼼算法与动态规划算法的主要差别。 3 、贪⼼算法与动态规划算法的差异 0 4.2 贪⼼算法的基本要素 • 0-1 背包问题： 给定 n 种物品和⼀个背包。物品 i 的重量是 Wi ，其价值 为 Vi ，背包的容量为 C 。应如何选择装⼊背包的物品， 使得装⼊背包中物品的总价值最⼤ ? 在选择装⼊背包的物品时，对每种物品 i 只有 2 种选择，即装⼊背 包或不装⼊背包。不能将物品 i 装⼊背包多次，也不能只装⼊部分 的物品 i 。 0 4.2 贪⼼算法的基本要素 • 背包问题： 与 0-1 背包问题类似，所不同的是在选择物品 i 装⼊ 背包时， 可以选择物品 i 的⼀部分 ，⽽不⼀定要全部装 ⼊背包， 1 ≤ i ≤ n 。 这 2 类问题都具有 最优⼦结构 性质，极为相似，但背 包问题可以⽤贪⼼算法求解，⽽ 0-1 背包问题却不能⽤ 贪⼼算法求解。 0 4.2 贪⼼算法的基本要素 ⾸先计算每种物品单位重量的价值 Vi / Wi ，然后，依贪⼼选 择策略，将尽可能多的 单位重量价值最⾼ 的物品装⼊背包。 若将这种物品全部装⼊背包后，背包内的物品总重量未超过 C ，则选择单位重量价值次⾼的物品并尽可能多地装⼊背 包。依此策略⼀直地进⾏下去，直到背包装满为⽌。 具体算法可描述如下⻚： ⽤贪⼼算法解背包问题的基本步骤：   0 4.2 贪⼼算法的基本要素 • publ i c s t a t i c fl oa t k n ap s ac k (fl oa t c ,fl oa t [] w , fl oa t [] v ,fl oa t [] x) • { • i nt n=v .l e ngt h; • E l e m e nt [] d = ne w E l e m e nt [n]; • for ( i nt i = 0; i < n; i ++) d[i ] = ne w E l e m e nt (w [i ],v[i ],i ); • M e r ge S ort . m e r ge S ort (d); • i nt i ; • fl oa t opt =0; • for (i =0; i <n; i ++) x[i ]=0; • for (i =0; i <n; i ++) { • i f (d[i ].w >c ) bre a k; • x[d[i ].i ]=1; • opt +=d[i ].v; • c -=d[i ].w ; • } • i f (i <n){ • x[d[i ].i ]=c / d[i ].w ; • opt +=x[d[i ].i ]*d[i ].v; • } • re t urn opt ; • } 算法 k n ap s ac k 的主要 计算时间在于将各种 物品依其单位重量的 价值从⼤到⼩排序。 因此，算法的计算时 间上界为 O （ n l ogn ）。当然， 为了证明算法的正确 性，还必须证明背包 问题具有贪⼼选择性 质 。 0 第 4 章  贪⼼算法 顾名思义，贪⼼算法总是作出在当前看来最好的选 择。也就是说贪⼼算法并不从整体最优考虑，它所作 出的选择只是在某种意义上的 局部最优 选择。当然， 希望贪⼼算法得到的最终结果也是整体最优的。虽然 贪⼼算法不能对所有问题都得到整体最优解，但对许 多问题它能产⽣整体最优解。如单源最短路经问题， 最⼩⽣成树问题等。在⼀些情况下，即使贪⼼算法不 能得到整体最优解，其最终结果却是最优解的很好近 似。 0 第 4 章  贪⼼算法 • 4.1 活动安排问题 • 4.2 贪⼼算法的基本要素 • 4.3 最优装载 • 4.4 哈夫曼编码 • 4.5 单源最短路径 • 4.6 最⼩⽣成树 • 4.7 多机调度问题 • 4.8 贪⼼算法的理论基础 本章主要知识点： 0 4.1 活动安排问题 活动安排问题就是要在所给的活动集合中选出最 ⼤的相容活动⼦集合，是可以⽤贪⼼算法有效求解的 很好例⼦。该问题要求⾼效地安排⼀系列争⽤某⼀公 共资源的活动。贪⼼算法提供了⼀个简单、漂亮的⽅ 法使得尽可能多的活动能兼容地使⽤公共资源。 0 4.1 活动安排问题 设有 n 个活动的集合 E ={1,2,…,n} ，其中每个活动都要求 使⽤同⼀资源，如演讲会场等，⽽在同⼀时间内只有⼀个 活动能使⽤这⼀资源。每个活动 i 都有⼀个要求使⽤该资源 的起始时间 si 和⼀个结束时间 fi , 且 si < fi 。如果选择了活动 i ，则它在半开时间区间 [ si , fi ) 内占⽤资源。若区间 [ si , fi ) 与 区间 [ sj , fj ) 不相交，则称活动 i 与活动 j 是相容的。也就是 说，当 si ≥ fj 或 sj ≥ fi 时，活动 i 与活动 j 相容。 0 4.1 活动安排问题 • publ i c s t a t i c i nt gr e e d yS e l e c tor ( i nt [] s , i nt [] f, bool e a n a []) • { • i nt n=s .l e ngt h-1; • a [1]=t rue ; • i nt j =1; • i nt c ount =1; • for ( i nt i =2; i <=n; i ++) { • i f (s [i ]>=f[j ]) { • a [i ]=t rue ; • j =i ; • c ount ++; • } • e l s e a [i ]=fa l s e ; • } • re t urn c ount ; • } 在下⾯所给出的解活动安排问题的贪⼼算法 greedySelector : 各活动的起始时间和结束 时间存储于数组 s 和 f 中且 按结束时间的⾮减序排列 0 4.1 活动安排问题 由于输⼊的活动以其完成时间的 ⾮减序 排列，所以 算法 gr e e d yS e l e c tor 每次总是选择 具有最早完成时间 的 相容活动加⼊集合 A 中。直观上，按这种⽅法选择相 容活动为未安排活动留下尽可能多的时间。也就是 说，该算法的贪⼼选择的意义是 使剩余的可安排时间 段极⼤化 ，以便安排尽可能多的相容活动。 算法 gr e e d yS e l e c tor 的效率极⾼。当输⼊的活动已 按结束时间的⾮减序排列，算法只需 O (n ) 的时间安排 n 个活动，使最多的活动能相容地使⽤公共资源。如 果所给出的活动未按⾮减序排列，可以⽤ O( n l ogn ) 的 时间重排。 0 4.1 活动安排问题 例： 设待安排的 11 个活动的开始时间和结束时间按结 束时间的⾮减序排列如下： 1413121110987654f[i ] 122886535031S [i ] 1110987654321i 0 4.1 活动安排问题 算法 gr e e d yS e l e c tor 的计算 过程 如左图所示。图中 每⾏相应于算法的⼀次 迭代。阴影⻓条表示的 活动是已选⼊集合 A 的活 动，⽽空⽩⻓条表示的 活动是当前正在检查相 容性的活动。 0 4.1 活动安排问题 若被检查的活动 i 的开始时间 Si ⼩于最近选择的活动 j 的 结束时间 fi ，则不选择活动 i ，否则选择活动 i 加⼊集 合 A 中。 贪⼼算法并不总能求得问题的 整体最优解 。但对于 活动安排问题，贪⼼算法 gre e dyS e l e c t or 却总能求得的 整体最优解，即它最终所确定的相容活动集合 A 的规模 最⼤。这个结论可以⽤数学归纳法证明。 0 4.2 贪⼼算法的基本要素 本节着重讨论可以⽤贪⼼算法求解的问题的⼀般特 征。 对于⼀个具体的问题，怎么知道是否可⽤贪⼼算法 解此问题，以及能否得到问题的最优解呢 ? 这个问题很 难给予肯定的回答。 但是，从许多可以⽤贪⼼算法求解的问题中看到这类 问题⼀般具有 2 个重要的性质： 贪⼼选择性质 和 最优⼦ 结构性质 。 0 4.2 贪⼼算法的基本要素 1 、贪⼼选择性质 所谓 贪⼼选择性质 是指所求问题的 整体最优解 可以通 过⼀系列 局部最优 的选择，即贪⼼选择来达到。这是贪 ⼼算法可⾏的第⼀个基本要素，也是贪⼼算法与动态规 划算法的主要区别。 动态规划算法通常以 ⾃底向上 的⽅式解各⼦问题，⽽ 贪⼼算法则通常以 ⾃顶向下 的⽅式进⾏，以迭代的⽅式 作出相继的贪⼼选择，每作⼀次贪⼼选择就将所求问题 简化为规模更⼩的⼦问题。 对于⼀个具体问题，要确定它是否具有贪⼼选择性 质，必须证明每⼀步所作的贪⼼选择最终导致问题的整 体最优解。 0 4.2 贪⼼算法的基本要素 当⼀个问题的最优解包含其⼦问题的最优解时， 称此问题具有 最优⼦结构性质 。问题的最优⼦结构性 质是该问题可⽤动态规划算法或贪⼼算法求解的关键 特征。 2 、最优⼦结构性质 0 4.2 贪⼼算法的基本要素 贪⼼算法和动态规划算法都要求问题具有最优⼦结构 性质，这是 2 类算法的⼀个共同点。但是，对于具有 最 优⼦结构 的问题应该选⽤贪⼼算法还是动态规划算法 求解 ? 是否能⽤动态规划算法求解的问题也能⽤贪⼼算 法求解 ? 下⾯研究 2 个经典的 组合优化问题 ，并以此说 明贪⼼算法与动态规划算法的主要差别。 3 、贪⼼算法与动态规划算法的差异 0 4.2 贪⼼算法的基本要素 • 0-1 背包问题： 给定 n 种物品和⼀个背包。物品 i 的重量是 Wi ，其价值 为 Vi ，背包的容量为 C 。应如何选择装⼊背包的物品， 使得装⼊背包中物品的总价值最⼤ ? 在选择装⼊背包的物品时，对每种物品 i 只有 2 种选择，即装⼊背 包或不装⼊背包。不能将物品 i 装⼊背包多次，也不能只装⼊部分 的物品 i 。 0 4.2 贪⼼算法的基本要素 • 背包问题： 与 0-1 背包问题类似，所不同的是在选择物品 i 装⼊ 背包时， 可以选择物品 i 的⼀部分 ，⽽不⼀定要全部装 ⼊背包， 1 ≤ i ≤ n 。 这 2 类问题都具有 最优⼦结构 性质，极为相似，但背 包问题可以⽤贪⼼算法求解，⽽ 0-1 背包问题却不能⽤ 贪⼼算法求解。 0 4.2 贪⼼算法的基本要素 ⾸先计算每种物品单位重量的价值 Vi / Wi ，然后，依贪⼼选 择策略，将尽可能多的 单位重量价值最⾼ 的物品装⼊背包。 若将这种物品全部装⼊背包后，背包内的物品总重量未超过 C ，则选择单位重量价值次⾼的物品并尽可能多地装⼊背 包。依此策略⼀直地进⾏下去，直到背包装满为⽌。 具体算法可描述如下⻚： ⽤贪⼼算法解背包问题的基本步骤：   0 4.2 贪⼼算法的基本要素 • publ i c s t a t i c fl oa t k n ap s ac k (fl oa t c ,fl oa t [] w , fl oa t [] v ,fl oa t [] x) • { • i nt n=v .l e ngt h; • E l e m e nt [] d = ne w E l e m e nt [n]; • for ( i nt i = 0; i < n; i ++) d[i ] = ne w E l e m e nt (w [i ],v[i ],i ); • M e r ge S ort . m e r ge S ort (d); • i nt i ; • fl oa t opt =0; • for (i =0; i <n; i ++) x[i ]=0; • for (i =0; i <n; i ++) { • i f (d[i ].w >c ) bre a k; • x[d[i ].i ]=1; • opt +=d[i ].v; • c -=d[i ].w ; • } • i f (i <n){ • x[d[i ].i ]=c / d[i ].w ; • opt +=x[d[i ].i ]*d[i ].v; • } • re t urn opt ; • } 算法 k n ap s ac k 的主要 计算时间在于将各种 物品依其单位重量的 价值从⼤到⼩排序。 因此，算法的计算时 间上界为 O （ n l ogn ）。当然， 为了证明算法的正确 性，还必须证明背包 问题具有贪⼼选择性 质 。 0 第 4 章  贪⼼算法 顾名思义，贪⼼算法总是作出在当前看来最好的选 择。也就是说贪⼼算法并不从整体最优考虑，它所作 出的选择只是在某种意义上的 局部最优 选择。当然， 希望贪⼼算法得到的最终结果也是整体最优的。虽然 贪⼼算法不能对所有问题都得到整体最优解，但对许 多问题它能产⽣整体最优解。如单源最短路经问题， 最⼩⽣成树问题等。在⼀些情况下，即使贪⼼算法不 能得到整体最优解，其最终结果却是最优解的很好近 似。 0 第 4 章  贪⼼算法 • 4.1 活动安排问题 • 4.2 贪⼼算法的基本要素 • 4.3 最优装载 • 4.4 哈夫曼编码 • 4.5 单源最短路径 • 4.6 最⼩⽣成树 • 4.7 多机调度问题 • 4.8 贪⼼算法的理论基础 本章主要知识点： 0 4.1 活动安排问题 活动安排问题就是要在所给的活动集合中选出最 ⼤的相容活动⼦集合，是可以⽤贪⼼算法有效求解的 很好例⼦。该问题要求⾼效地安排⼀系列争⽤某⼀公 共资源的活动。贪⼼算法提供了⼀个简单、漂亮的⽅ 法使得尽可能多的活动能兼容地使⽤公共资源。 0 4.1 活动安排问题 设有 n 个活动的集合 E ={1,2,…,n} ，其中每个活动都要求 使⽤同⼀资源，如演讲会场等，⽽在同⼀时间内只有⼀个 活动能使⽤这⼀资源。每个活动 i 都有⼀个要求使⽤该资源 的起始时间 si 和⼀个结束时间 fi , 且 si < fi 。如果选择了活动 i ，则它在半开时间区间 [ si , fi ) 内占⽤资源。若区间 [ si , fi ) 与 区间 [ sj , fj ) 不相交，则称活动 i 与活动 j 是相容的。也就是 说，当 si ≥ fj 或 sj ≥ fi 时，活动 i 与活动 j 相容。 0 4.1 活动安排问题 • publ i c s t a t i c i nt gr e e d yS e l e c tor ( i nt [] s , i nt [] f, bool e a n a []) • { • i nt n=s .l e ngt h-1; • a [1]=t rue ; • i nt j =1; • i nt c ount =1; • for ( i nt i =2; i <=n; i ++) { • i f (s [i ]>=f[j ]) { • a [i ]=t rue ; • j =i ; • c ount ++; • } • e l s e a [i ]=fa l s e ; • } • re t urn c ount ; • } 在下⾯所给出的解活动安排问题的贪⼼算法 greedySelector : 各活动的起始时间和结束 时间存储于数组 s 和 f 中且 按结束时间的⾮减序排列 0 4.1 活动安排问题 由于输⼊的活动以其完成时间的 ⾮减序 排列，所以 算法 gr e e d yS e l e c tor 每次总是选择 具有最早完成时间 的 相容活动加⼊集合 A 中。直观上，按这种⽅法选择相 容活动为未安排活动留下尽可能多的时间。也就是 说，该算法的贪⼼选择的意义是 使剩余的可安排时间 段极⼤化 ，以便安排尽可能多的相容活动。 算法 gr e e d yS e l e c tor 的效率极⾼。当输⼊的活动已 按结束时间的⾮减序排列，算法只需 O (n ) 的时间安排 n 个活动，使最多的活动能相容地使⽤公共资源。如 果所给出的活动未按⾮减序排列，可以⽤ O( n l ogn ) 的 时间重排。 0 4.1 活动安排问题 例： 设待安排的 11 个活动的开始时间和结束时间按结 束时间的⾮减序排列如下： 1413121110987654f[i ] 122886535031S [i ] 1110987654321i 0 4.1 活动安排问题 算法 gr e e d yS e l e c tor 的计算 过程 如左图所示。图中 每⾏相应于算法的⼀次 迭代。阴影⻓条表示的 活动是已选⼊集合 A 的活 动，⽽空⽩⻓条表示的 活动是当前正在检查相 容性的活动。 0 4.1 活动安排问题 若被检查的活动 i 的开始时间 Si ⼩于最近选择的活动 j 的 结束时间 fi ，则不选择活动 i ，否则选择活动 i 加⼊集 合 A 中。 贪⼼算法并不总能求得问题的 整体最优解 。但对于 活动安排问题，贪⼼算法 gre e dyS e l e c t or 却总能求得的 整体最优解，即它最终所确定的相容活动集合 A 的规模 最⼤。这个结论可以⽤数学归纳法证明。 0 4.2 贪⼼算法的基本要素 本节着重讨论可以⽤贪⼼算法求解的问题的⼀般特 征。 对于⼀个具体的问题，怎么知道是否可⽤贪⼼算法 解此问题，以及能否得到问题的最优解呢 ? 这个问题很 难给予肯定的回答。 但是，从许多可以⽤贪⼼算法求解的问题中看到这类 问题⼀般具有 2 个重要的性质： 贪⼼选择性质 和 最优⼦ 结构性质 。 0 4.2 贪⼼算法的基本要素 1 、贪⼼选择性质 所谓 贪⼼选择性质 是指所求问题的 整体最优解 可以通 过⼀系列 局部最优 的选择，即贪⼼选择来达到。这是贪 ⼼算法可⾏的第⼀个基本要素，也是贪⼼算法与动态规 划算法的主要区别。 动态规划算法通常以 ⾃底向上 的⽅式解各⼦问题，⽽ 贪⼼算法则通常以 ⾃顶向下 的⽅式进⾏，以迭代的⽅式 作出相继的贪⼼选择，每作⼀次贪⼼选择就将所求问题 简化为规模更⼩的⼦问题。 对于⼀个具体问题，要确定它是否具有贪⼼选择性 质，必须证明每⼀步所作的贪⼼选择最终导致问题的整 体最优解。 0 4.2 贪⼼算法的基本要素 当⼀个问题的最优解包含其⼦问题的最优解时， 称此问题具有 最优⼦结构性质 。问题的最优⼦结构性 质是该问题可⽤动态规划算法或贪⼼算法求解的关键 特征。 2 、最优⼦结构性质 0 4.2 贪⼼算法的基本要素 贪⼼算法和动态规划算法都要求问题具有最优⼦结构 性质，这是 2 类算法的⼀个共同点。但是，对于具有 最 优⼦结构 的问题应该选⽤贪⼼算法还是动态规划算法 求解 ? 是否能⽤动态规划算法求解的问题也能⽤贪⼼算 法求解 ? 下⾯研究 2 个经典的 组合优化问题 ，并以此说 明贪⼼算法与动态规划算法的主要差别。 3 、贪⼼算法与动态规划算法的差异 0 4.2 贪⼼算法的基本要素 • 0-1 背包问题： 给定 n 种物品和⼀个背包。物品 i 的重量是 Wi ，其价值 为 Vi ，背包的容量为 C 。应如何选择装⼊背包的物品， 使得装⼊背包中物品的总价值最⼤ ? 在选择装⼊背包的物品时，对每种物品 i 只有 2 种选择，即装⼊背 包或不装⼊背包。不能将物品 i 装⼊背包多次，也不能只装⼊部分 的物品 i 。 0 4.2 贪⼼算法的基本要素 • 背包问题： 与 0-1 背包问题类似，所不同的是在选择物品 i 装⼊ 背包时， 可以选择物品 i 的⼀部分 ，⽽不⼀定要全部装 ⼊背包， 1 ≤ i ≤ n 。 这 2 类问题都具有 最优⼦结构 性质，极为相似，但背 包问题可以⽤贪⼼算法求解，⽽ 0-1 背包问题却不能⽤ 贪⼼算法求解。 0 4.2 贪⼼算法的基本要素 ⾸先计算每种物品单位重量的价值 Vi / Wi ，然后，依贪⼼选 择策略，将尽可能多的 单位重量价值最⾼ 的物品装⼊背包。 若将这种物品全部装⼊背包后，背包内的物品总重量未超过 C ，则选择单位重量价值次⾼的物品并尽可能多地装⼊背 包。依此策略⼀直地进⾏下去，直到背包装满为⽌。 具体算法可描述如下⻚： ⽤贪⼼算法解背包问题的基本步骤：   0 4.2 贪⼼算法的基本要素 • publ i c s t a t i c fl oa t k n ap s ac k (fl oa t c ,fl oa t [] w , fl oa t [] v ,fl oa t [] x) • { • i nt n=v .l e ngt h; • E l e m e nt [] d = ne w E l e m e nt [n]; • for ( i nt i = 0; i < n; i ++) d[i ] = ne w E l e m e nt (w [i ],v[i ],i ); • M e r ge S ort . m e r ge S ort (d); • i nt i ; • fl oa t opt =0; • for (i =0; i <n; i ++) x[i ]=0; • for (i =0; i <n; i ++) { • i f (d[i ].w >c ) bre a k; • x[d[i ].i ]=1; • opt +=d[i ].v; • c -=d[i ].w ; • } • i f (i <n){ • x[d[i ].i ]=c / d[i ].w ; • opt +=x[d[i ].i ]*d[i ].v; • } • re t urn opt ; • } 算法 k n ap s ac k 的主要 计算时间在于将各种 物品依其单位重量的 价值从⼤到⼩排序。 因此，算法的计算时 间上界为 O （ n l ogn ）。当然， 为了证明算法的正确 性，还必须证明背包 问题具有贪⼼选择性 质 。 0 第 4 章  贪⼼算法 顾名思义，贪⼼算法总是作出在当前看来最好的选 择。也就是说贪⼼算法并不从整体最优考虑，它所作 出的选择只是在某种意义上的 局部最优 选择。当然， 希望贪⼼算法得到的最终结果也是整体最优的。虽然 贪⼼算法不能对所有问题都得到整体最优解，但对许 多问题它能产⽣整体最优解。如单源最短路经问题， 最⼩⽣成树问题等。在⼀些情况下，即使贪⼼算法不 能得到整体最优解，其最终结果却是最优解的很好近 似。 0 第 4 章  贪⼼算法 • 4.1 活动安排问题 • 4.2 贪⼼算法的基本要素 • 4.3 最优装载 • 4.4 哈夫曼编码 • 4.5 单源最短路径 • 4.6 最⼩⽣成树 • 4.7 多机调度问题 • 4.8 贪⼼算法的理论基础 本章主要知识点： 0 4.1 活动安排问题 活动安排问题就是要在所给的活动集合中选出最 ⼤的相容活动⼦集合，是可以⽤贪⼼算法有效求解的 很好例⼦。该问题要求⾼效地安排⼀系列争⽤某⼀公 共资源的活动。贪⼼算法提供了⼀个简单、漂亮的⽅ 法使得尽可能多的活动能兼容地使⽤公共资源。 0 4.1 活动安排问题 设有 n 个活动的集合 E ={1,2,…,n} ，其中每个活动都要求 使⽤同⼀资源，如演讲会场等，⽽在同⼀时间内只有⼀个 活动能使⽤这⼀资源。每个活动 i 都有⼀个要求使⽤该资源 的起始时间 si 和⼀个结束时间 fi , 且 si < fi 。如果选择了活动 i ，则它在半开时间区间 [ si , fi ) 内占⽤资源。若区间 [ si , fi ) 与 区间 [ sj , fj ) 不相交，则称活动 i 与活动 j 是相容的。也就是 说，当 si ≥ fj 或 sj ≥ fi 时，活动 i 与活动 j 相容。 0 4.1 活动安排问题 • publ i c s t a t i c i nt gr e e d yS e l e c tor ( i nt [] s , i nt [] f, bool e a n a []) • { • i nt n=s .l e ngt h-1; • a [1]=t rue ; • i nt j =1; • i nt c ount =1; • for ( i nt i =2; i <=n; i ++) { • i f (s [i ]>=f[j ]) { • a [i ]=t rue ; • j =i ; • c ount ++; • } • e l s e a [i ]=fa l s e ; • } • re t urn c ount ; • } 在下⾯所给出的解活动安排问题的贪⼼算法 greedySelector : 各活动的起始时间和结束 时间存储于数组 s 和 f 中且 按结束时间的⾮减序排列 0 4.1 活动安排问题 由于输⼊的活动以其完成时间的 ⾮减序 排列，所以 算法 gr e e d yS e l e c tor 每次总是选择 具有最早完成时间 的 相容活动加⼊集合 A 中。直观上，按这种⽅法选择相 容活动为未安排活动留下尽可能多的时间。也就是 说，该算法的贪⼼选择的意义是 使剩余的可安排时间 段极⼤化 ，以便安排尽可能多的相容活动。 算法 gr e e d yS e l e c tor 的效率极⾼。当输⼊的活动已 按结束时间的⾮减序排列，算法只需 O (n ) 的时间安排 n 个活动，使最多的活动能相容地使⽤公共资源。如 果所给出的活动未按⾮减序排列，可以⽤ O( n l ogn ) 的 时间重排。 0 4.1 活动安排问题 例： 设待安排的 11 个活动的开始时间和结束时间按结 束时间的⾮减序排列如下： 1413121110987654f[i ] 122886535031S [i ] 1110987654321i 0 4.1 活动安排问题 算法 gr e e d yS e l e c tor 的计算 过程 如左图所示。图中 每⾏相应于算法的⼀次 迭代。阴影⻓条表示的 活动是已选⼊集合 A 的活 动，⽽空⽩⻓条表示的 活动是当前正在检查相 容性的活动。 0 4.1 活动安排问题 若被检查的活动 i 的开始时间 Si ⼩于最近选择的活动 j 的 结束时间 fi ，则不选择活动 i ，否则选择活动 i 加⼊集 合 A 中。 贪⼼算法并不总能求得问题的 整体最优解 。但对于 活动安排问题，贪⼼算法 gre e dyS e l e c t or 却总能求得的 整体最优解，即它最终所确定的相容活动集合 A 的规模 最⼤。这个结论可以⽤数学归纳法证明。 0 4.2 贪⼼算法的基本要素 本节着重讨论可以⽤贪⼼算法求解的问题的⼀般特 征。 对于⼀个具体的问题，怎么知道是否可⽤贪⼼算法 解此问题，以及能否得到问题的最优解呢 ? 这个问题很 难给予肯定的回答。 但是，从许多可以⽤贪⼼算法求解的问题中看到这类 问题⼀般具有 2 个重要的性质： 贪⼼选择性质 和 最优⼦ 结构性质 。 0 4.2 贪⼼算法的基本要素 1 、贪⼼选择性质 所谓 贪⼼选择性质 是指所求问题的 整体最优解 可以通 过⼀系列 局部最优 的选择，即贪⼼选择来达到。这是贪 ⼼算法可⾏的第⼀个基本要素，也是贪⼼算法与动态规 划算法的主要区别。 动态规划算法通常以 ⾃底向上 的⽅式解各⼦问题，⽽ 贪⼼算法则通常以 ⾃顶向下 的⽅式进⾏，以迭代的⽅式 作出相继的贪⼼选择，每作⼀次贪⼼选择就将所求问题 简化为规模更⼩的⼦问题。 对于⼀个具体问题，要确定它是否具有贪⼼选择性 质，必须证明每⼀步所作的贪⼼选择最终导致问题的整 体最优解。 0 4.2 贪⼼算法的基本要素 当⼀个问题的最优解包含其⼦问题的最优解时， 称此问题具有 最优⼦结构性质 。问题的最优⼦结构性 质是该问题可⽤动态规划算法或贪⼼算法求解的关键 特征。 2 、最优⼦结构性质 0 4.2 贪⼼算法的基本要素 贪⼼算法和动态规划算法都要求问题具有最优⼦结构 性质，这是 2 类算法的⼀个共同点。但是，对于具有 最 优⼦结构 的问题应该选⽤贪⼼算法还是动态规划算法 求解 ? 是否能⽤动态规划算法求解的问题也能⽤贪⼼算 法求解 ? 下⾯研究 2 个经典的 组合优化问题 ，并以此说 明贪⼼算法与动态规划算法的主要差别。 3 、贪⼼算法与动态规划算法的差异 0 4.2 贪⼼算法的基本要素 • 0-1 背包问题： 给定 n 种物品和⼀个背包。物品 i 的重量是 Wi ，其价值 为 Vi ，背包的容量为 C 。应如何选择装⼊背包的物品， 使得装⼊背包中物品的总价值最⼤ ? 在选择装⼊背包的物品时，对每种物品 i 只有 2 种选择，即装⼊背 包或不装⼊背包。不能将物品 i 装⼊背包多次，也不能只装⼊部分 的物品 i 。 0 4.2 贪⼼算法的基本要素 • 背包问题： 与 0-1 背包问题类似，所不同的是在选择物品 i 装⼊ 背包时， 可以选择物品 i 的⼀部分 ，⽽不⼀定要全部装 ⼊背包， 1 ≤ i ≤ n 。 这 2 类问题都具有 最优⼦结构 性质，极为相似，但背 包问题可以⽤贪⼼算法求解，⽽ 0-1 背包问题却不能⽤ 贪⼼算法求解。 0 4.2 贪⼼算法的基本要素 ⾸先计算每种物品单位重量的价值 Vi / Wi ，然后，依贪⼼选 择策略，将尽可能多的 单位重量价值最⾼ 的物品装⼊背包。 若将这种物品全部装⼊背包后，背包内的物品总重量未超过 C ，则选择单位重量价值次⾼的物品并尽可能多地装⼊背 包。依此策略⼀直地进⾏下去，直到背包装满为⽌。 具体算法可描述如下⻚： ⽤贪⼼算法解背包问题的基本步骤：   0 4.2 贪⼼算法的基本要素 • publ i c s t a t i c fl oa t k n ap s ac k (fl oa t c ,fl oa t [] w , fl oa t [] v ,fl oa t [] x) • { • i nt n=v .l e ngt h; • E l e m e nt [] d = ne w E l e m e nt [n]; • for ( i nt i = 0; i < n; i ++) d[i ] = ne w E l e m e nt (w [i ],v[i ],i ); • M e r ge S ort . m e r ge S ort (d); • i nt i ; • fl oa t opt =0; • for (i =0; i <n; i ++) x[i ]=0; • for (i =0; i <n; i ++) { • i f (d[i ].w >c ) bre a k; • x[d[i ].i ]=1; • opt +=d[i ].v; • c -=d[i ].w ; • } • i f (i <n){ • x[d[i ].i ]=c / d[i ].w ; • opt +=x[d[i ].i ]*d[i ].v; • } • re t urn opt ; • } 算法 k n ap s ac k 的主要 计算时间在于将各种 物品依其单位重量的 价值从⼤到⼩排序。 因此，算法的计算时 间上界为 O （ n l ogn ）。当然， 为了证明算法的正确 性，还必须证明背包 问题具有贪⼼选择性 质 。 0 4.2 贪⼼算法的基本要素 对于 0-1 背包问题 ，贪⼼选择之所以不能得到最优解是因 为在这种情况下，它⽆法保证最终能将背包装满，部分闲 置的背包空间使每公⽄背包空间的价值降低了。事实上， 在考虑 0-1 背包问题时，应⽐较选择该物品和不选择该物 品所导致的最终⽅案，然后再作出最好选择。由此就导出 许多互相重叠的⼦问题。这正是该问题可⽤ 动态规划算法 求解的另⼀重要特征。 实际上也是如此，动态规划算法的确可以有效地解 0-1 背 包问题。 0 4.3 最优装载 有⼀批集装箱要装上⼀艘载重量为 c 的轮船。其中集 装箱 i 的重量为 Wi 。最优装载问题要求确定在装载体积 不受限制的情况下，将尽可能多的集装箱装上轮船。 1 、算法描述 最优装载问题可⽤贪⼼算法求解。采⽤重量最轻者先 装的贪⼼选择策略，可产⽣最优装载问题的最优解。 具体算法描述如下⻚。 0 4.3 最优装载 • publ i c s t a t i c fl oa t l oad i n g (fl oa t c , fl oa t [] w , i nt [] x) • { • i nt n=w .l e ngt h; • E l e m e nt [] d = ne w E l e m e nt [n]; • for ( i nt i = 0; i < n; i ++) • d[i ] = ne w E l e m e nt (w [i ],i ); • M e r ge S ort . m e r ge S ort (d); • fl oa t opt =0; • for ( i nt i = 0; i < n; i ++) x[i ] = 0; • for ( i nt i = 0; i < n & & d[i ].w <= c ; i ++) { • x[d[i ].i ] = 1; • opt +=d[i ].w ; • c -= d[i ].w ; • } • re t urn opt ; • } 其中 El e me n t 类说明为 参 ⻅本书 P 1 15 0 4.3 最优装载 2 、贪⼼选择性质 可以证明最优装载问题具有贪⼼选择性质 。 3 、最优⼦结构性质 最优装载问题具有最优⼦结构性质。 由最优装载问题的贪⼼选择性质和最优⼦结构性质， 容易证明算法 l oad i n g 的正确性。 算法 l oad i n g 的主要计算量在于将集装箱依其重量从 ⼩到⼤排序，故算法所需的计算时间为 O( n l ogn ) 。 0 4.4 哈夫曼编码 哈夫曼编码 是⼴泛地⽤于数据⽂件压缩的⼗分有效的 编码⽅法。其压缩率通常在 20% ～ 90% 之间。哈夫曼编 码算法⽤字符在⽂件中出现的频率表来建⽴⼀个 ⽤ 0 ， 1 串表示各字符的最优表示⽅式。 给出现频率⾼的字符较短的编码，出现频率较低的字 符以较⻓的编码，可以⼤⼤缩短总码⻓。 1 、前缀码 对每⼀个字符规定⼀个 0,1 串作为其代码，并要求任 ⼀字符的代码都不是其它字符代码的前缀。这种编码 称为 前缀码 。 0 4.4 哈夫曼编码 编码的前缀性质可以使译码⽅法⾮常简单。 表示 最优前缀码 的⼆叉树总是⼀棵 完全⼆叉树 ，即树 中任⼀结点都有 2 个⼉⼦结点。 平均码⻓ 定义为： 使平均码⻓达到最⼩的前缀码编码⽅案称为给定编码 字符集 C 的 最优前缀码 。 0 4.4 哈夫曼编码 2 、构造哈夫曼编码 哈夫曼提出构造最优前缀码的贪⼼算法，由此产⽣的 编码⽅案称为 哈夫曼编码 。 哈夫曼算法以⾃底向上的⽅式构造表示最优前缀码的 ⼆叉树 T 。 算法以 | C| 个叶结点开始，执⾏ | C| － 1 次的 “ 合并 ” 运算 后产⽣最终所要求的树 T 。 0 4.4 哈夫曼编码 在书上给出的算法 huf fm a nT re e 中，编码字符集中每 ⼀字符 c 的频率是 f(c ) 。 以 f 为键值的优先队列 Q ⽤在 贪 ⼼选择 时有效地确定算法当前要合并的 2 棵具有最⼩频 率的树。⼀旦 2 棵具有最⼩频率的树合并后，产⽣⼀棵 新的树，其频率为合并的 2 棵树的频率之和，并将新树 插⼊优先队列 Q 。经过 n － 1 次的合并后，优先队列中只 剩下⼀棵树，即所要求的树 T 。 算法 huf fm a nT re e ⽤最⼩堆实现优先队列 Q 。初始化优 先队列需要 O (n) 计算时间，由于最⼩堆的 re m ove M i n 和 put 运算均需 O( l ogn ) 时间， n － 1 次的合并总共需要 O( nl ogn ) 计算时间。因此，关于 n 个字符的哈夫曼算法 的 计算时间 为 O( nl ogn ) 。 0 4.4 哈夫曼编码 3 、哈夫曼算法的正确性 要证明哈夫曼算法的正确性，只要证明最优前缀码问 题具有 贪⼼选择性质 和 最优⼦结构性质 。        (1)贪⼼选择性质        (2)最优⼦结构性质   0 4.5 单源最短路径 给定带权有向图 G =(V ,E ) ，其中每条边的权是⾮负实 数。另外，还给定 V 中的⼀个顶点，称为 源 。现在要计 算从源到所有其它各顶点的 最短路⻓度 。这⾥路的⻓ 度是指路上各边权之和。这个问题通常称为 单源最短 路径问题 。    1、算法基本思想 D i j ks t ra 算法是解单源最短路径问题的贪⼼算法。     0 4.5 单源最短路径 其 基本思想 是，设置顶点集合 S 并不断地作 贪⼼选择 来扩充这个集合。⼀个顶点属于集合 S 当且仅当从源到 该顶点的最短路径⻓度已知。 初始时， S 中仅含有源。设 u 是 G 的某⼀个顶点，把从 源到 u 且中间只经过 S 中顶点的路称为从源到 u 的特殊路 径，并⽤数组 di s t 记录当前每个顶点所对应的最短特殊 路径⻓度。 D i j ks t ra 算法每次从 V -S 中取出具有最短特殊 路⻓度的顶点 u ，将 u 添加到 S 中，同时对数组 di s t 作必 要的修改。⼀旦 S 包含了所有 V 中顶点， di s t 就记录了从 源到所有其它顶点之间的最短路径⻓度。 0 4.5 单源最短路径 例如 ，对右图中的有向 图，应⽤ D i j ks t ra 算法计 算从源顶点 1 到其它顶点 间最短路径的过程列在 下⻚的表中。 0 4.5 单源最短路径 603050105{1,2,4,3,5}4 603050103{1,2,4,3}3 903050104{1,2,4}2 1003060102{1,2}1 10030m a xi nt10-{1}初始 d i s t[5]d i s t[4]d i s t[3]d i s t[2]uS迭代 D i j ks t ra 算法的迭代过程： 0 4.5 单源最短路径 2 、算法的正确性和计算复杂性 (1)贪⼼选择性质 (2)最优⼦结构性质 (3)计算复杂性 对于具有 n 个顶点和 e 条边的带权有向图，如果⽤带权 邻接矩阵表示这个图，那么 D i j ks t ra 算法的主循环体需 要 时间。这个循环需要执⾏ n-1 次，所以完成循环需 要 时间。算法的其余部分所需要时间不超过 。 0 4.6 最⼩⽣成树 设 G =(V ,E ) 是⽆向连通带权图，即⼀个 ⽹络 。 E 中每 条边 (v ,w ) 的权为 c [v][w ] 。如果 G 的⼦图 G’ 是⼀棵包含 G 的所有顶点的树，则称 G’ 为 G 的⽣成树。⽣成树上各边 权的总和称为该⽣成树的 耗费 。在 G 的所有⽣成树中， 耗费最⼩的⽣成树称为 G 的 最⼩⽣成树 。 ⽹络的最⼩⽣成树在实际中有⼴泛应⽤。 例如 ，在设 计通信⽹络时，⽤图的顶点表示城市，⽤边 (v ,w ) 的 权 c [v][w ] 表示建⽴城市 v 和城市 w 之间的通信线路所需 的费⽤，则最⼩⽣成树就给出了建⽴通信⽹络的最经 济的⽅案。 0 4.6 最⼩⽣成树 1 、最⼩⽣成树性质 ⽤贪⼼算法设计策略可以设计出构造最⼩⽣成树的有 效算法。本节介绍的构造最⼩⽣成树的 Prim 算法 和 K r u s k al 算法 都可以看作是应⽤贪⼼算法设计策略的例 ⼦。尽管这 2 个算法做贪⼼选择的⽅式不同，它们都利 ⽤了下⾯的 最⼩⽣成树性质 ： 设 G =(V ,E ) 是连通带权图， U 是 V 的真⼦集。如果 (u,v) \u0000 E ，且 u \u0000 U ， v \u0000 V -U ，且在所有这样的边中， (u,v) 的权 c [u][v] 最⼩，那么⼀定存在 G 的⼀棵最⼩⽣成树， 它以 (u,v) 为其中⼀条边。这个性质有时也称为 MST 性 质 。 0 4.6 最⼩⽣成树 2 、 Prim算法 设 G =(V ,E ) 是连通带权图， V ={1,2,…,n} 。 构造 G 的最⼩⽣成树的 P ri m 算法的 基本思想 是：⾸先 置 S ={1} ，然后，只要 S 是 V 的真⼦集，就作如下的 贪 ⼼选择 ： 选取满⾜条件 i \u0000 S ， j \u0000 V -S ，且 c [i ][j ] 最⼩的 边，将顶点 j 添加到 S 中。这个过程⼀直进⾏到 S =V 时为 ⽌。 在这个过程中选取到的所有边恰好构成 G 的⼀棵 最⼩ ⽣成树 。 0 4.2 贪⼼算法的基本要素 对于 0-1 背包问题 ，贪⼼选择之所以不能得到最优解是因 为在这种情况下，它⽆法保证最终能将背包装满，部分闲 置的背包空间使每公⽄背包空间的价值降低了。事实上， 在考虑 0-1 背包问题时，应⽐较选择该物品和不选择该物 品所导致的最终⽅案，然后再作出最好选择。由此就导出 许多互相重叠的⼦问题。这正是该问题可⽤ 动态规划算法 求解的另⼀重要特征。 实际上也是如此，动态规划算法的确可以有效地解 0-1 背 包问题。 0 4.3 最优装载 有⼀批集装箱要装上⼀艘载重量为 c 的轮船。其中集 装箱 i 的重量为 Wi 。最优装载问题要求确定在装载体积 不受限制的情况下，将尽可能多的集装箱装上轮船。 1 、算法描述 最优装载问题可⽤贪⼼算法求解。采⽤重量最轻者先 装的贪⼼选择策略，可产⽣最优装载问题的最优解。 具体算法描述如下⻚。 0 4.3 最优装载 • publ i c s t a t i c fl oa t l oad i n g (fl oa t c , fl oa t [] w , i nt [] x) • { • i nt n=w .l e ngt h; • E l e m e nt [] d = ne w E l e m e nt [n]; • for ( i nt i = 0; i < n; i ++) • d[i ] = ne w E l e m e nt (w [i ],i ); • M e r ge S ort . m e r ge S ort (d); • fl oa t opt =0; • for ( i nt i = 0; i < n; i ++) x[i ] = 0; • for ( i nt i = 0; i < n & & d[i ].w <= c ; i ++) { • x[d[i ].i ] = 1; • opt +=d[i ].w ; • c -= d[i ].w ; • } • re t urn opt ; • } 其中 El e me n t 类说明为 参 ⻅本书 P 1 15 0 4.3 最优装载 2 、贪⼼选择性质 可以证明最优装载问题具有贪⼼选择性质 。 3 、最优⼦结构性质 最优装载问题具有最优⼦结构性质。 由最优装载问题的贪⼼选择性质和最优⼦结构性质， 容易证明算法 l oad i n g 的正确性。 算法 l oad i n g 的主要计算量在于将集装箱依其重量从 ⼩到⼤排序，故算法所需的计算时间为 O( n l ogn ) 。 0 4.4 哈夫曼编码 哈夫曼编码 是⼴泛地⽤于数据⽂件压缩的⼗分有效的 编码⽅法。其压缩率通常在 20% ～ 90% 之间。哈夫曼编 码算法⽤字符在⽂件中出现的频率表来建⽴⼀个 ⽤ 0 ， 1 串表示各字符的最优表示⽅式。 给出现频率⾼的字符较短的编码，出现频率较低的字 符以较⻓的编码，可以⼤⼤缩短总码⻓。 1 、前缀码 对每⼀个字符规定⼀个 0,1 串作为其代码，并要求任 ⼀字符的代码都不是其它字符代码的前缀。这种编码 称为 前缀码 。 0 4.4 哈夫曼编码 编码的前缀性质可以使译码⽅法⾮常简单。 表示 最优前缀码 的⼆叉树总是⼀棵 完全⼆叉树 ，即树 中任⼀结点都有 2 个⼉⼦结点。 平均码⻓ 定义为： 使平均码⻓达到最⼩的前缀码编码⽅案称为给定编码 字符集 C 的 最优前缀码 。 0 4.4 哈夫曼编码 2 、构造哈夫曼编码 哈夫曼提出构造最优前缀码的贪⼼算法，由此产⽣的 编码⽅案称为 哈夫曼编码 。 哈夫曼算法以⾃底向上的⽅式构造表示最优前缀码的 ⼆叉树 T 。 算法以 | C| 个叶结点开始，执⾏ | C| － 1 次的 “ 合并 ” 运算 后产⽣最终所要求的树 T 。 0 4.4 哈夫曼编码 在书上给出的算法 huf fm a nT re e 中，编码字符集中每 ⼀字符 c 的频率是 f(c ) 。 以 f 为键值的优先队列 Q ⽤在 贪 ⼼选择 时有效地确定算法当前要合并的 2 棵具有最⼩频 率的树。⼀旦 2 棵具有最⼩频率的树合并后，产⽣⼀棵 新的树，其频率为合并的 2 棵树的频率之和，并将新树 插⼊优先队列 Q 。经过 n － 1 次的合并后，优先队列中只 剩下⼀棵树，即所要求的树 T 。 算法 huf fm a nT re e ⽤最⼩堆实现优先队列 Q 。初始化优 先队列需要 O (n) 计算时间，由于最⼩堆的 re m ove M i n 和 put 运算均需 O( l ogn ) 时间， n － 1 次的合并总共需要 O( nl ogn ) 计算时间。因此，关于 n 个字符的哈夫曼算法 的 计算时间 为 O( nl ogn ) 。 0 4.4 哈夫曼编码 3 、哈夫曼算法的正确性 要证明哈夫曼算法的正确性，只要证明最优前缀码问 题具有 贪⼼选择性质 和 最优⼦结构性质 。        (1)贪⼼选择性质        (2)最优⼦结构性质   0 4.5 单源最短路径 给定带权有向图 G =(V ,E ) ，其中每条边的权是⾮负实 数。另外，还给定 V 中的⼀个顶点，称为 源 。现在要计 算从源到所有其它各顶点的 最短路⻓度 。这⾥路的⻓ 度是指路上各边权之和。这个问题通常称为 单源最短 路径问题 。    1、算法基本思想 D i j ks t ra 算法是解单源最短路径问题的贪⼼算法。     0 4.5 单源最短路径 其 基本思想 是，设置顶点集合 S 并不断地作 贪⼼选择 来扩充这个集合。⼀个顶点属于集合 S 当且仅当从源到 该顶点的最短路径⻓度已知。 初始时， S 中仅含有源。设 u 是 G 的某⼀个顶点，把从 源到 u 且中间只经过 S 中顶点的路称为从源到 u 的特殊路 径，并⽤数组 di s t 记录当前每个顶点所对应的最短特殊 路径⻓度。 D i j ks t ra 算法每次从 V -S 中取出具有最短特殊 路⻓度的顶点 u ，将 u 添加到 S 中，同时对数组 di s t 作必 要的修改。⼀旦 S 包含了所有 V 中顶点， di s t 就记录了从 源到所有其它顶点之间的最短路径⻓度。 0 4.5 单源最短路径 例如 ，对右图中的有向 图，应⽤ D i j ks t ra 算法计 算从源顶点 1 到其它顶点 间最短路径的过程列在 下⻚的表中。 0 4.5 单源最短路径 603050105{1,2,4,3,5}4 603050103{1,2,4,3}3 903050104{1,2,4}2 1003060102{1,2}1 10030m a xi nt10-{1}初始 d i s t[5]d i s t[4]d i s t[3]d i s t[2]uS迭代 D i j ks t ra 算法的迭代过程： 0 4.5 单源最短路径 2 、算法的正确性和计算复杂性 (1)贪⼼选择性质 (2)最优⼦结构性质 (3)计算复杂性 对于具有 n 个顶点和 e 条边的带权有向图，如果⽤带权 邻接矩阵表示这个图，那么 D i j ks t ra 算法的主循环体需 要 时间。这个循环需要执⾏ n-1 次，所以完成循环需 要 时间。算法的其余部分所需要时间不超过 。 0 4.6 最⼩⽣成树 设 G =(V ,E ) 是⽆向连通带权图，即⼀个 ⽹络 。 E 中每 条边 (v ,w ) 的权为 c [v][w ] 。如果 G 的⼦图 G’ 是⼀棵包含 G 的所有顶点的树，则称 G’ 为 G 的⽣成树。⽣成树上各边 权的总和称为该⽣成树的 耗费 。在 G 的所有⽣成树中， 耗费最⼩的⽣成树称为 G 的 最⼩⽣成树 。 ⽹络的最⼩⽣成树在实际中有⼴泛应⽤。 例如 ，在设 计通信⽹络时，⽤图的顶点表示城市，⽤边 (v ,w ) 的 权 c [v][w ] 表示建⽴城市 v 和城市 w 之间的通信线路所需 的费⽤，则最⼩⽣成树就给出了建⽴通信⽹络的最经 济的⽅案。 0 4.6 最⼩⽣成树 1 、最⼩⽣成树性质 ⽤贪⼼算法设计策略可以设计出构造最⼩⽣成树的有 效算法。本节介绍的构造最⼩⽣成树的 Prim 算法 和 K r u s k al 算法 都可以看作是应⽤贪⼼算法设计策略的例 ⼦。尽管这 2 个算法做贪⼼选择的⽅式不同，它们都利 ⽤了下⾯的 最⼩⽣成树性质 ： 设 G =(V ,E ) 是连通带权图， U 是 V 的真⼦集。如果 (u,v) \u0000 E ，且 u \u0000 U ， v \u0000 V -U ，且在所有这样的边中， (u,v) 的权 c [u][v] 最⼩，那么⼀定存在 G 的⼀棵最⼩⽣成树， 它以 (u,v) 为其中⼀条边。这个性质有时也称为 MST 性 质 。 0 4.6 最⼩⽣成树 2 、 Prim算法 设 G =(V ,E ) 是连通带权图， V ={1,2,…,n} 。 构造 G 的最⼩⽣成树的 P ri m 算法的 基本思想 是：⾸先 置 S ={1} ，然后，只要 S 是 V 的真⼦集，就作如下的 贪 ⼼选择 ： 选取满⾜条件 i \u0000 S ， j \u0000 V -S ，且 c [i ][j ] 最⼩的 边，将顶点 j 添加到 S 中。这个过程⼀直进⾏到 S =V 时为 ⽌。 在这个过程中选取到的所有边恰好构成 G 的⼀棵 最⼩ ⽣成树 。 0 4.2 贪⼼算法的基本要素 对于 0-1 背包问题 ，贪⼼选择之所以不能得到最优解是因 为在这种情况下，它⽆法保证最终能将背包装满，部分闲 置的背包空间使每公⽄背包空间的价值降低了。事实上， 在考虑 0-1 背包问题时，应⽐较选择该物品和不选择该物 品所导致的最终⽅案，然后再作出最好选择。由此就导出 许多互相重叠的⼦问题。这正是该问题可⽤ 动态规划算法 求解的另⼀重要特征。 实际上也是如此，动态规划算法的确可以有效地解 0-1 背 包问题。 0 4.3 最优装载 有⼀批集装箱要装上⼀艘载重量为 c 的轮船。其中集 装箱 i 的重量为 Wi 。最优装载问题要求确定在装载体积 不受限制的情况下，将尽可能多的集装箱装上轮船。 1 、算法描述 最优装载问题可⽤贪⼼算法求解。采⽤重量最轻者先 装的贪⼼选择策略，可产⽣最优装载问题的最优解。 具体算法描述如下⻚。 0 4.3 最优装载 • publ i c s t a t i c fl oa t l oad i n g (fl oa t c , fl oa t [] w , i nt [] x) • { • i nt n=w .l e ngt h; • E l e m e nt [] d = ne w E l e m e nt [n]; • for ( i nt i = 0; i < n; i ++) • d[i ] = ne w E l e m e nt (w [i ],i ); • M e r ge S ort . m e r ge S ort (d); • fl oa t opt =0; • for ( i nt i = 0; i < n; i ++) x[i ] = 0; • for ( i nt i = 0; i < n & & d[i ].w <= c ; i ++) { • x[d[i ].i ] = 1; • opt +=d[i ].w ; • c -= d[i ].w ; • } • re t urn opt ; • } 其中 El e me n t 类说明为 参 ⻅本书 P 1 15 0 4.3 最优装载 2 、贪⼼选择性质 可以证明最优装载问题具有贪⼼选择性质 。 3 、最优⼦结构性质 最优装载问题具有最优⼦结构性质。 由最优装载问题的贪⼼选择性质和最优⼦结构性质， 容易证明算法 l oad i n g 的正确性。 算法 l oad i n g 的主要计算量在于将集装箱依其重量从 ⼩到⼤排序，故算法所需的计算时间为 O( n l ogn ) 。 0 4.4 哈夫曼编码 哈夫曼编码 是⼴泛地⽤于数据⽂件压缩的⼗分有效的 编码⽅法。其压缩率通常在 20% ～ 90% 之间。哈夫曼编 码算法⽤字符在⽂件中出现的频率表来建⽴⼀个 ⽤ 0 ， 1 串表示各字符的最优表示⽅式。 给出现频率⾼的字符较短的编码，出现频率较低的字 符以较⻓的编码，可以⼤⼤缩短总码⻓。 1 、前缀码 对每⼀个字符规定⼀个 0,1 串作为其代码，并要求任 ⼀字符的代码都不是其它字符代码的前缀。这种编码 称为 前缀码 。 0 4.4 哈夫曼编码 编码的前缀性质可以使译码⽅法⾮常简单。 表示 最优前缀码 的⼆叉树总是⼀棵 完全⼆叉树 ，即树 中任⼀结点都有 2 个⼉⼦结点。 平均码⻓ 定义为： 使平均码⻓达到最⼩的前缀码编码⽅案称为给定编码 字符集 C 的 最优前缀码 。 0 4.4 哈夫曼编码 2 、构造哈夫曼编码 哈夫曼提出构造最优前缀码的贪⼼算法，由此产⽣的 编码⽅案称为 哈夫曼编码 。 哈夫曼算法以⾃底向上的⽅式构造表示最优前缀码的 ⼆叉树 T 。 算法以 | C| 个叶结点开始，执⾏ | C| － 1 次的 “ 合并 ” 运算 后产⽣最终所要求的树 T 。 0 4.4 哈夫曼编码 在书上给出的算法 huf fm a nT re e 中，编码字符集中每 ⼀字符 c 的频率是 f(c ) 。 以 f 为键值的优先队列 Q ⽤在 贪 ⼼选择 时有效地确定算法当前要合并的 2 棵具有最⼩频 率的树。⼀旦 2 棵具有最⼩频率的树合并后，产⽣⼀棵 新的树，其频率为合并的 2 棵树的频率之和，并将新树 插⼊优先队列 Q 。经过 n － 1 次的合并后，优先队列中只 剩下⼀棵树，即所要求的树 T 。 算法 huf fm a nT re e ⽤最⼩堆实现优先队列 Q 。初始化优 先队列需要 O (n) 计算时间，由于最⼩堆的 re m ove M i n 和 put 运算均需 O( l ogn ) 时间， n － 1 次的合并总共需要 O( nl ogn ) 计算时间。因此，关于 n 个字符的哈夫曼算法 的 计算时间 为 O( nl ogn ) 。 0 4.4 哈夫曼编码 3 、哈夫曼算法的正确性 要证明哈夫曼算法的正确性，只要证明最优前缀码问 题具有 贪⼼选择性质 和 最优⼦结构性质 。        (1)贪⼼选择性质        (2)最优⼦结构性质   0 4.5 单源最短路径 给定带权有向图 G =(V ,E ) ，其中每条边的权是⾮负实 数。另外，还给定 V 中的⼀个顶点，称为 源 。现在要计 算从源到所有其它各顶点的 最短路⻓度 。这⾥路的⻓ 度是指路上各边权之和。这个问题通常称为 单源最短 路径问题 。    1、算法基本思想 D i j ks t ra 算法是解单源最短路径问题的贪⼼算法。     0 4.5 单源最短路径 其 基本思想 是，设置顶点集合 S 并不断地作 贪⼼选择 来扩充这个集合。⼀个顶点属于集合 S 当且仅当从源到 该顶点的最短路径⻓度已知。 初始时， S 中仅含有源。设 u 是 G 的某⼀个顶点，把从 源到 u 且中间只经过 S 中顶点的路称为从源到 u 的特殊路 径，并⽤数组 di s t 记录当前每个顶点所对应的最短特殊 路径⻓度。 D i j ks t ra 算法每次从 V -S 中取出具有最短特殊 路⻓度的顶点 u ，将 u 添加到 S 中，同时对数组 di s t 作必 要的修改。⼀旦 S 包含了所有 V 中顶点， di s t 就记录了从 源到所有其它顶点之间的最短路径⻓度。 0 4.5 单源最短路径 例如 ，对右图中的有向 图，应⽤ D i j ks t ra 算法计 算从源顶点 1 到其它顶点 间最短路径的过程列在 下⻚的表中。 0 4.5 单源最短路径 603050105{1,2,4,3,5}4 603050103{1,2,4,3}3 903050104{1,2,4}2 1003060102{1,2}1 10030m a xi nt10-{1}初始 d i s t[5]d i s t[4]d i s t[3]d i s t[2]uS迭代 D i j ks t ra 算法的迭代过程： 0 4.5 单源最短路径 2 、算法的正确性和计算复杂性 (1)贪⼼选择性质 (2)最优⼦结构性质 (3)计算复杂性 对于具有 n 个顶点和 e 条边的带权有向图，如果⽤带权 邻接矩阵表示这个图，那么 D i j ks t ra 算法的主循环体需 要 时间。这个循环需要执⾏ n-1 次，所以完成循环需 要 时间。算法的其余部分所需要时间不超过 。 0 4.6 最⼩⽣成树 设 G =(V ,E ) 是⽆向连通带权图，即⼀个 ⽹络 。 E 中每 条边 (v ,w ) 的权为 c [v][w ] 。如果 G 的⼦图 G’ 是⼀棵包含 G 的所有顶点的树，则称 G’ 为 G 的⽣成树。⽣成树上各边 权的总和称为该⽣成树的 耗费 。在 G 的所有⽣成树中， 耗费最⼩的⽣成树称为 G 的 最⼩⽣成树 。 ⽹络的最⼩⽣成树在实际中有⼴泛应⽤。 例如 ，在设 计通信⽹络时，⽤图的顶点表示城市，⽤边 (v ,w ) 的 权 c [v][w ] 表示建⽴城市 v 和城市 w 之间的通信线路所需 的费⽤，则最⼩⽣成树就给出了建⽴通信⽹络的最经 济的⽅案。 0 4.6 最⼩⽣成树 1 、最⼩⽣成树性质 ⽤贪⼼算法设计策略可以设计出构造最⼩⽣成树的有 效算法。本节介绍的构造最⼩⽣成树的 Prim 算法 和 K r u s k al 算法 都可以看作是应⽤贪⼼算法设计策略的例 ⼦。尽管这 2 个算法做贪⼼选择的⽅式不同，它们都利 ⽤了下⾯的 最⼩⽣成树性质 ： 设 G =(V ,E ) 是连通带权图， U 是 V 的真⼦集。如果 (u,v) \u0000 E ，且 u \u0000 U ， v \u0000 V -U ，且在所有这样的边中， (u,v) 的权 c [u][v] 最⼩，那么⼀定存在 G 的⼀棵最⼩⽣成树， 它以 (u,v) 为其中⼀条边。这个性质有时也称为 MST 性 质 。 0 4.6 最⼩⽣成树 2 、 Prim算法 设 G =(V ,E ) 是连通带权图， V ={1,2,…,n} 。 构造 G 的最⼩⽣成树的 P ri m 算法的 基本思想 是：⾸先 置 S ={1} ，然后，只要 S 是 V 的真⼦集，就作如下的 贪 ⼼选择 ： 选取满⾜条件 i \u0000 S ， j \u0000 V -S ，且 c [i ][j ] 最⼩的 边，将顶点 j 添加到 S 中。这个过程⼀直进⾏到 S =V 时为 ⽌。 在这个过程中选取到的所有边恰好构成 G 的⼀棵 最⼩ ⽣成树 。 0 4.2 贪⼼算法的基本要素 对于 0-1 背包问题 ，贪⼼选择之所以不能得到最优解是因 为在这种情况下，它⽆法保证最终能将背包装满，部分闲 置的背包空间使每公⽄背包空间的价值降低了。事实上， 在考虑 0-1 背包问题时，应⽐较选择该物品和不选择该物 品所导致的最终⽅案，然后再作出最好选择。由此就导出 许多互相重叠的⼦问题。这正是该问题可⽤ 动态规划算法 求解的另⼀重要特征。 实际上也是如此，动态规划算法的确可以有效地解 0-1 背 包问题。 0 4.3 最优装载 有⼀批集装箱要装上⼀艘载重量为 c 的轮船。其中集 装箱 i 的重量为 Wi 。最优装载问题要求确定在装载体积 不受限制的情况下，将尽可能多的集装箱装上轮船。 1 、算法描述 最优装载问题可⽤贪⼼算法求解。采⽤重量最轻者先 装的贪⼼选择策略，可产⽣最优装载问题的最优解。 具体算法描述如下⻚。 0 4.3 最优装载 • publ i c s t a t i c fl oa t l oad i n g (fl oa t c , fl oa t [] w , i nt [] x) • { • i nt n=w .l e ngt h; • E l e m e nt [] d = ne w E l e m e nt [n]; • for ( i nt i = 0; i < n; i ++) • d[i ] = ne w E l e m e nt (w [i ],i ); • M e r ge S ort . m e r ge S ort (d); • fl oa t opt =0; • for ( i nt i = 0; i < n; i ++) x[i ] = 0; • for ( i nt i = 0; i < n & & d[i ].w <= c ; i ++) { • x[d[i ].i ] = 1; • opt +=d[i ].w ; • c -= d[i ].w ; • } • re t urn opt ; • } 其中 El e me n t 类说明为 参 ⻅本书 P 1 15 0 4.3 最优装载 2 、贪⼼选择性质 可以证明最优装载问题具有贪⼼选择性质 。 3 、最优⼦结构性质 最优装载问题具有最优⼦结构性质。 由最优装载问题的贪⼼选择性质和最优⼦结构性质， 容易证明算法 l oad i n g 的正确性。 算法 l oad i n g 的主要计算量在于将集装箱依其重量从 ⼩到⼤排序，故算法所需的计算时间为 O( n l ogn ) 。 0 4.4 哈夫曼编码 哈夫曼编码 是⼴泛地⽤于数据⽂件压缩的⼗分有效的 编码⽅法。其压缩率通常在 20% ～ 90% 之间。哈夫曼编 码算法⽤字符在⽂件中出现的频率表来建⽴⼀个 ⽤ 0 ， 1 串表示各字符的最优表示⽅式。 给出现频率⾼的字符较短的编码，出现频率较低的字 符以较⻓的编码，可以⼤⼤缩短总码⻓。 1 、前缀码 对每⼀个字符规定⼀个 0,1 串作为其代码，并要求任 ⼀字符的代码都不是其它字符代码的前缀。这种编码 称为 前缀码 。 0 4.4 哈夫曼编码 编码的前缀性质可以使译码⽅法⾮常简单。 表示 最优前缀码 的⼆叉树总是⼀棵 完全⼆叉树 ，即树 中任⼀结点都有 2 个⼉⼦结点。 平均码⻓ 定义为： 使平均码⻓达到最⼩的前缀码编码⽅案称为给定编码 字符集 C 的 最优前缀码 。 0 4.4 哈夫曼编码 2 、构造哈夫曼编码 哈夫曼提出构造最优前缀码的贪⼼算法，由此产⽣的 编码⽅案称为 哈夫曼编码 。 哈夫曼算法以⾃底向上的⽅式构造表示最优前缀码的 ⼆叉树 T 。 算法以 | C| 个叶结点开始，执⾏ | C| － 1 次的 “ 合并 ” 运算 后产⽣最终所要求的树 T 。 0 4.4 哈夫曼编码 在书上给出的算法 huf fm a nT re e 中，编码字符集中每 ⼀字符 c 的频率是 f(c ) 。 以 f 为键值的优先队列 Q ⽤在 贪 ⼼选择 时有效地确定算法当前要合并的 2 棵具有最⼩频 率的树。⼀旦 2 棵具有最⼩频率的树合并后，产⽣⼀棵 新的树，其频率为合并的 2 棵树的频率之和，并将新树 插⼊优先队列 Q 。经过 n － 1 次的合并后，优先队列中只 剩下⼀棵树，即所要求的树 T 。 算法 huf fm a nT re e ⽤最⼩堆实现优先队列 Q 。初始化优 先队列需要 O (n) 计算时间，由于最⼩堆的 re m ove M i n 和 put 运算均需 O( l ogn ) 时间， n － 1 次的合并总共需要 O( nl ogn ) 计算时间。因此，关于 n 个字符的哈夫曼算法 的 计算时间 为 O( nl ogn ) 。 0 4.4 哈夫曼编码 3 、哈夫曼算法的正确性 要证明哈夫曼算法的正确性，只要证明最优前缀码问 题具有 贪⼼选择性质 和 最优⼦结构性质 。        (1)贪⼼选择性质        (2)最优⼦结构性质   0 4.5 单源最短路径 给定带权有向图 G =(V ,E ) ，其中每条边的权是⾮负实 数。另外，还给定 V 中的⼀个顶点，称为 源 。现在要计 算从源到所有其它各顶点的 最短路⻓度 。这⾥路的⻓ 度是指路上各边权之和。这个问题通常称为 单源最短 路径问题 。    1、算法基本思想 D i j ks t ra 算法是解单源最短路径问题的贪⼼算法。     0 4.5 单源最短路径 其 基本思想 是，设置顶点集合 S 并不断地作 贪⼼选择 来扩充这个集合。⼀个顶点属于集合 S 当且仅当从源到 该顶点的最短路径⻓度已知。 初始时， S 中仅含有源。设 u 是 G 的某⼀个顶点，把从 源到 u 且中间只经过 S 中顶点的路称为从源到 u 的特殊路 径，并⽤数组 di s t 记录当前每个顶点所对应的最短特殊 路径⻓度。 D i j ks t ra 算法每次从 V -S 中取出具有最短特殊 路⻓度的顶点 u ，将 u 添加到 S 中，同时对数组 di s t 作必 要的修改。⼀旦 S 包含了所有 V 中顶点， di s t 就记录了从 源到所有其它顶点之间的最短路径⻓度。 0 4.5 单源最短路径 例如 ，对右图中的有向 图，应⽤ D i j ks t ra 算法计 算从源顶点 1 到其它顶点 间最短路径的过程列在 下⻚的表中。 0 4.5 单源最短路径 603050105{1,2,4,3,5}4 603050103{1,2,4,3}3 903050104{1,2,4}2 1003060102{1,2}1 10030m a xi nt10-{1}初始 d i s t[5]d i s t[4]d i s t[3]d i s t[2]uS迭代 D i j ks t ra 算法的迭代过程： 0 4.5 单源最短路径 2 、算法的正确性和计算复杂性 (1)贪⼼选择性质 (2)最优⼦结构性质 (3)计算复杂性 对于具有 n 个顶点和 e 条边的带权有向图，如果⽤带权 邻接矩阵表示这个图，那么 D i j ks t ra 算法的主循环体需 要 时间。这个循环需要执⾏ n-1 次，所以完成循环需 要 时间。算法的其余部分所需要时间不超过 。 0 4.6 最⼩⽣成树 设 G =(V ,E ) 是⽆向连通带权图，即⼀个 ⽹络 。 E 中每 条边 (v ,w ) 的权为 c [v][w ] 。如果 G 的⼦图 G’ 是⼀棵包含 G 的所有顶点的树，则称 G’ 为 G 的⽣成树。⽣成树上各边 权的总和称为该⽣成树的 耗费 。在 G 的所有⽣成树中， 耗费最⼩的⽣成树称为 G 的 最⼩⽣成树 。 ⽹络的最⼩⽣成树在实际中有⼴泛应⽤。 例如 ，在设 计通信⽹络时，⽤图的顶点表示城市，⽤边 (v ,w ) 的 权 c [v][w ] 表示建⽴城市 v 和城市 w 之间的通信线路所需 的费⽤，则最⼩⽣成树就给出了建⽴通信⽹络的最经 济的⽅案。 0 4.6 最⼩⽣成树 1 、最⼩⽣成树性质 ⽤贪⼼算法设计策略可以设计出构造最⼩⽣成树的有 效算法。本节介绍的构造最⼩⽣成树的 Prim 算法 和 K r u s k al 算法 都可以看作是应⽤贪⼼算法设计策略的例 ⼦。尽管这 2 个算法做贪⼼选择的⽅式不同，它们都利 ⽤了下⾯的 最⼩⽣成树性质 ： 设 G =(V ,E ) 是连通带权图， U 是 V 的真⼦集。如果 (u,v) \u0000 E ，且 u \u0000 U ， v \u0000 V -U ，且在所有这样的边中， (u,v) 的权 c [u][v] 最⼩，那么⼀定存在 G 的⼀棵最⼩⽣成树， 它以 (u,v) 为其中⼀条边。这个性质有时也称为 MST 性 质 。 0 4.6 最⼩⽣成树 2 、 Prim算法 设 G =(V ,E ) 是连通带权图， V ={1,2,…,n} 。 构造 G 的最⼩⽣成树的 P ri m 算法的 基本思想 是：⾸先 置 S ={1} ，然后，只要 S 是 V 的真⼦集，就作如下的 贪 ⼼选择 ： 选取满⾜条件 i \u0000 S ， j \u0000 V -S ，且 c [i ][j ] 最⼩的 边，将顶点 j 添加到 S 中。这个过程⼀直进⾏到 S =V 时为 ⽌。 在这个过程中选取到的所有边恰好构成 G 的⼀棵 最⼩ ⽣成树 。 0 4.2 贪⼼算法的基本要素 对于 0-1 背包问题 ，贪⼼选择之所以不能得到最优解是因 为在这种情况下，它⽆法保证最终能将背包装满，部分闲 置的背包空间使每公⽄背包空间的价值降低了。事实上， 在考虑 0-1 背包问题时，应⽐较选择该物品和不选择该物 品所导致的最终⽅案，然后再作出最好选择。由此就导出 许多互相重叠的⼦问题。这正是该问题可⽤ 动态规划算法 求解的另⼀重要特征。 实际上也是如此，动态规划算法的确可以有效地解 0-1 背 包问题。 0 4.3 最优装载 有⼀批集装箱要装上⼀艘载重量为 c 的轮船。其中集 装箱 i 的重量为 Wi 。最优装载问题要求确定在装载体积 不受限制的情况下，将尽可能多的集装箱装上轮船。 1 、算法描述 最优装载问题可⽤贪⼼算法求解。采⽤重量最轻者先 装的贪⼼选择策略，可产⽣最优装载问题的最优解。 具体算法描述如下⻚。 0 4.3 最优装载 • publ i c s t a t i c fl oa t l oad i n g (fl oa t c , fl oa t [] w , i nt [] x) • { • i nt n=w .l e ngt h; • E l e m e nt [] d = ne w E l e m e nt [n]; • for ( i nt i = 0; i < n; i ++) • d[i ] = ne w E l e m e nt (w [i ],i ); • M e r ge S ort . m e r ge S ort (d); • fl oa t opt =0; • for ( i nt i = 0; i < n; i ++) x[i ] = 0; • for ( i nt i = 0; i < n & & d[i ].w <= c ; i ++) { • x[d[i ].i ] = 1; • opt +=d[i ].w ; • c -= d[i ].w ; • } • re t urn opt ; • } 其中 El e me n t 类说明为 参 ⻅本书 P 1 15 0 4.3 最优装载 2 、贪⼼选择性质 可以证明最优装载问题具有贪⼼选择性质 。 3 、最优⼦结构性质 最优装载问题具有最优⼦结构性质。 由最优装载问题的贪⼼选择性质和最优⼦结构性质， 容易证明算法 l oad i n g 的正确性。 算法 l oad i n g 的主要计算量在于将集装箱依其重量从 ⼩到⼤排序，故算法所需的计算时间为 O( n l ogn ) 。 0 4.4 哈夫曼编码 哈夫曼编码 是⼴泛地⽤于数据⽂件压缩的⼗分有效的 编码⽅法。其压缩率通常在 20% ～ 90% 之间。哈夫曼编 码算法⽤字符在⽂件中出现的频率表来建⽴⼀个 ⽤ 0 ， 1 串表示各字符的最优表示⽅式。 给出现频率⾼的字符较短的编码，出现频率较低的字 符以较⻓的编码，可以⼤⼤缩短总码⻓。 1 、前缀码 对每⼀个字符规定⼀个 0,1 串作为其代码，并要求任 ⼀字符的代码都不是其它字符代码的前缀。这种编码 称为 前缀码 。 0 4.4 哈夫曼编码 编码的前缀性质可以使译码⽅法⾮常简单。 表示 最优前缀码 的⼆叉树总是⼀棵 完全⼆叉树 ，即树 中任⼀结点都有 2 个⼉⼦结点。 平均码⻓ 定义为： 使平均码⻓达到最⼩的前缀码编码⽅案称为给定编码 字符集 C 的 最优前缀码 。 0 4.4 哈夫曼编码 2 、构造哈夫曼编码 哈夫曼提出构造最优前缀码的贪⼼算法，由此产⽣的 编码⽅案称为 哈夫曼编码 。 哈夫曼算法以⾃底向上的⽅式构造表示最优前缀码的 ⼆叉树 T 。 算法以 | C| 个叶结点开始，执⾏ | C| － 1 次的 “ 合并 ” 运算 后产⽣最终所要求的树 T 。 0 4.4 哈夫曼编码 在书上给出的算法 huf fm a nT re e 中，编码字符集中每 ⼀字符 c 的频率是 f(c ) 。 以 f 为键值的优先队列 Q ⽤在 贪 ⼼选择 时有效地确定算法当前要合并的 2 棵具有最⼩频 率的树。⼀旦 2 棵具有最⼩频率的树合并后，产⽣⼀棵 新的树，其频率为合并的 2 棵树的频率之和，并将新树 插⼊优先队列 Q 。经过 n － 1 次的合并后，优先队列中只 剩下⼀棵树，即所要求的树 T 。 算法 huf fm a nT re e ⽤最⼩堆实现优先队列 Q 。初始化优 先队列需要 O (n) 计算时间，由于最⼩堆的 re m ove M i n 和 put 运算均需 O( l ogn ) 时间， n － 1 次的合并总共需要 O( nl ogn ) 计算时间。因此，关于 n 个字符的哈夫曼算法 的 计算时间 为 O( nl ogn ) 。 0 4.4 哈夫曼编码 3 、哈夫曼算法的正确性 要证明哈夫曼算法的正确性，只要证明最优前缀码问 题具有 贪⼼选择性质 和 最优⼦结构性质 。        (1)贪⼼选择性质        (2)最优⼦结构性质   0 4.5 单源最短路径 给定带权有向图 G =(V ,E ) ，其中每条边的权是⾮负实 数。另外，还给定 V 中的⼀个顶点，称为 源 。现在要计 算从源到所有其它各顶点的 最短路⻓度 。这⾥路的⻓ 度是指路上各边权之和。这个问题通常称为 单源最短 路径问题 。    1、算法基本思想 D i j ks t ra 算法是解单源最短路径问题的贪⼼算法。     0 4.5 单源最短路径 其 基本思想 是，设置顶点集合 S 并不断地作 贪⼼选择 来扩充这个集合。⼀个顶点属于集合 S 当且仅当从源到 该顶点的最短路径⻓度已知。 初始时， S 中仅含有源。设 u 是 G 的某⼀个顶点，把从 源到 u 且中间只经过 S 中顶点的路称为从源到 u 的特殊路 径，并⽤数组 di s t 记录当前每个顶点所对应的最短特殊 路径⻓度。 D i j ks t ra 算法每次从 V -S 中取出具有最短特殊 路⻓度的顶点 u ，将 u 添加到 S 中，同时对数组 di s t 作必 要的修改。⼀旦 S 包含了所有 V 中顶点， di s t 就记录了从 源到所有其它顶点之间的最短路径⻓度。 0 4.5 单源最短路径 例如 ，对右图中的有向 图，应⽤ D i j ks t ra 算法计 算从源顶点 1 到其它顶点 间最短路径的过程列在 下⻚的表中。 0 4.5 单源最短路径 603050105{1,2,4,3,5}4 603050103{1,2,4,3}3 903050104{1,2,4}2 1003060102{1,2}1 10030m a xi nt10-{1}初始 d i s t[5]d i s t[4]d i s t[3]d i s t[2]uS迭代 D i j ks t ra 算法的迭代过程： 0 4.5 单源最短路径 2 、算法的正确性和计算复杂性 (1)贪⼼选择性质 (2)最优⼦结构性质 (3)计算复杂性 对于具有 n 个顶点和 e 条边的带权有向图，如果⽤带权 邻接矩阵表示这个图，那么 D i j ks t ra 算法的主循环体需 要 时间。这个循环需要执⾏ n-1 次，所以完成循环需 要 时间。算法的其余部分所需要时间不超过 。 0 4.6 最⼩⽣成树 设 G =(V ,E ) 是⽆向连通带权图，即⼀个 ⽹络 。 E 中每 条边 (v ,w ) 的权为 c [v][w ] 。如果 G 的⼦图 G’ 是⼀棵包含 G 的所有顶点的树，则称 G’ 为 G 的⽣成树。⽣成树上各边 权的总和称为该⽣成树的 耗费 。在 G 的所有⽣成树中， 耗费最⼩的⽣成树称为 G 的 最⼩⽣成树 。 ⽹络的最⼩⽣成树在实际中有⼴泛应⽤。 例如 ，在设 计通信⽹络时，⽤图的顶点表示城市，⽤边 (v ,w ) 的 权 c [v][w ] 表示建⽴城市 v 和城市 w 之间的通信线路所需 的费⽤，则最⼩⽣成树就给出了建⽴通信⽹络的最经 济的⽅案。 0 4.6 最⼩⽣成树 1 、最⼩⽣成树性质 ⽤贪⼼算法设计策略可以设计出构造最⼩⽣成树的有 效算法。本节介绍的构造最⼩⽣成树的 Prim 算法 和 K r u s k al 算法 都可以看作是应⽤贪⼼算法设计策略的例 ⼦。尽管这 2 个算法做贪⼼选择的⽅式不同，它们都利 ⽤了下⾯的 最⼩⽣成树性质 ： 设 G =(V ,E ) 是连通带权图， U 是 V 的真⼦集。如果 (u,v) \u0000 E ，且 u \u0000 U ， v \u0000 V -U ，且在所有这样的边中， (u,v) 的权 c [u][v] 最⼩，那么⼀定存在 G 的⼀棵最⼩⽣成树， 它以 (u,v) 为其中⼀条边。这个性质有时也称为 MST 性 质 。 0 4.6 最⼩⽣成树 2 、 Prim算法 设 G =(V ,E ) 是连通带权图， V ={1,2,…,n} 。 构造 G 的最⼩⽣成树的 P ri m 算法的 基本思想 是：⾸先 置 S ={1} ，然后，只要 S 是 V 的真⼦集，就作如下的 贪 ⼼选择 ： 选取满⾜条件 i \u0000 S ， j \u0000 V -S ，且 c [i ][j ] 最⼩的 边，将顶点 j 添加到 S 中。这个过程⼀直进⾏到 S =V 时为 ⽌。 在这个过程中选取到的所有边恰好构成 G 的⼀棵 最⼩ ⽣成树 。 0 4.2 贪⼼算法的基本要素 对于 0-1 背包问题 ，贪⼼选择之所以不能得到最优解是因 为在这种情况下，它⽆法保证最终能将背包装满，部分闲 置的背包空间使每公⽄背包空间的价值降低了。事实上， 在考虑 0-1 背包问题时，应⽐较选择该物品和不选择该物 品所导致的最终⽅案，然后再作出最好选择。由此就导出 许多互相重叠的⼦问题。这正是该问题可⽤ 动态规划算法 求解的另⼀重要特征。 实际上也是如此，动态规划算法的确可以有效地解 0-1 背 包问题。 0 4.3 最优装载 有⼀批集装箱要装上⼀艘载重量为 c 的轮船。其中集 装箱 i 的重量为 Wi 。最优装载问题要求确定在装载体积 不受限制的情况下，将尽可能多的集装箱装上轮船。 1 、算法描述 最优装载问题可⽤贪⼼算法求解。采⽤重量最轻者先 装的贪⼼选择策略，可产⽣最优装载问题的最优解。 具体算法描述如下⻚。 0 4.3 最优装载 • publ i c s t a t i c fl oa t l oad i n g (fl oa t c , fl oa t [] w , i nt [] x) • { • i nt n=w .l e ngt h; • E l e m e nt [] d = ne w E l e m e nt [n]; • for ( i nt i = 0; i < n; i ++) • d[i ] = ne w E l e m e nt (w [i ],i ); • M e r ge S ort . m e r ge S ort (d); • fl oa t opt =0; • for ( i nt i = 0; i < n; i ++) x[i ] = 0; • for ( i nt i = 0; i < n & & d[i ].w <= c ; i ++) { • x[d[i ].i ] = 1; • opt +=d[i ].w ; • c -= d[i ].w ; • } • re t urn opt ; • } 其中 El e me n t 类说明为 参 ⻅本书 P 1 15 0 4.3 最优装载 2 、贪⼼选择性质 可以证明最优装载问题具有贪⼼选择性质 。 3 、最优⼦结构性质 最优装载问题具有最优⼦结构性质。 由最优装载问题的贪⼼选择性质和最优⼦结构性质， 容易证明算法 l oad i n g 的正确性。 算法 l oad i n g 的主要计算量在于将集装箱依其重量从 ⼩到⼤排序，故算法所需的计算时间为 O( n l ogn ) 。 0 4.4 哈夫曼编码 哈夫曼编码 是⼴泛地⽤于数据⽂件压缩的⼗分有效的 编码⽅法。其压缩率通常在 20% ～ 90% 之间。哈夫曼编 码算法⽤字符在⽂件中出现的频率表来建⽴⼀个 ⽤ 0 ， 1 串表示各字符的最优表示⽅式。 给出现频率⾼的字符较短的编码，出现频率较低的字 符以较⻓的编码，可以⼤⼤缩短总码⻓。 1 、前缀码 对每⼀个字符规定⼀个 0,1 串作为其代码，并要求任 ⼀字符的代码都不是其它字符代码的前缀。这种编码 称为 前缀码 。 0 4.4 哈夫曼编码 编码的前缀性质可以使译码⽅法⾮常简单。 表示 最优前缀码 的⼆叉树总是⼀棵 完全⼆叉树 ，即树 中任⼀结点都有 2 个⼉⼦结点。 平均码⻓ 定义为： 使平均码⻓达到最⼩的前缀码编码⽅案称为给定编码 字符集 C 的 最优前缀码 。 0 4.4 哈夫曼编码 2 、构造哈夫曼编码 哈夫曼提出构造最优前缀码的贪⼼算法，由此产⽣的 编码⽅案称为 哈夫曼编码 。 哈夫曼算法以⾃底向上的⽅式构造表示最优前缀码的 ⼆叉树 T 。 算法以 | C| 个叶结点开始，执⾏ | C| － 1 次的 “ 合并 ” 运算 后产⽣最终所要求的树 T 。 0 4.4 哈夫曼编码 在书上给出的算法 huf fm a nT re e 中，编码字符集中每 ⼀字符 c 的频率是 f(c ) 。 以 f 为键值的优先队列 Q ⽤在 贪 ⼼选择 时有效地确定算法当前要合并的 2 棵具有最⼩频 率的树。⼀旦 2 棵具有最⼩频率的树合并后，产⽣⼀棵 新的树，其频率为合并的 2 棵树的频率之和，并将新树 插⼊优先队列 Q 。经过 n － 1 次的合并后，优先队列中只 剩下⼀棵树，即所要求的树 T 。 算法 huf fm a nT re e ⽤最⼩堆实现优先队列 Q 。初始化优 先队列需要 O (n) 计算时间，由于最⼩堆的 re m ove M i n 和 put 运算均需 O( l ogn ) 时间， n － 1 次的合并总共需要 O( nl ogn ) 计算时间。因此，关于 n 个字符的哈夫曼算法 的 计算时间 为 O( nl ogn ) 。 0 4.4 哈夫曼编码 3 、哈夫曼算法的正确性 要证明哈夫曼算法的正确性，只要证明最优前缀码问 题具有 贪⼼选择性质 和 最优⼦结构性质 。        (1)贪⼼选择性质        (2)最优⼦结构性质   0 4.5 单源最短路径 给定带权有向图 G =(V ,E ) ，其中每条边的权是⾮负实 数。另外，还给定 V 中的⼀个顶点，称为 源 。现在要计 算从源到所有其它各顶点的 最短路⻓度 。这⾥路的⻓ 度是指路上各边权之和。这个问题通常称为 单源最短 路径问题 。    1、算法基本思想 D i j ks t ra 算法是解单源最短路径问题的贪⼼算法。     0 4.5 单源最短路径 其 基本思想 是，设置顶点集合 S 并不断地作 贪⼼选择 来扩充这个集合。⼀个顶点属于集合 S 当且仅当从源到 该顶点的最短路径⻓度已知。 初始时， S 中仅含有源。设 u 是 G 的某⼀个顶点，把从 源到 u 且中间只经过 S 中顶点的路称为从源到 u 的特殊路 径，并⽤数组 di s t 记录当前每个顶点所对应的最短特殊 路径⻓度。 D i j ks t ra 算法每次从 V -S 中取出具有最短特殊 路⻓度的顶点 u ，将 u 添加到 S 中，同时对数组 di s t 作必 要的修改。⼀旦 S 包含了所有 V 中顶点， di s t 就记录了从 源到所有其它顶点之间的最短路径⻓度。 0 4.5 单源最短路径 例如 ，对右图中的有向 图，应⽤ D i j ks t ra 算法计 算从源顶点 1 到其它顶点 间最短路径的过程列在 下⻚的表中。 0 4.5 单源最短路径 603050105{1,2,4,3,5}4 603050103{1,2,4,3}3 903050104{1,2,4}2 1003060102{1,2}1 10030m a xi nt10-{1}初始 d i s t[5]d i s t[4]d i s t[3]d i s t[2]uS迭代 D i j ks t ra 算法的迭代过程： 0 4.5 单源最短路径 2 、算法的正确性和计算复杂性 (1)贪⼼选择性质 (2)最优⼦结构性质 (3)计算复杂性 对于具有 n 个顶点和 e 条边的带权有向图，如果⽤带权 邻接矩阵表示这个图，那么 D i j ks t ra 算法的主循环体需 要 时间。这个循环需要执⾏ n-1 次，所以完成循环需 要 时间。算法的其余部分所需要时间不超过 。 0 4.6 最⼩⽣成树 设 G =(V ,E ) 是⽆向连通带权图，即⼀个 ⽹络 。 E 中每 条边 (v ,w ) 的权为 c [v][w ] 。如果 G 的⼦图 G’ 是⼀棵包含 G 的所有顶点的树，则称 G’ 为 G 的⽣成树。⽣成树上各边 权的总和称为该⽣成树的 耗费 。在 G 的所有⽣成树中， 耗费最⼩的⽣成树称为 G 的 最⼩⽣成树 。 ⽹络的最⼩⽣成树在实际中有⼴泛应⽤。 例如 ，在设 计通信⽹络时，⽤图的顶点表示城市，⽤边 (v ,w ) 的 权 c [v][w ] 表示建⽴城市 v 和城市 w 之间的通信线路所需 的费⽤，则最⼩⽣成树就给出了建⽴通信⽹络的最经 济的⽅案。 0 4.6 最⼩⽣成树 1 、最⼩⽣成树性质 ⽤贪⼼算法设计策略可以设计出构造最⼩⽣成树的有 效算法。本节介绍的构造最⼩⽣成树的 Prim 算法 和 K r u s k al 算法 都可以看作是应⽤贪⼼算法设计策略的例 ⼦。尽管这 2 个算法做贪⼼选择的⽅式不同，它们都利 ⽤了下⾯的 最⼩⽣成树性质 ： 设 G =(V ,E ) 是连通带权图， U 是 V 的真⼦集。如果 (u,v) \u0000 E ，且 u \u0000 U ， v \u0000 V -U ，且在所有这样的边中， (u,v) 的权 c [u][v] 最⼩，那么⼀定存在 G 的⼀棵最⼩⽣成树， 它以 (u,v) 为其中⼀条边。这个性质有时也称为 MST 性 质 。 0 4.6 最⼩⽣成树 2 、 Prim算法 设 G =(V ,E ) 是连通带权图， V ={1,2,…,n} 。 构造 G 的最⼩⽣成树的 P ri m 算法的 基本思想 是：⾸先 置 S ={1} ，然后，只要 S 是 V 的真⼦集，就作如下的 贪 ⼼选择 ： 选取满⾜条件 i \u0000 S ， j \u0000 V -S ，且 c [i ][j ] 最⼩的 边，将顶点 j 添加到 S 中。这个过程⼀直进⾏到 S =V 时为 ⽌。 在这个过程中选取到的所有边恰好构成 G 的⼀棵 最⼩ ⽣成树 。 0 4.2 贪⼼算法的基本要素 对于 0-1 背包问题 ，贪⼼选择之所以不能得到最优解是因 为在这种情况下，它⽆法保证最终能将背包装满，部分闲 置的背包空间使每公⽄背包空间的价值降低了。事实上， 在考虑 0-1 背包问题时，应⽐较选择该物品和不选择该物 品所导致的最终⽅案，然后再作出最好选择。由此就导出 许多互相重叠的⼦问题。这正是该问题可⽤ 动态规划算法 求解的另⼀重要特征。 实际上也是如此，动态规划算法的确可以有效地解 0-1 背 包问题。 0 4.3 最优装载 有⼀批集装箱要装上⼀艘载重量为 c 的轮船。其中集 装箱 i 的重量为 Wi 。最优装载问题要求确定在装载体积 不受限制的情况下，将尽可能多的集装箱装上轮船。 1 、算法描述 最优装载问题可⽤贪⼼算法求解。采⽤重量最轻者先 装的贪⼼选择策略，可产⽣最优装载问题的最优解。 具体算法描述如下⻚。 0 4.3 最优装载 • publ i c s t a t i c fl oa t l oad i n g (fl oa t c , fl oa t [] w , i nt [] x) • { • i nt n=w .l e ngt h; • E l e m e nt [] d = ne w E l e m e nt [n]; • for ( i nt i = 0; i < n; i ++) • d[i ] = ne w E l e m e nt (w [i ],i ); • M e r ge S ort . m e r ge S ort (d); • fl oa t opt =0; • for ( i nt i = 0; i < n; i ++) x[i ] = 0; • for ( i nt i = 0; i < n & & d[i ].w <= c ; i ++) { • x[d[i ].i ] = 1; • opt +=d[i ].w ; • c -= d[i ].w ; • } • re t urn opt ; • } 其中 El e me n t 类说明为 参 ⻅本书 P 1 15 0 4.3 最优装载 2 、贪⼼选择性质 可以证明最优装载问题具有贪⼼选择性质 。 3 、最优⼦结构性质 最优装载问题具有最优⼦结构性质。 由最优装载问题的贪⼼选择性质和最优⼦结构性质， 容易证明算法 l oad i n g 的正确性。 算法 l oad i n g 的主要计算量在于将集装箱依其重量从 ⼩到⼤排序，故算法所需的计算时间为 O( n l ogn ) 。 0 4.4 哈夫曼编码 哈夫曼编码 是⼴泛地⽤于数据⽂件压缩的⼗分有效的 编码⽅法。其压缩率通常在 20% ～ 90% 之间。哈夫曼编 码算法⽤字符在⽂件中出现的频率表来建⽴⼀个 ⽤ 0 ， 1 串表示各字符的最优表示⽅式。 给出现频率⾼的字符较短的编码，出现频率较低的字 符以较⻓的编码，可以⼤⼤缩短总码⻓。 1 、前缀码 对每⼀个字符规定⼀个 0,1 串作为其代码，并要求任 ⼀字符的代码都不是其它字符代码的前缀。这种编码 称为 前缀码 。 0 4.4 哈夫曼编码 编码的前缀性质可以使译码⽅法⾮常简单。 表示 最优前缀码 的⼆叉树总是⼀棵 完全⼆叉树 ，即树 中任⼀结点都有 2 个⼉⼦结点。 平均码⻓ 定义为： 使平均码⻓达到最⼩的前缀码编码⽅案称为给定编码 字符集 C 的 最优前缀码 。 0 4.4 哈夫曼编码 2 、构造哈夫曼编码 哈夫曼提出构造最优前缀码的贪⼼算法，由此产⽣的 编码⽅案称为 哈夫曼编码 。 哈夫曼算法以⾃底向上的⽅式构造表示最优前缀码的 ⼆叉树 T 。 算法以 | C| 个叶结点开始，执⾏ | C| － 1 次的 “ 合并 ” 运算 后产⽣最终所要求的树 T 。 0 4.4 哈夫曼编码 在书上给出的算法 huf fm a nT re e 中，编码字符集中每 ⼀字符 c 的频率是 f(c ) 。 以 f 为键值的优先队列 Q ⽤在 贪 ⼼选择 时有效地确定算法当前要合并的 2 棵具有最⼩频 率的树。⼀旦 2 棵具有最⼩频率的树合并后，产⽣⼀棵 新的树，其频率为合并的 2 棵树的频率之和，并将新树 插⼊优先队列 Q 。经过 n － 1 次的合并后，优先队列中只 剩下⼀棵树，即所要求的树 T 。 算法 huf fm a nT re e ⽤最⼩堆实现优先队列 Q 。初始化优 先队列需要 O (n) 计算时间，由于最⼩堆的 re m ove M i n 和 put 运算均需 O( l ogn ) 时间， n － 1 次的合并总共需要 O( nl ogn ) 计算时间。因此，关于 n 个字符的哈夫曼算法 的 计算时间 为 O( nl ogn ) 。 0 4.4 哈夫曼编码 3 、哈夫曼算法的正确性 要证明哈夫曼算法的正确性，只要证明最优前缀码问 题具有 贪⼼选择性质 和 最优⼦结构性质 。        (1)贪⼼选择性质        (2)最优⼦结构性质   0 4.5 单源最短路径 给定带权有向图 G =(V ,E ) ，其中每条边的权是⾮负实 数。另外，还给定 V 中的⼀个顶点，称为 源 。现在要计 算从源到所有其它各顶点的 最短路⻓度 。这⾥路的⻓ 度是指路上各边权之和。这个问题通常称为 单源最短 路径问题 。    1、算法基本思想 D i j ks t ra 算法是解单源最短路径问题的贪⼼算法。     0 4.5 单源最短路径 其 基本思想 是，设置顶点集合 S 并不断地作 贪⼼选择 来扩充这个集合。⼀个顶点属于集合 S 当且仅当从源到 该顶点的最短路径⻓度已知。 初始时， S 中仅含有源。设 u 是 G 的某⼀个顶点，把从 源到 u 且中间只经过 S 中顶点的路称为从源到 u 的特殊路 径，并⽤数组 di s t 记录当前每个顶点所对应的最短特殊 路径⻓度。 D i j ks t ra 算法每次从 V -S 中取出具有最短特殊 路⻓度的顶点 u ，将 u 添加到 S 中，同时对数组 di s t 作必 要的修改。⼀旦 S 包含了所有 V 中顶点， di s t 就记录了从 源到所有其它顶点之间的最短路径⻓度。 0 4.5 单源最短路径 例如 ，对右图中的有向 图，应⽤ D i j ks t ra 算法计 算从源顶点 1 到其它顶点 间最短路径的过程列在 下⻚的表中。 0 4.5 单源最短路径 603050105{1,2,4,3,5}4 603050103{1,2,4,3}3 903050104{1,2,4}2 1003060102{1,2}1 10030m a xi nt10-{1}初始 d i s t[5]d i s t[4]d i s t[3]d i s t[2]uS迭代 D i j ks t ra 算法的迭代过程： 0 4.5 单源最短路径 2 、算法的正确性和计算复杂性 (1)贪⼼选择性质 (2)最优⼦结构性质 (3)计算复杂性 对于具有 n 个顶点和 e 条边的带权有向图，如果⽤带权 邻接矩阵表示这个图，那么 D i j ks t ra 算法的主循环体需 要 时间。这个循环需要执⾏ n-1 次，所以完成循环需 要 时间。算法的其余部分所需要时间不超过 。 0 4.6 最⼩⽣成树 设 G =(V ,E ) 是⽆向连通带权图，即⼀个 ⽹络 。 E 中每 条边 (v ,w ) 的权为 c [v][w ] 。如果 G 的⼦图 G’ 是⼀棵包含 G 的所有顶点的树，则称 G’ 为 G 的⽣成树。⽣成树上各边 权的总和称为该⽣成树的 耗费 。在 G 的所有⽣成树中， 耗费最⼩的⽣成树称为 G 的 最⼩⽣成树 。 ⽹络的最⼩⽣成树在实际中有⼴泛应⽤。 例如 ，在设 计通信⽹络时，⽤图的顶点表示城市，⽤边 (v ,w ) 的 权 c [v][w ] 表示建⽴城市 v 和城市 w 之间的通信线路所需 的费⽤，则最⼩⽣成树就给出了建⽴通信⽹络的最经 济的⽅案。 0 4.6 最⼩⽣成树 1 、最⼩⽣成树性质 ⽤贪⼼算法设计策略可以设计出构造最⼩⽣成树的有 效算法。本节介绍的构造最⼩⽣成树的 Prim 算法 和 K r u s k al 算法 都可以看作是应⽤贪⼼算法设计策略的例 ⼦。尽管这 2 个算法做贪⼼选择的⽅式不同，它们都利 ⽤了下⾯的 最⼩⽣成树性质 ： 设 G =(V ,E ) 是连通带权图， U 是 V 的真⼦集。如果 (u,v) \u0000 E ，且 u \u0000 U ， v \u0000 V -U ，且在所有这样的边中， (u,v) 的权 c [u][v] 最⼩，那么⼀定存在 G 的⼀棵最⼩⽣成树， 它以 (u,v) 为其中⼀条边。这个性质有时也称为 MST 性 质 。 0 4.6 最⼩⽣成树 2 、 Prim算法 设 G =(V ,E ) 是连通带权图， V ={1,2,…,n} 。 构造 G 的最⼩⽣成树的 P ri m 算法的 基本思想 是：⾸先 置 S ={1} ，然后，只要 S 是 V 的真⼦集，就作如下的 贪 ⼼选择 ： 选取满⾜条件 i \u0000 S ， j \u0000 V -S ，且 c [i ][j ] 最⼩的 边，将顶点 j 添加到 S 中。这个过程⼀直进⾏到 S =V 时为 ⽌。 在这个过程中选取到的所有边恰好构成 G 的⼀棵 最⼩ ⽣成树 。 0 4.2 贪⼼算法的基本要素 对于 0-1 背包问题 ，贪⼼选择之所以不能得到最优解是因 为在这种情况下，它⽆法保证最终能将背包装满，部分闲 置的背包空间使每公⽄背包空间的价值降低了。事实上， 在考虑 0-1 背包问题时，应⽐较选择该物品和不选择该物 品所导致的最终⽅案，然后再作出最好选择。由此就导出 许多互相重叠的⼦问题。这正是该问题可⽤ 动态规划算法 求解的另⼀重要特征。 实际上也是如此，动态规划算法的确可以有效地解 0-1 背 包问题。 0 4.3 最优装载 有⼀批集装箱要装上⼀艘载重量为 c 的轮船。其中集 装箱 i 的重量为 Wi 。最优装载问题要求确定在装载体积 不受限制的情况下，将尽可能多的集装箱装上轮船。 1 、算法描述 最优装载问题可⽤贪⼼算法求解。采⽤重量最轻者先 装的贪⼼选择策略，可产⽣最优装载问题的最优解。 具体算法描述如下⻚。 0 4.3 最优装载 • publ i c s t a t i c fl oa t l oad i n g (fl oa t c , fl oa t [] w , i nt [] x) • { • i nt n=w .l e ngt h; • E l e m e nt [] d = ne w E l e m e nt [n]; • for ( i nt i = 0; i < n; i ++) • d[i ] = ne w E l e m e nt (w [i ],i ); • M e r ge S ort . m e r ge S ort (d); • fl oa t opt =0; • for ( i nt i = 0; i < n; i ++) x[i ] = 0; • for ( i nt i = 0; i < n & & d[i ].w <= c ; i ++) { • x[d[i ].i ] = 1; • opt +=d[i ].w ; • c -= d[i ].w ; • } • re t urn opt ; • } 其中 El e me n t 类说明为 参 ⻅本书 P 1 15 0 4.3 最优装载 2 、贪⼼选择性质 可以证明最优装载问题具有贪⼼选择性质 。 3 、最优⼦结构性质 最优装载问题具有最优⼦结构性质。 由最优装载问题的贪⼼选择性质和最优⼦结构性质， 容易证明算法 l oad i n g 的正确性。 算法 l oad i n g 的主要计算量在于将集装箱依其重量从 ⼩到⼤排序，故算法所需的计算时间为 O( n l ogn ) 。 0 4.4 哈夫曼编码 哈夫曼编码 是⼴泛地⽤于数据⽂件压缩的⼗分有效的 编码⽅法。其压缩率通常在 20% ～ 90% 之间。哈夫曼编 码算法⽤字符在⽂件中出现的频率表来建⽴⼀个 ⽤ 0 ， 1 串表示各字符的最优表示⽅式。 给出现频率⾼的字符较短的编码，出现频率较低的字 符以较⻓的编码，可以⼤⼤缩短总码⻓。 1 、前缀码 对每⼀个字符规定⼀个 0,1 串作为其代码，并要求任 ⼀字符的代码都不是其它字符代码的前缀。这种编码 称为 前缀码 。 0 4.4 哈夫曼编码 编码的前缀性质可以使译码⽅法⾮常简单。 表示 最优前缀码 的⼆叉树总是⼀棵 完全⼆叉树 ，即树 中任⼀结点都有 2 个⼉⼦结点。 平均码⻓ 定义为： 使平均码⻓达到最⼩的前缀码编码⽅案称为给定编码 字符集 C 的 最优前缀码 。 0 4.4 哈夫曼编码 2 、构造哈夫曼编码 哈夫曼提出构造最优前缀码的贪⼼算法，由此产⽣的 编码⽅案称为 哈夫曼编码 。 哈夫曼算法以⾃底向上的⽅式构造表示最优前缀码的 ⼆叉树 T 。 算法以 | C| 个叶结点开始，执⾏ | C| － 1 次的 “ 合并 ” 运算 后产⽣最终所要求的树 T 。 0 4.4 哈夫曼编码 在书上给出的算法 huf fm a nT re e 中，编码字符集中每 ⼀字符 c 的频率是 f(c ) 。 以 f 为键值的优先队列 Q ⽤在 贪 ⼼选择 时有效地确定算法当前要合并的 2 棵具有最⼩频 率的树。⼀旦 2 棵具有最⼩频率的树合并后，产⽣⼀棵 新的树，其频率为合并的 2 棵树的频率之和，并将新树 插⼊优先队列 Q 。经过 n － 1 次的合并后，优先队列中只 剩下⼀棵树，即所要求的树 T 。 算法 huf fm a nT re e ⽤最⼩堆实现优先队列 Q 。初始化优 先队列需要 O (n) 计算时间，由于最⼩堆的 re m ove M i n 和 put 运算均需 O( l ogn ) 时间， n － 1 次的合并总共需要 O( nl ogn ) 计算时间。因此，关于 n 个字符的哈夫曼算法 的 计算时间 为 O( nl ogn ) 。 0 4.4 哈夫曼编码 3 、哈夫曼算法的正确性 要证明哈夫曼算法的正确性，只要证明最优前缀码问 题具有 贪⼼选择性质 和 最优⼦结构性质 。        (1)贪⼼选择性质        (2)最优⼦结构性质   0 4.5 单源最短路径 给定带权有向图 G =(V ,E ) ，其中每条边的权是⾮负实 数。另外，还给定 V 中的⼀个顶点，称为 源 。现在要计 算从源到所有其它各顶点的 最短路⻓度 。这⾥路的⻓ 度是指路上各边权之和。这个问题通常称为 单源最短 路径问题 。    1、算法基本思想 D i j ks t ra 算法是解单源最短路径问题的贪⼼算法。     0 4.5 单源最短路径 其 基本思想 是，设置顶点集合 S 并不断地作 贪⼼选择 来扩充这个集合。⼀个顶点属于集合 S 当且仅当从源到 该顶点的最短路径⻓度已知。 初始时， S 中仅含有源。设 u 是 G 的某⼀个顶点，把从 源到 u 且中间只经过 S 中顶点的路称为从源到 u 的特殊路 径，并⽤数组 di s t 记录当前每个顶点所对应的最短特殊 路径⻓度。 D i j ks t ra 算法每次从 V -S 中取出具有最短特殊 路⻓度的顶点 u ，将 u 添加到 S 中，同时对数组 di s t 作必 要的修改。⼀旦 S 包含了所有 V 中顶点， di s t 就记录了从 源到所有其它顶点之间的最短路径⻓度。 0 4.5 单源最短路径 例如 ，对右图中的有向 图，应⽤ D i j ks t ra 算法计 算从源顶点 1 到其它顶点 间最短路径的过程列在 下⻚的表中。 0 4.5 单源最短路径 603050105{1,2,4,3,5}4 603050103{1,2,4,3}3 903050104{1,2,4}2 1003060102{1,2}1 10030m a xi nt10-{1}初始 d i s t[5]d i s t[4]d i s t[3]d i s t[2]uS迭代 D i j ks t ra 算法的迭代过程： 0 4.5 单源最短路径 2 、算法的正确性和计算复杂性 (1)贪⼼选择性质 (2)最优⼦结构性质 (3)计算复杂性 对于具有 n 个顶点和 e 条边的带权有向图，如果⽤带权 邻接矩阵表示这个图，那么 D i j ks t ra 算法的主循环体需 要 时间。这个循环需要执⾏ n-1 次，所以完成循环需 要 时间。算法的其余部分所需要时间不超过 。 0 4.6 最⼩⽣成树 设 G =(V ,E ) 是⽆向连通带权图，即⼀个 ⽹络 。 E 中每 条边 (v ,w ) 的权为 c [v][w ] 。如果 G 的⼦图 G’ 是⼀棵包含 G 的所有顶点的树，则称 G’ 为 G 的⽣成树。⽣成树上各边 权的总和称为该⽣成树的 耗费 。在 G 的所有⽣成树中， 耗费最⼩的⽣成树称为 G 的 最⼩⽣成树 。 ⽹络的最⼩⽣成树在实际中有⼴泛应⽤。 例如 ，在设 计通信⽹络时，⽤图的顶点表示城市，⽤边 (v ,w ) 的 权 c [v][w ] 表示建⽴城市 v 和城市 w 之间的通信线路所需 的费⽤，则最⼩⽣成树就给出了建⽴通信⽹络的最经 济的⽅案。 0 4.6 最⼩⽣成树 1 、最⼩⽣成树性质 ⽤贪⼼算法设计策略可以设计出构造最⼩⽣成树的有 效算法。本节介绍的构造最⼩⽣成树的 Prim 算法 和 K r u s k al 算法 都可以看作是应⽤贪⼼算法设计策略的例 ⼦。尽管这 2 个算法做贪⼼选择的⽅式不同，它们都利 ⽤了下⾯的 最⼩⽣成树性质 ： 设 G =(V ,E ) 是连通带权图， U 是 V 的真⼦集。如果 (u,v) \u0000 E ，且 u \u0000 U ， v \u0000 V -U ，且在所有这样的边中， (u,v) 的权 c [u][v] 最⼩，那么⼀定存在 G 的⼀棵最⼩⽣成树， 它以 (u,v) 为其中⼀条边。这个性质有时也称为 MST 性 质 。 0 4.6 最⼩⽣成树 2 、 Prim算法 设 G =(V ,E ) 是连通带权图， V ={1,2,…,n} 。 构造 G 的最⼩⽣成树的 P ri m 算法的 基本思想 是：⾸先 置 S ={1} ，然后，只要 S 是 V 的真⼦集，就作如下的 贪 ⼼选择 ： 选取满⾜条件 i \u0000 S ， j \u0000 V -S ，且 c [i ][j ] 最⼩的 边，将顶点 j 添加到 S 中。这个过程⼀直进⾏到 S =V 时为 ⽌。 在这个过程中选取到的所有边恰好构成 G 的⼀棵 最⼩ ⽣成树 。 0 4.2 贪⼼算法的基本要素 对于 0-1 背包问题 ，贪⼼选择之所以不能得到最优解是因 为在这种情况下，它⽆法保证最终能将背包装满，部分闲 置的背包空间使每公⽄背包空间的价值降低了。事实上， 在考虑 0-1 背包问题时，应⽐较选择该物品和不选择该物 品所导致的最终⽅案，然后再作出最好选择。由此就导出 许多互相重叠的⼦问题。这正是该问题可⽤ 动态规划算法 求解的另⼀重要特征。 实际上也是如此，动态规划算法的确可以有效地解 0-1 背 包问题。 0 4.3 最优装载 有⼀批集装箱要装上⼀艘载重量为 c 的轮船。其中集 装箱 i 的重量为 Wi 。最优装载问题要求确定在装载体积 不受限制的情况下，将尽可能多的集装箱装上轮船。 1 、算法描述 最优装载问题可⽤贪⼼算法求解。采⽤重量最轻者先 装的贪⼼选择策略，可产⽣最优装载问题的最优解。 具体算法描述如下⻚。 0 4.3 最优装载 • publ i c s t a t i c fl oa t l oad i n g (fl oa t c , fl oa t [] w , i nt [] x) • { • i nt n=w .l e ngt h; • E l e m e nt [] d = ne w E l e m e nt [n]; • for ( i nt i = 0; i < n; i ++) • d[i ] = ne w E l e m e nt (w [i ],i ); • M e r ge S ort . m e r ge S ort (d); • fl oa t opt =0; • for ( i nt i = 0; i < n; i ++) x[i ] = 0; • for ( i nt i = 0; i < n & & d[i ].w <= c ; i ++) { • x[d[i ].i ] = 1; • opt +=d[i ].w ; • c -= d[i ].w ; • } • re t urn opt ; • } 其中 El e me n t 类说明为 参 ⻅本书 P 1 15 0 4.3 最优装载 2 、贪⼼选择性质 可以证明最优装载问题具有贪⼼选择性质 。 3 、最优⼦结构性质 最优装载问题具有最优⼦结构性质。 由最优装载问题的贪⼼选择性质和最优⼦结构性质， 容易证明算法 l oad i n g 的正确性。 算法 l oad i n g 的主要计算量在于将集装箱依其重量从 ⼩到⼤排序，故算法所需的计算时间为 O( n l ogn ) 。 0 4.4 哈夫曼编码 哈夫曼编码 是⼴泛地⽤于数据⽂件压缩的⼗分有效的 编码⽅法。其压缩率通常在 20% ～ 90% 之间。哈夫曼编 码算法⽤字符在⽂件中出现的频率表来建⽴⼀个 ⽤ 0 ， 1 串表示各字符的最优表示⽅式。 给出现频率⾼的字符较短的编码，出现频率较低的字 符以较⻓的编码，可以⼤⼤缩短总码⻓。 1 、前缀码 对每⼀个字符规定⼀个 0,1 串作为其代码，并要求任 ⼀字符的代码都不是其它字符代码的前缀。这种编码 称为 前缀码 。 0 4.4 哈夫曼编码 编码的前缀性质可以使译码⽅法⾮常简单。 表示 最优前缀码 的⼆叉树总是⼀棵 完全⼆叉树 ，即树 中任⼀结点都有 2 个⼉⼦结点。 平均码⻓ 定义为： 使平均码⻓达到最⼩的前缀码编码⽅案称为给定编码 字符集 C 的 最优前缀码 。 0 4.4 哈夫曼编码 2 、构造哈夫曼编码 哈夫曼提出构造最优前缀码的贪⼼算法，由此产⽣的 编码⽅案称为 哈夫曼编码 。 哈夫曼算法以⾃底向上的⽅式构造表示最优前缀码的 ⼆叉树 T 。 算法以 | C| 个叶结点开始，执⾏ | C| － 1 次的 “ 合并 ” 运算 后产⽣最终所要求的树 T 。 0 4.4 哈夫曼编码 在书上给出的算法 huf fm a nT re e 中，编码字符集中每 ⼀字符 c 的频率是 f(c ) 。 以 f 为键值的优先队列 Q ⽤在 贪 ⼼选择 时有效地确定算法当前要合并的 2 棵具有最⼩频 率的树。⼀旦 2 棵具有最⼩频率的树合并后，产⽣⼀棵 新的树，其频率为合并的 2 棵树的频率之和，并将新树 插⼊优先队列 Q 。经过 n － 1 次的合并后，优先队列中只 剩下⼀棵树，即所要求的树 T 。 算法 huf fm a nT re e ⽤最⼩堆实现优先队列 Q 。初始化优 先队列需要 O (n) 计算时间，由于最⼩堆的 re m ove M i n 和 put 运算均需 O( l ogn ) 时间， n － 1 次的合并总共需要 O( nl ogn ) 计算时间。因此，关于 n 个字符的哈夫曼算法 的 计算时间 为 O( nl ogn ) 。 0 4.4 哈夫曼编码 3 、哈夫曼算法的正确性 要证明哈夫曼算法的正确性，只要证明最优前缀码问 题具有 贪⼼选择性质 和 最优⼦结构性质 。        (1)贪⼼选择性质        (2)最优⼦结构性质   0 4.5 单源最短路径 给定带权有向图 G =(V ,E ) ，其中每条边的权是⾮负实 数。另外，还给定 V 中的⼀个顶点，称为 源 。现在要计 算从源到所有其它各顶点的 最短路⻓度 。这⾥路的⻓ 度是指路上各边权之和。这个问题通常称为 单源最短 路径问题 。    1、算法基本思想 D i j ks t ra 算法是解单源最短路径问题的贪⼼算法。     0 4.5 单源最短路径 其 基本思想 是，设置顶点集合 S 并不断地作 贪⼼选择 来扩充这个集合。⼀个顶点属于集合 S 当且仅当从源到 该顶点的最短路径⻓度已知。 初始时， S 中仅含有源。设 u 是 G 的某⼀个顶点，把从 源到 u 且中间只经过 S 中顶点的路称为从源到 u 的特殊路 径，并⽤数组 di s t 记录当前每个顶点所对应的最短特殊 路径⻓度。 D i j ks t ra 算法每次从 V -S 中取出具有最短特殊 路⻓度的顶点 u ，将 u 添加到 S 中，同时对数组 di s t 作必 要的修改。⼀旦 S 包含了所有 V 中顶点， di s t 就记录了从 源到所有其它顶点之间的最短路径⻓度。 0 4.5 单源最短路径 例如 ，对右图中的有向 图，应⽤ D i j ks t ra 算法计 算从源顶点 1 到其它顶点 间最短路径的过程列在 下⻚的表中。 0 4.5 单源最短路径 603050105{1,2,4,3,5}4 603050103{1,2,4,3}3 903050104{1,2,4}2 1003060102{1,2}1 10030m a xi nt10-{1}初始 d i s t[5]d i s t[4]d i s t[3]d i s t[2]uS迭代 D i j ks t ra 算法的迭代过程： 0 4.5 单源最短路径 2 、算法的正确性和计算复杂性 (1)贪⼼选择性质 (2)最优⼦结构性质 (3)计算复杂性 对于具有 n 个顶点和 e 条边的带权有向图，如果⽤带权 邻接矩阵表示这个图，那么 D i j ks t ra 算法的主循环体需 要 时间。这个循环需要执⾏ n-1 次，所以完成循环需 要 时间。算法的其余部分所需要时间不超过 。 0 4.6 最⼩⽣成树 设 G =(V ,E ) 是⽆向连通带权图，即⼀个 ⽹络 。 E 中每 条边 (v ,w ) 的权为 c [v][w ] 。如果 G 的⼦图 G’ 是⼀棵包含 G 的所有顶点的树，则称 G’ 为 G 的⽣成树。⽣成树上各边 权的总和称为该⽣成树的 耗费 。在 G 的所有⽣成树中， 耗费最⼩的⽣成树称为 G 的 最⼩⽣成树 。 ⽹络的最⼩⽣成树在实际中有⼴泛应⽤。 例如 ，在设 计通信⽹络时，⽤图的顶点表示城市，⽤边 (v ,w ) 的 权 c [v][w ] 表示建⽴城市 v 和城市 w 之间的通信线路所需 的费⽤，则最⼩⽣成树就给出了建⽴通信⽹络的最经 济的⽅案。 0 4.6 最⼩⽣成树 1 、最⼩⽣成树性质 ⽤贪⼼算法设计策略可以设计出构造最⼩⽣成树的有 效算法。本节介绍的构造最⼩⽣成树的 Prim 算法 和 K r u s k al 算法 都可以看作是应⽤贪⼼算法设计策略的例 ⼦。尽管这 2 个算法做贪⼼选择的⽅式不同，它们都利 ⽤了下⾯的 最⼩⽣成树性质 ： 设 G =(V ,E ) 是连通带权图， U 是 V 的真⼦集。如果 (u,v) \u0000 E ，且 u \u0000 U ， v \u0000 V -U ，且在所有这样的边中， (u,v) 的权 c [u][v] 最⼩，那么⼀定存在 G 的⼀棵最⼩⽣成树， 它以 (u,v) 为其中⼀条边。这个性质有时也称为 MST 性 质 。 0 4.6 最⼩⽣成树 2 、 Prim算法 设 G =(V ,E ) 是连通带权图， V ={1,2,…,n} 。 构造 G 的最⼩⽣成树的 P ri m 算法的 基本思想 是：⾸先 置 S ={1} ，然后，只要 S 是 V 的真⼦集，就作如下的 贪 ⼼选择 ： 选取满⾜条件 i \u0000 S ， j \u0000 V -S ，且 c [i ][j ] 最⼩的 边，将顶点 j 添加到 S 中。这个过程⼀直进⾏到 S =V 时为 ⽌。 在这个过程中选取到的所有边恰好构成 G 的⼀棵 最⼩ ⽣成树 。 0 4.2 贪⼼算法的基本要素 对于 0-1 背包问题 ，贪⼼选择之所以不能得到最优解是因 为在这种情况下，它⽆法保证最终能将背包装满，部分闲 置的背包空间使每公⽄背包空间的价值降低了。事实上， 在考虑 0-1 背包问题时，应⽐较选择该物品和不选择该物 品所导致的最终⽅案，然后再作出最好选择。由此就导出 许多互相重叠的⼦问题。这正是该问题可⽤ 动态规划算法 求解的另⼀重要特征。 实际上也是如此，动态规划算法的确可以有效地解 0-1 背 包问题。 0 4.3 最优装载 有⼀批集装箱要装上⼀艘载重量为 c 的轮船。其中集 装箱 i 的重量为 Wi 。最优装载问题要求确定在装载体积 不受限制的情况下，将尽可能多的集装箱装上轮船。 1 、算法描述 最优装载问题可⽤贪⼼算法求解。采⽤重量最轻者先 装的贪⼼选择策略，可产⽣最优装载问题的最优解。 具体算法描述如下⻚。 0 4.3 最优装载 • publ i c s t a t i c fl oa t l oad i n g (fl oa t c , fl oa t [] w , i nt [] x) • { • i nt n=w .l e ngt h; • E l e m e nt [] d = ne w E l e m e nt [n]; • for ( i nt i = 0; i < n; i ++) • d[i ] = ne w E l e m e nt (w [i ],i ); • M e r ge S ort . m e r ge S ort (d); • fl oa t opt =0; • for ( i nt i = 0; i < n; i ++) x[i ] = 0; • for ( i nt i = 0; i < n & & d[i ].w <= c ; i ++) { • x[d[i ].i ] = 1; • opt +=d[i ].w ; • c -= d[i ].w ; • } • re t urn opt ; • } 其中 El e me n t 类说明为 参 ⻅本书 P 1 15 0 4.3 最优装载 2 、贪⼼选择性质 可以证明最优装载问题具有贪⼼选择性质 。 3 、最优⼦结构性质 最优装载问题具有最优⼦结构性质。 由最优装载问题的贪⼼选择性质和最优⼦结构性质， 容易证明算法 l oad i n g 的正确性。 算法 l oad i n g 的主要计算量在于将集装箱依其重量从 ⼩到⼤排序，故算法所需的计算时间为 O( n l ogn ) 。 0 4.4 哈夫曼编码 哈夫曼编码 是⼴泛地⽤于数据⽂件压缩的⼗分有效的 编码⽅法。其压缩率通常在 20% ～ 90% 之间。哈夫曼编 码算法⽤字符在⽂件中出现的频率表来建⽴⼀个 ⽤ 0 ， 1 串表示各字符的最优表示⽅式。 给出现频率⾼的字符较短的编码，出现频率较低的字 符以较⻓的编码，可以⼤⼤缩短总码⻓。 1 、前缀码 对每⼀个字符规定⼀个 0,1 串作为其代码，并要求任 ⼀字符的代码都不是其它字符代码的前缀。这种编码 称为 前缀码 。 0 4.4 哈夫曼编码 编码的前缀性质可以使译码⽅法⾮常简单。 表示 最优前缀码 的⼆叉树总是⼀棵 完全⼆叉树 ，即树 中任⼀结点都有 2 个⼉⼦结点。 平均码⻓ 定义为： 使平均码⻓达到最⼩的前缀码编码⽅案称为给定编码 字符集 C 的 最优前缀码 。 0 4.4 哈夫曼编码 2 、构造哈夫曼编码 哈夫曼提出构造最优前缀码的贪⼼算法，由此产⽣的 编码⽅案称为 哈夫曼编码 。 哈夫曼算法以⾃底向上的⽅式构造表示最优前缀码的 ⼆叉树 T 。 算法以 | C| 个叶结点开始，执⾏ | C| － 1 次的 “ 合并 ” 运算 后产⽣最终所要求的树 T 。 0 4.4 哈夫曼编码 在书上给出的算法 huf fm a nT re e 中，编码字符集中每 ⼀字符 c 的频率是 f(c ) 。 以 f 为键值的优先队列 Q ⽤在 贪 ⼼选择 时有效地确定算法当前要合并的 2 棵具有最⼩频 率的树。⼀旦 2 棵具有最⼩频率的树合并后，产⽣⼀棵 新的树，其频率为合并的 2 棵树的频率之和，并将新树 插⼊优先队列 Q 。经过 n － 1 次的合并后，优先队列中只 剩下⼀棵树，即所要求的树 T 。 算法 huf fm a nT re e ⽤最⼩堆实现优先队列 Q 。初始化优 先队列需要 O (n) 计算时间，由于最⼩堆的 re m ove M i n 和 put 运算均需 O( l ogn ) 时间， n － 1 次的合并总共需要 O( nl ogn ) 计算时间。因此，关于 n 个字符的哈夫曼算法 的 计算时间 为 O( nl ogn ) 。 0 4.4 哈夫曼编码 3 、哈夫曼算法的正确性 要证明哈夫曼算法的正确性，只要证明最优前缀码问 题具有 贪⼼选择性质 和 最优⼦结构性质 。        (1)贪⼼选择性质        (2)最优⼦结构性质   0 4.5 单源最短路径 给定带权有向图 G =(V ,E ) ，其中每条边的权是⾮负实 数。另外，还给定 V 中的⼀个顶点，称为 源 。现在要计 算从源到所有其它各顶点的 最短路⻓度 。这⾥路的⻓ 度是指路上各边权之和。这个问题通常称为 单源最短 路径问题 。    1、算法基本思想 D i j ks t ra 算法是解单源最短路径问题的贪⼼算法。     0 4.5 单源最短路径 其 基本思想 是，设置顶点集合 S 并不断地作 贪⼼选择 来扩充这个集合。⼀个顶点属于集合 S 当且仅当从源到 该顶点的最短路径⻓度已知。 初始时， S 中仅含有源。设 u 是 G 的某⼀个顶点，把从 源到 u 且中间只经过 S 中顶点的路称为从源到 u 的特殊路 径，并⽤数组 di s t 记录当前每个顶点所对应的最短特殊 路径⻓度。 D i j ks t ra 算法每次从 V -S 中取出具有最短特殊 路⻓度的顶点 u ，将 u 添加到 S 中，同时对数组 di s t 作必 要的修改。⼀旦 S 包含了所有 V 中顶点， di s t 就记录了从 源到所有其它顶点之间的最短路径⻓度。 0 4.5 单源最短路径 例如 ，对右图中的有向 图，应⽤ D i j ks t ra 算法计 算从源顶点 1 到其它顶点 间最短路径的过程列在 下⻚的表中。 0 4.5 单源最短路径 603050105{1,2,4,3,5}4 603050103{1,2,4,3}3 903050104{1,2,4}2 1003060102{1,2}1 10030m a xi nt10-{1}初始 d i s t[5]d i s t[4]d i s t[3]d i s t[2]uS迭代 D i j ks t ra 算法的迭代过程： 0 4.5 单源最短路径 2 、算法的正确性和计算复杂性 (1)贪⼼选择性质 (2)最优⼦结构性质 (3)计算复杂性 对于具有 n 个顶点和 e 条边的带权有向图，如果⽤带权 邻接矩阵表示这个图，那么 D i j ks t ra 算法的主循环体需 要 时间。这个循环需要执⾏ n-1 次，所以完成循环需 要 时间。算法的其余部分所需要时间不超过 。 0 4.6 最⼩⽣成树 设 G =(V ,E ) 是⽆向连通带权图，即⼀个 ⽹络 。 E 中每 条边 (v ,w ) 的权为 c [v][w ] 。如果 G 的⼦图 G’ 是⼀棵包含 G 的所有顶点的树，则称 G’ 为 G 的⽣成树。⽣成树上各边 权的总和称为该⽣成树的 耗费 。在 G 的所有⽣成树中， 耗费最⼩的⽣成树称为 G 的 最⼩⽣成树 。 ⽹络的最⼩⽣成树在实际中有⼴泛应⽤。 例如 ，在设 计通信⽹络时，⽤图的顶点表示城市，⽤边 (v ,w ) 的 权 c [v][w ] 表示建⽴城市 v 和城市 w 之间的通信线路所需 的费⽤，则最⼩⽣成树就给出了建⽴通信⽹络的最经 济的⽅案。 0 4.6 最⼩⽣成树 1 、最⼩⽣成树性质 ⽤贪⼼算法设计策略可以设计出构造最⼩⽣成树的有 效算法。本节介绍的构造最⼩⽣成树的 Prim 算法 和 K r u s k al 算法 都可以看作是应⽤贪⼼算法设计策略的例 ⼦。尽管这 2 个算法做贪⼼选择的⽅式不同，它们都利 ⽤了下⾯的 最⼩⽣成树性质 ： 设 G =(V ,E ) 是连通带权图， U 是 V 的真⼦集。如果 (u,v) \u0000 E ，且 u \u0000 U ， v \u0000 V -U ，且在所有这样的边中， (u,v) 的权 c [u][v] 最⼩，那么⼀定存在 G 的⼀棵最⼩⽣成树， 它以 (u,v) 为其中⼀条边。这个性质有时也称为 MST 性 质 。 0 4.6 最⼩⽣成树 2 、 Prim算法 设 G =(V ,E ) 是连通带权图， V ={1,2,…,n} 。 构造 G 的最⼩⽣成树的 P ri m 算法的 基本思想 是：⾸先 置 S ={1} ，然后，只要 S 是 V 的真⼦集，就作如下的 贪 ⼼选择 ： 选取满⾜条件 i \u0000 S ， j \u0000 V -S ，且 c [i ][j ] 最⼩的 边，将顶点 j 添加到 S 中。这个过程⼀直进⾏到 S =V 时为 ⽌。 在这个过程中选取到的所有边恰好构成 G 的⼀棵 最⼩ ⽣成树 。 0 4.2 贪⼼算法的基本要素 对于 0-1 背包问题 ，贪⼼选择之所以不能得到最优解是因 为在这种情况下，它⽆法保证最终能将背包装满，部分闲 置的背包空间使每公⽄背包空间的价值降低了。事实上， 在考虑 0-1 背包问题时，应⽐较选择该物品和不选择该物 品所导致的最终⽅案，然后再作出最好选择。由此就导出 许多互相重叠的⼦问题。这正是该问题可⽤ 动态规划算法 求解的另⼀重要特征。 实际上也是如此，动态规划算法的确可以有效地解 0-1 背 包问题。 0 4.3 最优装载 有⼀批集装箱要装上⼀艘载重量为 c 的轮船。其中集 装箱 i 的重量为 Wi 。最优装载问题要求确定在装载体积 不受限制的情况下，将尽可能多的集装箱装上轮船。 1 、算法描述 最优装载问题可⽤贪⼼算法求解。采⽤重量最轻者先 装的贪⼼选择策略，可产⽣最优装载问题的最优解。 具体算法描述如下⻚。 0 4.3 最优装载 • publ i c s t a t i c fl oa t l oad i n g (fl oa t c , fl oa t [] w , i nt [] x) • { • i nt n=w .l e ngt h; • E l e m e nt [] d = ne w E l e m e nt [n]; • for ( i nt i = 0; i < n; i ++) • d[i ] = ne w E l e m e nt (w [i ],i ); • M e r ge S ort . m e r ge S ort (d); • fl oa t opt =0; • for ( i nt i = 0; i < n; i ++) x[i ] = 0; • for ( i nt i = 0; i < n & & d[i ].w <= c ; i ++) { • x[d[i ].i ] = 1; • opt +=d[i ].w ; • c -= d[i ].w ; • } • re t urn opt ; • } 其中 El e me n t 类说明为 参 ⻅本书 P 1 15 0 4.3 最优装载 2 、贪⼼选择性质 可以证明最优装载问题具有贪⼼选择性质 。 3 、最优⼦结构性质 最优装载问题具有最优⼦结构性质。 由最优装载问题的贪⼼选择性质和最优⼦结构性质， 容易证明算法 l oad i n g 的正确性。 算法 l oad i n g 的主要计算量在于将集装箱依其重量从 ⼩到⼤排序，故算法所需的计算时间为 O( n l ogn ) 。 0 4.4 哈夫曼编码 哈夫曼编码 是⼴泛地⽤于数据⽂件压缩的⼗分有效的 编码⽅法。其压缩率通常在 20% ～ 90% 之间。哈夫曼编 码算法⽤字符在⽂件中出现的频率表来建⽴⼀个 ⽤ 0 ， 1 串表示各字符的最优表示⽅式。 给出现频率⾼的字符较短的编码，出现频率较低的字 符以较⻓的编码，可以⼤⼤缩短总码⻓。 1 、前缀码 对每⼀个字符规定⼀个 0,1 串作为其代码，并要求任 ⼀字符的代码都不是其它字符代码的前缀。这种编码 称为 前缀码 。 0 4.4 哈夫曼编码 编码的前缀性质可以使译码⽅法⾮常简单。 表示 最优前缀码 的⼆叉树总是⼀棵 完全⼆叉树 ，即树 中任⼀结点都有 2 个⼉⼦结点。 平均码⻓ 定义为： 使平均码⻓达到最⼩的前缀码编码⽅案称为给定编码 字符集 C 的 最优前缀码 。 0 4.4 哈夫曼编码 2 、构造哈夫曼编码 哈夫曼提出构造最优前缀码的贪⼼算法，由此产⽣的 编码⽅案称为 哈夫曼编码 。 哈夫曼算法以⾃底向上的⽅式构造表示最优前缀码的 ⼆叉树 T 。 算法以 | C| 个叶结点开始，执⾏ | C| － 1 次的 “ 合并 ” 运算 后产⽣最终所要求的树 T 。 0 4.4 哈夫曼编码 在书上给出的算法 huf fm a nT re e 中，编码字符集中每 ⼀字符 c 的频率是 f(c ) 。 以 f 为键值的优先队列 Q ⽤在 贪 ⼼选择 时有效地确定算法当前要合并的 2 棵具有最⼩频 率的树。⼀旦 2 棵具有最⼩频率的树合并后，产⽣⼀棵 新的树，其频率为合并的 2 棵树的频率之和，并将新树 插⼊优先队列 Q 。经过 n － 1 次的合并后，优先队列中只 剩下⼀棵树，即所要求的树 T 。 算法 huf fm a nT re e ⽤最⼩堆实现优先队列 Q 。初始化优 先队列需要 O (n) 计算时间，由于最⼩堆的 re m ove M i n 和 put 运算均需 O( l ogn ) 时间， n － 1 次的合并总共需要 O( nl ogn ) 计算时间。因此，关于 n 个字符的哈夫曼算法 的 计算时间 为 O( nl ogn ) 。 0 4.4 哈夫曼编码 3 、哈夫曼算法的正确性 要证明哈夫曼算法的正确性，只要证明最优前缀码问 题具有 贪⼼选择性质 和 最优⼦结构性质 。        (1)贪⼼选择性质        (2)最优⼦结构性质   0 4.5 单源最短路径 给定带权有向图 G =(V ,E ) ，其中每条边的权是⾮负实 数。另外，还给定 V 中的⼀个顶点，称为 源 。现在要计 算从源到所有其它各顶点的 最短路⻓度 。这⾥路的⻓ 度是指路上各边权之和。这个问题通常称为 单源最短 路径问题 。    1、算法基本思想 D i j ks t ra 算法是解单源最短路径问题的贪⼼算法。     0 4.5 单源最短路径 其 基本思想 是，设置顶点集合 S 并不断地作 贪⼼选择 来扩充这个集合。⼀个顶点属于集合 S 当且仅当从源到 该顶点的最短路径⻓度已知。 初始时， S 中仅含有源。设 u 是 G 的某⼀个顶点，把从 源到 u 且中间只经过 S 中顶点的路称为从源到 u 的特殊路 径，并⽤数组 di s t 记录当前每个顶点所对应的最短特殊 路径⻓度。 D i j ks t ra 算法每次从 V -S 中取出具有最短特殊 路⻓度的顶点 u ，将 u 添加到 S 中，同时对数组 di s t 作必 要的修改。⼀旦 S 包含了所有 V 中顶点， di s t 就记录了从 源到所有其它顶点之间的最短路径⻓度。 0 4.5 单源最短路径 例如 ，对右图中的有向 图，应⽤ D i j ks t ra 算法计 算从源顶点 1 到其它顶点 间最短路径的过程列在 下⻚的表中。 0 4.5 单源最短路径 603050105{1,2,4,3,5}4 603050103{1,2,4,3}3 903050104{1,2,4}2 1003060102{1,2}1 10030m a xi nt10-{1}初始 d i s t[5]d i s t[4]d i s t[3]d i s t[2]uS迭代 D i j ks t ra 算法的迭代过程： 0 4.5 单源最短路径 2 、算法的正确性和计算复杂性 (1)贪⼼选择性质 (2)最优⼦结构性质 (3)计算复杂性 对于具有 n 个顶点和 e 条边的带权有向图，如果⽤带权 邻接矩阵表示这个图，那么 D i j ks t ra 算法的主循环体需 要 时间。这个循环需要执⾏ n-1 次，所以完成循环需 要 时间。算法的其余部分所需要时间不超过 。 0 4.6 最⼩⽣成树 设 G =(V ,E ) 是⽆向连通带权图，即⼀个 ⽹络 。 E 中每 条边 (v ,w ) 的权为 c [v][w ] 。如果 G 的⼦图 G’ 是⼀棵包含 G 的所有顶点的树，则称 G’ 为 G 的⽣成树。⽣成树上各边 权的总和称为该⽣成树的 耗费 。在 G 的所有⽣成树中， 耗费最⼩的⽣成树称为 G 的 最⼩⽣成树 。 ⽹络的最⼩⽣成树在实际中有⼴泛应⽤。 例如 ，在设 计通信⽹络时，⽤图的顶点表示城市，⽤边 (v ,w ) 的 权 c [v][w ] 表示建⽴城市 v 和城市 w 之间的通信线路所需 的费⽤，则最⼩⽣成树就给出了建⽴通信⽹络的最经 济的⽅案。 0 4.6 最⼩⽣成树 1 、最⼩⽣成树性质 ⽤贪⼼算法设计策略可以设计出构造最⼩⽣成树的有 效算法。本节介绍的构造最⼩⽣成树的 Prim 算法 和 K r u s k al 算法 都可以看作是应⽤贪⼼算法设计策略的例 ⼦。尽管这 2 个算法做贪⼼选择的⽅式不同，它们都利 ⽤了下⾯的 最⼩⽣成树性质 ： 设 G =(V ,E ) 是连通带权图， U 是 V 的真⼦集。如果 (u,v) \u0000 E ，且 u \u0000 U ， v \u0000 V -U ，且在所有这样的边中， (u,v) 的权 c [u][v] 最⼩，那么⼀定存在 G 的⼀棵最⼩⽣成树， 它以 (u,v) 为其中⼀条边。这个性质有时也称为 MST 性 质 。 0 4.6 最⼩⽣成树 2 、 Prim算法 设 G =(V ,E ) 是连通带权图， V ={1,2,…,n} 。 构造 G 的最⼩⽣成树的 P ri m 算法的 基本思想 是：⾸先 置 S ={1} ，然后，只要 S 是 V 的真⼦集，就作如下的 贪 ⼼选择 ： 选取满⾜条件 i \u0000 S ， j \u0000 V -S ，且 c [i ][j ] 最⼩的 边，将顶点 j 添加到 S 中。这个过程⼀直进⾏到 S =V 时为 ⽌。 在这个过程中选取到的所有边恰好构成 G 的⼀棵 最⼩ ⽣成树 。 0 4.2 贪⼼算法的基本要素 对于 0-1 背包问题 ，贪⼼选择之所以不能得到最优解是因 为在这种情况下，它⽆法保证最终能将背包装满，部分闲 置的背包空间使每公⽄背包空间的价值降低了。事实上， 在考虑 0-1 背包问题时，应⽐较选择该物品和不选择该物 品所导致的最终⽅案，然后再作出最好选择。由此就导出 许多互相重叠的⼦问题。这正是该问题可⽤ 动态规划算法 求解的另⼀重要特征。 实际上也是如此，动态规划算法的确可以有效地解 0-1 背 包问题。 0 4.3 最优装载 有⼀批集装箱要装上⼀艘载重量为 c 的轮船。其中集 装箱 i 的重量为 Wi 。最优装载问题要求确定在装载体积 不受限制的情况下，将尽可能多的集装箱装上轮船。 1 、算法描述 最优装载问题可⽤贪⼼算法求解。采⽤重量最轻者先 装的贪⼼选择策略，可产⽣最优装载问题的最优解。 具体算法描述如下⻚。 0 4.3 最优装载 • publ i c s t a t i c fl oa t l oad i n g (fl oa t c , fl oa t [] w , i nt [] x) • { • i nt n=w .l e ngt h; • E l e m e nt [] d = ne w E l e m e nt [n]; • for ( i nt i = 0; i < n; i ++) • d[i ] = ne w E l e m e nt (w [i ],i ); • M e r ge S ort . m e r ge S ort (d); • fl oa t opt =0; • for ( i nt i = 0; i < n; i ++) x[i ] = 0; • for ( i nt i = 0; i < n & & d[i ].w <= c ; i ++) { • x[d[i ].i ] = 1; • opt +=d[i ].w ; • c -= d[i ].w ; • } • re t urn opt ; • } 其中 El e me n t 类说明为 参 ⻅本书 P 1 15 0 4.3 最优装载 2 、贪⼼选择性质 可以证明最优装载问题具有贪⼼选择性质 。 3 、最优⼦结构性质 最优装载问题具有最优⼦结构性质。 由最优装载问题的贪⼼选择性质和最优⼦结构性质， 容易证明算法 l oad i n g 的正确性。 算法 l oad i n g 的主要计算量在于将集装箱依其重量从 ⼩到⼤排序，故算法所需的计算时间为 O( n l ogn ) 。 0 4.4 哈夫曼编码 哈夫曼编码 是⼴泛地⽤于数据⽂件压缩的⼗分有效的 编码⽅法。其压缩率通常在 20% ～ 90% 之间。哈夫曼编 码算法⽤字符在⽂件中出现的频率表来建⽴⼀个 ⽤ 0 ， 1 串表示各字符的最优表示⽅式。 给出现频率⾼的字符较短的编码，出现频率较低的字 符以较⻓的编码，可以⼤⼤缩短总码⻓。 1 、前缀码 对每⼀个字符规定⼀个 0,1 串作为其代码，并要求任 ⼀字符的代码都不是其它字符代码的前缀。这种编码 称为 前缀码 。 0 4.4 哈夫曼编码 编码的前缀性质可以使译码⽅法⾮常简单。 表示 最优前缀码 的⼆叉树总是⼀棵 完全⼆叉树 ，即树 中任⼀结点都有 2 个⼉⼦结点。 平均码⻓ 定义为： 使平均码⻓达到最⼩的前缀码编码⽅案称为给定编码 字符集 C 的 最优前缀码 。 0 4.4 哈夫曼编码 2 、构造哈夫曼编码 哈夫曼提出构造最优前缀码的贪⼼算法，由此产⽣的 编码⽅案称为 哈夫曼编码 。 哈夫曼算法以⾃底向上的⽅式构造表示最优前缀码的 ⼆叉树 T 。 算法以 | C| 个叶结点开始，执⾏ | C| － 1 次的 “ 合并 ” 运算 后产⽣最终所要求的树 T 。 0 4.4 哈夫曼编码 在书上给出的算法 huf fm a nT re e 中，编码字符集中每 ⼀字符 c 的频率是 f(c ) 。 以 f 为键值的优先队列 Q ⽤在 贪 ⼼选择 时有效地确定算法当前要合并的 2 棵具有最⼩频 率的树。⼀旦 2 棵具有最⼩频率的树合并后，产⽣⼀棵 新的树，其频率为合并的 2 棵树的频率之和，并将新树 插⼊优先队列 Q 。经过 n － 1 次的合并后，优先队列中只 剩下⼀棵树，即所要求的树 T 。 算法 huf fm a nT re e ⽤最⼩堆实现优先队列 Q 。初始化优 先队列需要 O (n) 计算时间，由于最⼩堆的 re m ove M i n 和 put 运算均需 O( l ogn ) 时间， n － 1 次的合并总共需要 O( nl ogn ) 计算时间。因此，关于 n 个字符的哈夫曼算法 的 计算时间 为 O( nl ogn ) 。 0 4.4 哈夫曼编码 3 、哈夫曼算法的正确性 要证明哈夫曼算法的正确性，只要证明最优前缀码问 题具有 贪⼼选择性质 和 最优⼦结构性质 。        (1)贪⼼选择性质        (2)最优⼦结构性质   0 4.5 单源最短路径 给定带权有向图 G =(V ,E ) ，其中每条边的权是⾮负实 数。另外，还给定 V 中的⼀个顶点，称为 源 。现在要计 算从源到所有其它各顶点的 最短路⻓度 。这⾥路的⻓ 度是指路上各边权之和。这个问题通常称为 单源最短 路径问题 。    1、算法基本思想 D i j ks t ra 算法是解单源最短路径问题的贪⼼算法。     0 4.5 单源最短路径 其 基本思想 是，设置顶点集合 S 并不断地作 贪⼼选择 来扩充这个集合。⼀个顶点属于集合 S 当且仅当从源到 该顶点的最短路径⻓度已知。 初始时， S 中仅含有源。设 u 是 G 的某⼀个顶点，把从 源到 u 且中间只经过 S 中顶点的路称为从源到 u 的特殊路 径，并⽤数组 di s t 记录当前每个顶点所对应的最短特殊 路径⻓度。 D i j ks t ra 算法每次从 V -S 中取出具有最短特殊 路⻓度的顶点 u ，将 u 添加到 S 中，同时对数组 di s t 作必 要的修改。⼀旦 S 包含了所有 V 中顶点， di s t 就记录了从 源到所有其它顶点之间的最短路径⻓度。 0 4.5 单源最短路径 例如 ，对右图中的有向 图，应⽤ D i j ks t ra 算法计 算从源顶点 1 到其它顶点 间最短路径的过程列在 下⻚的表中。 0 4.5 单源最短路径 603050105{1,2,4,3,5}4 603050103{1,2,4,3}3 903050104{1,2,4}2 1003060102{1,2}1 10030m a xi nt10-{1}初始 d i s t[5]d i s t[4]d i s t[3]d i s t[2]uS迭代 D i j ks t ra 算法的迭代过程： 0 4.5 单源最短路径 2 、算法的正确性和计算复杂性 (1)贪⼼选择性质 (2)最优⼦结构性质 (3)计算复杂性 对于具有 n 个顶点和 e 条边的带权有向图，如果⽤带权 邻接矩阵表示这个图，那么 D i j ks t ra 算法的主循环体需 要 时间。这个循环需要执⾏ n-1 次，所以完成循环需 要 时间。算法的其余部分所需要时间不超过 。 0 4.6 最⼩⽣成树 设 G =(V ,E ) 是⽆向连通带权图，即⼀个 ⽹络 。 E 中每 条边 (v ,w ) 的权为 c [v][w ] 。如果 G 的⼦图 G’ 是⼀棵包含 G 的所有顶点的树，则称 G’ 为 G 的⽣成树。⽣成树上各边 权的总和称为该⽣成树的 耗费 。在 G 的所有⽣成树中， 耗费最⼩的⽣成树称为 G 的 最⼩⽣成树 。 ⽹络的最⼩⽣成树在实际中有⼴泛应⽤。 例如 ，在设 计通信⽹络时，⽤图的顶点表示城市，⽤边 (v ,w ) 的 权 c [v][w ] 表示建⽴城市 v 和城市 w 之间的通信线路所需 的费⽤，则最⼩⽣成树就给出了建⽴通信⽹络的最经 济的⽅案。 0 4.6 最⼩⽣成树 1 、最⼩⽣成树性质 ⽤贪⼼算法设计策略可以设计出构造最⼩⽣成树的有 效算法。本节介绍的构造最⼩⽣成树的 Prim 算法 和 K r u s k al 算法 都可以看作是应⽤贪⼼算法设计策略的例 ⼦。尽管这 2 个算法做贪⼼选择的⽅式不同，它们都利 ⽤了下⾯的 最⼩⽣成树性质 ： 设 G =(V ,E ) 是连通带权图， U 是 V 的真⼦集。如果 (u,v) \u0000 E ，且 u \u0000 U ， v \u0000 V -U ，且在所有这样的边中， (u,v) 的权 c [u][v] 最⼩，那么⼀定存在 G 的⼀棵最⼩⽣成树， 它以 (u,v) 为其中⼀条边。这个性质有时也称为 MST 性 质 。 0 4.6 最⼩⽣成树 2 、 Prim算法 设 G =(V ,E ) 是连通带权图， V ={1,2,…,n} 。 构造 G 的最⼩⽣成树的 P ri m 算法的 基本思想 是：⾸先 置 S ={1} ，然后，只要 S 是 V 的真⼦集，就作如下的 贪 ⼼选择 ： 选取满⾜条件 i \u0000 S ， j \u0000 V -S ，且 c [i ][j ] 最⼩的 边，将顶点 j 添加到 S 中。这个过程⼀直进⾏到 S =V 时为 ⽌。 在这个过程中选取到的所有边恰好构成 G 的⼀棵 最⼩ ⽣成树 。 0 4.2 贪⼼算法的基本要素 对于 0-1 背包问题 ，贪⼼选择之所以不能得到最优解是因 为在这种情况下，它⽆法保证最终能将背包装满，部分闲 置的背包空间使每公⽄背包空间的价值降低了。事实上， 在考虑 0-1 背包问题时，应⽐较选择该物品和不选择该物 品所导致的最终⽅案，然后再作出最好选择。由此就导出 许多互相重叠的⼦问题。这正是该问题可⽤ 动态规划算法 求解的另⼀重要特征。 实际上也是如此，动态规划算法的确可以有效地解 0-1 背 包问题。 0 4.3 最优装载 有⼀批集装箱要装上⼀艘载重量为 c 的轮船。其中集 装箱 i 的重量为 Wi 。最优装载问题要求确定在装载体积 不受限制的情况下，将尽可能多的集装箱装上轮船。 1 、算法描述 最优装载问题可⽤贪⼼算法求解。采⽤重量最轻者先 装的贪⼼选择策略，可产⽣最优装载问题的最优解。 具体算法描述如下⻚。 0 4.3 最优装载 • publ i c s t a t i c fl oa t l oad i n g (fl oa t c , fl oa t [] w , i nt [] x) • { • i nt n=w .l e ngt h; • E l e m e nt [] d = ne w E l e m e nt [n]; • for ( i nt i = 0; i < n; i ++) • d[i ] = ne w E l e m e nt (w [i ],i ); • M e r ge S ort . m e r ge S ort (d); • fl oa t opt =0; • for ( i nt i = 0; i < n; i ++) x[i ] = 0; • for ( i nt i = 0; i < n & & d[i ].w <= c ; i ++) { • x[d[i ].i ] = 1; • opt +=d[i ].w ; • c -= d[i ].w ; • } • re t urn opt ; • } 其中 El e me n t 类说明为 参 ⻅本书 P 1 15 0 4.3 最优装载 2 、贪⼼选择性质 可以证明最优装载问题具有贪⼼选择性质 。 3 、最优⼦结构性质 最优装载问题具有最优⼦结构性质。 由最优装载问题的贪⼼选择性质和最优⼦结构性质， 容易证明算法 l oad i n g 的正确性。 算法 l oad i n g 的主要计算量在于将集装箱依其重量从 ⼩到⼤排序，故算法所需的计算时间为 O( n l ogn ) 。 0 4.4 哈夫曼编码 哈夫曼编码 是⼴泛地⽤于数据⽂件压缩的⼗分有效的 编码⽅法。其压缩率通常在 20% ～ 90% 之间。哈夫曼编 码算法⽤字符在⽂件中出现的频率表来建⽴⼀个 ⽤ 0 ， 1 串表示各字符的最优表示⽅式。 给出现频率⾼的字符较短的编码，出现频率较低的字 符以较⻓的编码，可以⼤⼤缩短总码⻓。 1 、前缀码 对每⼀个字符规定⼀个 0,1 串作为其代码，并要求任 ⼀字符的代码都不是其它字符代码的前缀。这种编码 称为 前缀码 。 0 4.4 哈夫曼编码 编码的前缀性质可以使译码⽅法⾮常简单。 表示 最优前缀码 的⼆叉树总是⼀棵 完全⼆叉树 ，即树 中任⼀结点都有 2 个⼉⼦结点。 平均码⻓ 定义为： 使平均码⻓达到最⼩的前缀码编码⽅案称为给定编码 字符集 C 的 最优前缀码 。 0 4.4 哈夫曼编码 2 、构造哈夫曼编码 哈夫曼提出构造最优前缀码的贪⼼算法，由此产⽣的 编码⽅案称为 哈夫曼编码 。 哈夫曼算法以⾃底向上的⽅式构造表示最优前缀码的 ⼆叉树 T 。 算法以 | C| 个叶结点开始，执⾏ | C| － 1 次的 “ 合并 ” 运算 后产⽣最终所要求的树 T 。 0 4.4 哈夫曼编码 在书上给出的算法 huf fm a nT re e 中，编码字符集中每 ⼀字符 c 的频率是 f(c ) 。 以 f 为键值的优先队列 Q ⽤在 贪 ⼼选择 时有效地确定算法当前要合并的 2 棵具有最⼩频 率的树。⼀旦 2 棵具有最⼩频率的树合并后，产⽣⼀棵 新的树，其频率为合并的 2 棵树的频率之和，并将新树 插⼊优先队列 Q 。经过 n － 1 次的合并后，优先队列中只 剩下⼀棵树，即所要求的树 T 。 算法 huf fm a nT re e ⽤最⼩堆实现优先队列 Q 。初始化优 先队列需要 O (n) 计算时间，由于最⼩堆的 re m ove M i n 和 put 运算均需 O( l ogn ) 时间， n － 1 次的合并总共需要 O( nl ogn ) 计算时间。因此，关于 n 个字符的哈夫曼算法 的 计算时间 为 O( nl ogn ) 。 0 4.4 哈夫曼编码 3 、哈夫曼算法的正确性 要证明哈夫曼算法的正确性，只要证明最优前缀码问 题具有 贪⼼选择性质 和 最优⼦结构性质 。        (1)贪⼼选择性质        (2)最优⼦结构性质   0 4.5 单源最短路径 给定带权有向图 G =(V ,E ) ，其中每条边的权是⾮负实 数。另外，还给定 V 中的⼀个顶点，称为 源 。现在要计 算从源到所有其它各顶点的 最短路⻓度 。这⾥路的⻓ 度是指路上各边权之和。这个问题通常称为 单源最短 路径问题 。    1、算法基本思想 D i j ks t ra 算法是解单源最短路径问题的贪⼼算法。     0 4.5 单源最短路径 其 基本思想 是，设置顶点集合 S 并不断地作 贪⼼选择 来扩充这个集合。⼀个顶点属于集合 S 当且仅当从源到 该顶点的最短路径⻓度已知。 初始时， S 中仅含有源。设 u 是 G 的某⼀个顶点，把从 源到 u 且中间只经过 S 中顶点的路称为从源到 u 的特殊路 径，并⽤数组 di s t 记录当前每个顶点所对应的最短特殊 路径⻓度。 D i j ks t ra 算法每次从 V -S 中取出具有最短特殊 路⻓度的顶点 u ，将 u 添加到 S 中，同时对数组 di s t 作必 要的修改。⼀旦 S 包含了所有 V 中顶点， di s t 就记录了从 源到所有其它顶点之间的最短路径⻓度。 0 4.5 单源最短路径 例如 ，对右图中的有向 图，应⽤ D i j ks t ra 算法计 算从源顶点 1 到其它顶点 间最短路径的过程列在 下⻚的表中。 0 4.5 单源最短路径 603050105{1,2,4,3,5}4 603050103{1,2,4,3}3 903050104{1,2,4}2 1003060102{1,2}1 10030m a xi nt10-{1}初始 d i s t[5]d i s t[4]d i s t[3]d i s t[2]uS迭代 D i j ks t ra 算法的迭代过程： 0 4.5 单源最短路径 2 、算法的正确性和计算复杂性 (1)贪⼼选择性质 (2)最优⼦结构性质 (3)计算复杂性 对于具有 n 个顶点和 e 条边的带权有向图，如果⽤带权 邻接矩阵表示这个图，那么 D i j ks t ra 算法的主循环体需 要 时间。这个循环需要执⾏ n-1 次，所以完成循环需 要 时间。算法的其余部分所需要时间不超过 。 0 4.6 最⼩⽣成树 设 G =(V ,E ) 是⽆向连通带权图，即⼀个 ⽹络 。 E 中每 条边 (v ,w ) 的权为 c [v][w ] 。如果 G 的⼦图 G’ 是⼀棵包含 G 的所有顶点的树，则称 G’ 为 G 的⽣成树。⽣成树上各边 权的总和称为该⽣成树的 耗费 。在 G 的所有⽣成树中， 耗费最⼩的⽣成树称为 G 的 最⼩⽣成树 。 ⽹络的最⼩⽣成树在实际中有⼴泛应⽤。 例如 ，在设 计通信⽹络时，⽤图的顶点表示城市，⽤边 (v ,w ) 的 权 c [v][w ] 表示建⽴城市 v 和城市 w 之间的通信线路所需 的费⽤，则最⼩⽣成树就给出了建⽴通信⽹络的最经 济的⽅案。 0 4.6 最⼩⽣成树 1 、最⼩⽣成树性质 ⽤贪⼼算法设计策略可以设计出构造最⼩⽣成树的有 效算法。本节介绍的构造最⼩⽣成树的 Prim 算法 和 K r u s k al 算法 都可以看作是应⽤贪⼼算法设计策略的例 ⼦。尽管这 2 个算法做贪⼼选择的⽅式不同，它们都利 ⽤了下⾯的 最⼩⽣成树性质 ： 设 G =(V ,E ) 是连通带权图， U 是 V 的真⼦集。如果 (u,v) \u0000 E ，且 u \u0000 U ， v \u0000 V -U ，且在所有这样的边中， (u,v) 的权 c [u][v] 最⼩，那么⼀定存在 G 的⼀棵最⼩⽣成树， 它以 (u,v) 为其中⼀条边。这个性质有时也称为 MST 性 质 。 0 4.6 最⼩⽣成树 2 、 Prim算法 设 G =(V ,E ) 是连通带权图， V ={1,2,…,n} 。 构造 G 的最⼩⽣成树的 P ri m 算法的 基本思想 是：⾸先 置 S ={1} ，然后，只要 S 是 V 的真⼦集，就作如下的 贪 ⼼选择 ： 选取满⾜条件 i \u0000 S ， j \u0000 V -S ，且 c [i ][j ] 最⼩的 边，将顶点 j 添加到 S 中。这个过程⼀直进⾏到 S =V 时为 ⽌。 在这个过程中选取到的所有边恰好构成 G 的⼀棵 最⼩ ⽣成树 。 0 4.2 贪⼼算法的基本要素 对于 0-1 背包问题 ，贪⼼选择之所以不能得到最优解是因 为在这种情况下，它⽆法保证最终能将背包装满，部分闲 置的背包空间使每公⽄背包空间的价值降低了。事实上， 在考虑 0-1 背包问题时，应⽐较选择该物品和不选择该物 品所导致的最终⽅案，然后再作出最好选择。由此就导出 许多互相重叠的⼦问题。这正是该问题可⽤ 动态规划算法 求解的另⼀重要特征。 实际上也是如此，动态规划算法的确可以有效地解 0-1 背 包问题。 0 4.3 最优装载 有⼀批集装箱要装上⼀艘载重量为 c 的轮船。其中集 装箱 i 的重量为 Wi 。最优装载问题要求确定在装载体积 不受限制的情况下，将尽可能多的集装箱装上轮船。 1 、算法描述 最优装载问题可⽤贪⼼算法求解。采⽤重量最轻者先 装的贪⼼选择策略，可产⽣最优装载问题的最优解。 具体算法描述如下⻚。 0 4.3 最优装载 • publ i c s t a t i c fl oa t l oad i n g (fl oa t c , fl oa t [] w , i nt [] x) • { • i nt n=w .l e ngt h; • E l e m e nt [] d = ne w E l e m e nt [n]; • for ( i nt i = 0; i < n; i ++) • d[i ] = ne w E l e m e nt (w [i ],i ); • M e r ge S ort . m e r ge S ort (d); • fl oa t opt =0; • for ( i nt i = 0; i < n; i ++) x[i ] = 0; • for ( i nt i = 0; i < n & & d[i ].w <= c ; i ++) { • x[d[i ].i ] = 1; • opt +=d[i ].w ; • c -= d[i ].w ; • } • re t urn opt ; • } 其中 El e me n t 类说明为 参 ⻅本书 P 1 15 0 4.3 最优装载 2 、贪⼼选择性质 可以证明最优装载问题具有贪⼼选择性质 。 3 、最优⼦结构性质 最优装载问题具有最优⼦结构性质。 由最优装载问题的贪⼼选择性质和最优⼦结构性质， 容易证明算法 l oad i n g 的正确性。 算法 l oad i n g 的主要计算量在于将集装箱依其重量从 ⼩到⼤排序，故算法所需的计算时间为 O( n l ogn ) 。 0 4.4 哈夫曼编码 哈夫曼编码 是⼴泛地⽤于数据⽂件压缩的⼗分有效的 编码⽅法。其压缩率通常在 20% ～ 90% 之间。哈夫曼编 码算法⽤字符在⽂件中出现的频率表来建⽴⼀个 ⽤ 0 ， 1 串表示各字符的最优表示⽅式。 给出现频率⾼的字符较短的编码，出现频率较低的字 符以较⻓的编码，可以⼤⼤缩短总码⻓。 1 、前缀码 对每⼀个字符规定⼀个 0,1 串作为其代码，并要求任 ⼀字符的代码都不是其它字符代码的前缀。这种编码 称为 前缀码 。 0 4.4 哈夫曼编码 编码的前缀性质可以使译码⽅法⾮常简单。 表示 最优前缀码 的⼆叉树总是⼀棵 完全⼆叉树 ，即树 中任⼀结点都有 2 个⼉⼦结点。 平均码⻓ 定义为： 使平均码⻓达到最⼩的前缀码编码⽅案称为给定编码 字符集 C 的 最优前缀码 。 0 4.4 哈夫曼编码 2 、构造哈夫曼编码 哈夫曼提出构造最优前缀码的贪⼼算法，由此产⽣的 编码⽅案称为 哈夫曼编码 。 哈夫曼算法以⾃底向上的⽅式构造表示最优前缀码的 ⼆叉树 T 。 算法以 | C| 个叶结点开始，执⾏ | C| － 1 次的 “ 合并 ” 运算 后产⽣最终所要求的树 T 。 0 4.4 哈夫曼编码 在书上给出的算法 huf fm a nT re e 中，编码字符集中每 ⼀字符 c 的频率是 f(c ) 。 以 f 为键值的优先队列 Q ⽤在 贪 ⼼选择 时有效地确定算法当前要合并的 2 棵具有最⼩频 率的树。⼀旦 2 棵具有最⼩频率的树合并后，产⽣⼀棵 新的树，其频率为合并的 2 棵树的频率之和，并将新树 插⼊优先队列 Q 。经过 n － 1 次的合并后，优先队列中只 剩下⼀棵树，即所要求的树 T 。 算法 huf fm a nT re e ⽤最⼩堆实现优先队列 Q 。初始化优 先队列需要 O (n) 计算时间，由于最⼩堆的 re m ove M i n 和 put 运算均需 O( l ogn ) 时间， n － 1 次的合并总共需要 O( nl ogn ) 计算时间。因此，关于 n 个字符的哈夫曼算法 的 计算时间 为 O( nl ogn ) 。 0 4.4 哈夫曼编码 3 、哈夫曼算法的正确性 要证明哈夫曼算法的正确性，只要证明最优前缀码问 题具有 贪⼼选择性质 和 最优⼦结构性质 。        (1)贪⼼选择性质        (2)最优⼦结构性质   0 4.5 单源最短路径 给定带权有向图 G =(V ,E ) ，其中每条边的权是⾮负实 数。另外，还给定 V 中的⼀个顶点，称为 源 。现在要计 算从源到所有其它各顶点的 最短路⻓度 。这⾥路的⻓ 度是指路上各边权之和。这个问题通常称为 单源最短 路径问题 。    1、算法基本思想 D i j ks t ra 算法是解单源最短路径问题的贪⼼算法。     0 4.5 单源最短路径 其 基本思想 是，设置顶点集合 S 并不断地作 贪⼼选择 来扩充这个集合。⼀个顶点属于集合 S 当且仅当从源到 该顶点的最短路径⻓度已知。 初始时， S 中仅含有源。设 u 是 G 的某⼀个顶点，把从 源到 u 且中间只经过 S 中顶点的路称为从源到 u 的特殊路 径，并⽤数组 di s t 记录当前每个顶点所对应的最短特殊 路径⻓度。 D i j ks t ra 算法每次从 V -S 中取出具有最短特殊 路⻓度的顶点 u ，将 u 添加到 S 中，同时对数组 di s t 作必 要的修改。⼀旦 S 包含了所有 V 中顶点， di s t 就记录了从 源到所有其它顶点之间的最短路径⻓度。 0 4.5 单源最短路径 例如 ，对右图中的有向 图，应⽤ D i j ks t ra 算法计 算从源顶点 1 到其它顶点 间最短路径的过程列在 下⻚的表中。 0 4.5 单源最短路径 603050105{1,2,4,3,5}4 603050103{1,2,4,3}3 903050104{1,2,4}2 1003060102{1,2}1 10030m a xi nt10-{1}初始 d i s t[5]d i s t[4]d i s t[3]d i s t[2]uS迭代 D i j ks t ra 算法的迭代过程： 0 4.5 单源最短路径 2 、算法的正确性和计算复杂性 (1)贪⼼选择性质 (2)最优⼦结构性质 (3)计算复杂性 对于具有 n 个顶点和 e 条边的带权有向图，如果⽤带权 邻接矩阵表示这个图，那么 D i j ks t ra 算法的主循环体需 要 时间。这个循环需要执⾏ n-1 次，所以完成循环需 要 时间。算法的其余部分所需要时间不超过 。 0 4.6 最⼩⽣成树 设 G =(V ,E ) 是⽆向连通带权图，即⼀个 ⽹络 。 E 中每 条边 (v ,w ) 的权为 c [v][w ] 。如果 G 的⼦图 G’ 是⼀棵包含 G 的所有顶点的树，则称 G’ 为 G 的⽣成树。⽣成树上各边 权的总和称为该⽣成树的 耗费 。在 G 的所有⽣成树中， 耗费最⼩的⽣成树称为 G 的 最⼩⽣成树 。 ⽹络的最⼩⽣成树在实际中有⼴泛应⽤。 例如 ，在设 计通信⽹络时，⽤图的顶点表示城市，⽤边 (v ,w ) 的 权 c [v][w ] 表示建⽴城市 v 和城市 w 之间的通信线路所需 的费⽤，则最⼩⽣成树就给出了建⽴通信⽹络的最经 济的⽅案。 0 4.6 最⼩⽣成树 1 、最⼩⽣成树性质 ⽤贪⼼算法设计策略可以设计出构造最⼩⽣成树的有 效算法。本节介绍的构造最⼩⽣成树的 Prim 算法 和 K r u s k al 算法 都可以看作是应⽤贪⼼算法设计策略的例 ⼦。尽管这 2 个算法做贪⼼选择的⽅式不同，它们都利 ⽤了下⾯的 最⼩⽣成树性质 ： 设 G =(V ,E ) 是连通带权图， U 是 V 的真⼦集。如果 (u,v) \u0000 E ，且 u \u0000 U ， v \u0000 V -U ，且在所有这样的边中， (u,v) 的权 c [u][v] 最⼩，那么⼀定存在 G 的⼀棵最⼩⽣成树， 它以 (u,v) 为其中⼀条边。这个性质有时也称为 MST 性 质 。 0 4.6 最⼩⽣成树 2 、 Prim算法 设 G =(V ,E ) 是连通带权图， V ={1,2,…,n} 。 构造 G 的最⼩⽣成树的 P ri m 算法的 基本思想 是：⾸先 置 S ={1} ，然后，只要 S 是 V 的真⼦集，就作如下的 贪 ⼼选择 ： 选取满⾜条件 i \u0000 S ， j \u0000 V -S ，且 c [i ][j ] 最⼩的 边，将顶点 j 添加到 S 中。这个过程⼀直进⾏到 S =V 时为 ⽌。 在这个过程中选取到的所有边恰好构成 G 的⼀棵 最⼩ ⽣成树 。 0 4.2 贪⼼算法的基本要素 对于 0-1 背包问题 ，贪⼼选择之所以不能得到最优解是因 为在这种情况下，它⽆法保证最终能将背包装满，部分闲 置的背包空间使每公⽄背包空间的价值降低了。事实上， 在考虑 0-1 背包问题时，应⽐较选择该物品和不选择该物 品所导致的最终⽅案，然后再作出最好选择。由此就导出 许多互相重叠的⼦问题。这正是该问题可⽤ 动态规划算法 求解的另⼀重要特征。 实际上也是如此，动态规划算法的确可以有效地解 0-1 背 包问题。 0 4.3 最优装载 有⼀批集装箱要装上⼀艘载重量为 c 的轮船。其中集 装箱 i 的重量为 Wi 。最优装载问题要求确定在装载体积 不受限制的情况下，将尽可能多的集装箱装上轮船。 1 、算法描述 最优装载问题可⽤贪⼼算法求解。采⽤重量最轻者先 装的贪⼼选择策略，可产⽣最优装载问题的最优解。 具体算法描述如下⻚。 0 4.3 最优装载 • publ i c s t a t i c fl oa t l oad i n g (fl oa t c , fl oa t [] w , i nt [] x) • { • i nt n=w .l e ngt h; • E l e m e nt [] d = ne w E l e m e nt [n]; • for ( i nt i = 0; i < n; i ++) • d[i ] = ne w E l e m e nt (w [i ],i ); • M e r ge S ort . m e r ge S ort (d); • fl oa t opt =0; • for ( i nt i = 0; i < n; i ++) x[i ] = 0; • for ( i nt i = 0; i < n & & d[i ].w <= c ; i ++) { • x[d[i ].i ] = 1; • opt +=d[i ].w ; • c -= d[i ].w ; • } • re t urn opt ; • } 其中 El e me n t 类说明为 参 ⻅本书 P 1 15 0 4.3 最优装载 2 、贪⼼选择性质 可以证明最优装载问题具有贪⼼选择性质 。 3 、最优⼦结构性质 最优装载问题具有最优⼦结构性质。 由最优装载问题的贪⼼选择性质和最优⼦结构性质， 容易证明算法 l oad i n g 的正确性。 算法 l oad i n g 的主要计算量在于将集装箱依其重量从 ⼩到⼤排序，故算法所需的计算时间为 O( n l ogn ) 。 0 4.4 哈夫曼编码 哈夫曼编码 是⼴泛地⽤于数据⽂件压缩的⼗分有效的 编码⽅法。其压缩率通常在 20% ～ 90% 之间。哈夫曼编 码算法⽤字符在⽂件中出现的频率表来建⽴⼀个 ⽤ 0 ， 1 串表示各字符的最优表示⽅式。 给出现频率⾼的字符较短的编码，出现频率较低的字 符以较⻓的编码，可以⼤⼤缩短总码⻓。 1 、前缀码 对每⼀个字符规定⼀个 0,1 串作为其代码，并要求任 ⼀字符的代码都不是其它字符代码的前缀。这种编码 称为 前缀码 。 0 4.4 哈夫曼编码 编码的前缀性质可以使译码⽅法⾮常简单。 表示 最优前缀码 的⼆叉树总是⼀棵 完全⼆叉树 ，即树 中任⼀结点都有 2 个⼉⼦结点。 平均码⻓ 定义为： 使平均码⻓达到最⼩的前缀码编码⽅案称为给定编码 字符集 C 的 最优前缀码 。 0 4.4 哈夫曼编码 2 、构造哈夫曼编码 哈夫曼提出构造最优前缀码的贪⼼算法，由此产⽣的 编码⽅案称为 哈夫曼编码 。 哈夫曼算法以⾃底向上的⽅式构造表示最优前缀码的 ⼆叉树 T 。 算法以 | C| 个叶结点开始，执⾏ | C| － 1 次的 “ 合并 ” 运算 后产⽣最终所要求的树 T 。 0 4.4 哈夫曼编码 在书上给出的算法 huf fm a nT re e 中，编码字符集中每 ⼀字符 c 的频率是 f(c ) 。 以 f 为键值的优先队列 Q ⽤在 贪 ⼼选择 时有效地确定算法当前要合并的 2 棵具有最⼩频 率的树。⼀旦 2 棵具有最⼩频率的树合并后，产⽣⼀棵 新的树，其频率为合并的 2 棵树的频率之和，并将新树 插⼊优先队列 Q 。经过 n － 1 次的合并后，优先队列中只 剩下⼀棵树，即所要求的树 T 。 算法 huf fm a nT re e ⽤最⼩堆实现优先队列 Q 。初始化优 先队列需要 O (n) 计算时间，由于最⼩堆的 re m ove M i n 和 put 运算均需 O( l ogn ) 时间， n － 1 次的合并总共需要 O( nl ogn ) 计算时间。因此，关于 n 个字符的哈夫曼算法 的 计算时间 为 O( nl ogn ) 。 0 4.4 哈夫曼编码 3 、哈夫曼算法的正确性 要证明哈夫曼算法的正确性，只要证明最优前缀码问 题具有 贪⼼选择性质 和 最优⼦结构性质 。        (1)贪⼼选择性质        (2)最优⼦结构性质   0 4.5 单源最短路径 给定带权有向图 G =(V ,E ) ，其中每条边的权是⾮负实 数。另外，还给定 V 中的⼀个顶点，称为 源 。现在要计 算从源到所有其它各顶点的 最短路⻓度 。这⾥路的⻓ 度是指路上各边权之和。这个问题通常称为 单源最短 路径问题 。    1、算法基本思想 D i j ks t ra 算法是解单源最短路径问题的贪⼼算法。     0 4.5 单源最短路径 其 基本思想 是，设置顶点集合 S 并不断地作 贪⼼选择 来扩充这个集合。⼀个顶点属于集合 S 当且仅当从源到 该顶点的最短路径⻓度已知。 初始时， S 中仅含有源。设 u 是 G 的某⼀个顶点，把从 源到 u 且中间只经过 S 中顶点的路称为从源到 u 的特殊路 径，并⽤数组 di s t 记录当前每个顶点所对应的最短特殊 路径⻓度。 D i j ks t ra 算法每次从 V -S 中取出具有最短特殊 路⻓度的顶点 u ，将 u 添加到 S 中，同时对数组 di s t 作必 要的修改。⼀旦 S 包含了所有 V 中顶点， di s t 就记录了从 源到所有其它顶点之间的最短路径⻓度。 0 4.5 单源最短路径 例如 ，对右图中的有向 图，应⽤ D i j ks t ra 算法计 算从源顶点 1 到其它顶点 间最短路径的过程列在 下⻚的表中。 0 4.5 单源最短路径 603050105{1,2,4,3,5}4 603050103{1,2,4,3}3 903050104{1,2,4}2 1003060102{1,2}1 10030m a xi nt10-{1}初始 d i s t[5]d i s t[4]d i s t[3]d i s t[2]uS迭代 D i j ks t ra 算法的迭代过程： 0 4.5 单源最短路径 2 、算法的正确性和计算复杂性 (1)贪⼼选择性质 (2)最优⼦结构性质 (3)计算复杂性 对于具有 n 个顶点和 e 条边的带权有向图，如果⽤带权 邻接矩阵表示这个图，那么 D i j ks t ra 算法的主循环体需 要 时间。这个循环需要执⾏ n-1 次，所以完成循环需 要 时间。算法的其余部分所需要时间不超过 。 0 4.6 最⼩⽣成树 设 G =(V ,E ) 是⽆向连通带权图，即⼀个 ⽹络 。 E 中每 条边 (v ,w ) 的权为 c [v][w ] 。如果 G 的⼦图 G’ 是⼀棵包含 G 的所有顶点的树，则称 G’ 为 G 的⽣成树。⽣成树上各边 权的总和称为该⽣成树的 耗费 。在 G 的所有⽣成树中， 耗费最⼩的⽣成树称为 G 的 最⼩⽣成树 。 ⽹络的最⼩⽣成树在实际中有⼴泛应⽤。 例如 ，在设 计通信⽹络时，⽤图的顶点表示城市，⽤边 (v ,w ) 的 权 c [v][w ] 表示建⽴城市 v 和城市 w 之间的通信线路所需 的费⽤，则最⼩⽣成树就给出了建⽴通信⽹络的最经 济的⽅案。 0 4.6 最⼩⽣成树 1 、最⼩⽣成树性质 ⽤贪⼼算法设计策略可以设计出构造最⼩⽣成树的有 效算法。本节介绍的构造最⼩⽣成树的 Prim 算法 和 K r u s k al 算法 都可以看作是应⽤贪⼼算法设计策略的例 ⼦。尽管这 2 个算法做贪⼼选择的⽅式不同，它们都利 ⽤了下⾯的 最⼩⽣成树性质 ： 设 G =(V ,E ) 是连通带权图， U 是 V 的真⼦集。如果 (u,v) \u0000 E ，且 u \u0000 U ， v \u0000 V -U ，且在所有这样的边中， (u,v) 的权 c [u][v] 最⼩，那么⼀定存在 G 的⼀棵最⼩⽣成树， 它以 (u,v) 为其中⼀条边。这个性质有时也称为 MST 性 质 。 0 4.6 最⼩⽣成树 2 、 Prim算法 设 G =(V ,E ) 是连通带权图， V ={1,2,…,n} 。 构造 G 的最⼩⽣成树的 P ri m 算法的 基本思想 是：⾸先 置 S ={1} ，然后，只要 S 是 V 的真⼦集，就作如下的 贪 ⼼选择 ： 选取满⾜条件 i \u0000 S ， j \u0000 V -S ，且 c [i ][j ] 最⼩的 边，将顶点 j 添加到 S 中。这个过程⼀直进⾏到 S =V 时为 ⽌。 在这个过程中选取到的所有边恰好构成 G 的⼀棵 最⼩ ⽣成树 。 0 4.2 贪⼼算法的基本要素 对于 0-1 背包问题 ，贪⼼选择之所以不能得到最优解是因 为在这种情况下，它⽆法保证最终能将背包装满，部分闲 置的背包空间使每公⽄背包空间的价值降低了。事实上， 在考虑 0-1 背包问题时，应⽐较选择该物品和不选择该物 品所导致的最终⽅案，然后再作出最好选择。由此就导出 许多互相重叠的⼦问题。这正是该问题可⽤ 动态规划算法 求解的另⼀重要特征。 实际上也是如此，动态规划算法的确可以有效地解 0-1 背 包问题。 0 4.3 最优装载 有⼀批集装箱要装上⼀艘载重量为 c 的轮船。其中集 装箱 i 的重量为 Wi 。最优装载问题要求确定在装载体积 不受限制的情况下，将尽可能多的集装箱装上轮船。 1 、算法描述 最优装载问题可⽤贪⼼算法求解。采⽤重量最轻者先 装的贪⼼选择策略，可产⽣最优装载问题的最优解。 具体算法描述如下⻚。 0 4.3 最优装载 • publ i c s t a t i c fl oa t l oad i n g (fl oa t c , fl oa t [] w , i nt [] x) • { • i nt n=w .l e ngt h; • E l e m e nt [] d = ne w E l e m e nt [n]; • for ( i nt i = 0; i < n; i ++) • d[i ] = ne w E l e m e nt (w [i ],i ); • M e r ge S ort . m e r ge S ort (d); • fl oa t opt =0; • for ( i nt i = 0; i < n; i ++) x[i ] = 0; • for ( i nt i = 0; i < n & & d[i ].w <= c ; i ++) { • x[d[i ].i ] = 1; • opt +=d[i ].w ; • c -= d[i ].w ; • } • re t urn opt ; • } 其中 El e me n t 类说明为 参 ⻅本书 P 1 15 0 4.3 最优装载 2 、贪⼼选择性质 可以证明最优装载问题具有贪⼼选择性质 。 3 、最优⼦结构性质 最优装载问题具有最优⼦结构性质。 由最优装载问题的贪⼼选择性质和最优⼦结构性质， 容易证明算法 l oad i n g 的正确性。 算法 l oad i n g 的主要计算量在于将集装箱依其重量从 ⼩到⼤排序，故算法所需的计算时间为 O( n l ogn ) 。 0 4.4 哈夫曼编码 哈夫曼编码 是⼴泛地⽤于数据⽂件压缩的⼗分有效的 编码⽅法。其压缩率通常在 20% ～ 90% 之间。哈夫曼编 码算法⽤字符在⽂件中出现的频率表来建⽴⼀个 ⽤ 0 ， 1 串表示各字符的最优表示⽅式。 给出现频率⾼的字符较短的编码，出现频率较低的字 符以较⻓的编码，可以⼤⼤缩短总码⻓。 1 、前缀码 对每⼀个字符规定⼀个 0,1 串作为其代码，并要求任 ⼀字符的代码都不是其它字符代码的前缀。这种编码 称为 前缀码 。 0 4.4 哈夫曼编码 编码的前缀性质可以使译码⽅法⾮常简单。 表示 最优前缀码 的⼆叉树总是⼀棵 完全⼆叉树 ，即树 中任⼀结点都有 2 个⼉⼦结点。 平均码⻓ 定义为： 使平均码⻓达到最⼩的前缀码编码⽅案称为给定编码 字符集 C 的 最优前缀码 。 0 4.4 哈夫曼编码 2 、构造哈夫曼编码 哈夫曼提出构造最优前缀码的贪⼼算法，由此产⽣的 编码⽅案称为 哈夫曼编码 。 哈夫曼算法以⾃底向上的⽅式构造表示最优前缀码的 ⼆叉树 T 。 算法以 | C| 个叶结点开始，执⾏ | C| － 1 次的 “ 合并 ” 运算 后产⽣最终所要求的树 T 。 0 4.4 哈夫曼编码 在书上给出的算法 huf fm a nT re e 中，编码字符集中每 ⼀字符 c 的频率是 f(c ) 。 以 f 为键值的优先队列 Q ⽤在 贪 ⼼选择 时有效地确定算法当前要合并的 2 棵具有最⼩频 率的树。⼀旦 2 棵具有最⼩频率的树合并后，产⽣⼀棵 新的树，其频率为合并的 2 棵树的频率之和，并将新树 插⼊优先队列 Q 。经过 n － 1 次的合并后，优先队列中只 剩下⼀棵树，即所要求的树 T 。 算法 huf fm a nT re e ⽤最⼩堆实现优先队列 Q 。初始化优 先队列需要 O (n) 计算时间，由于最⼩堆的 re m ove M i n 和 put 运算均需 O( l ogn ) 时间， n － 1 次的合并总共需要 O( nl ogn ) 计算时间。因此，关于 n 个字符的哈夫曼算法 的 计算时间 为 O( nl ogn ) 。 0 4.4 哈夫曼编码 3 、哈夫曼算法的正确性 要证明哈夫曼算法的正确性，只要证明最优前缀码问 题具有 贪⼼选择性质 和 最优⼦结构性质 。        (1)贪⼼选择性质        (2)最优⼦结构性质   0 4.5 单源最短路径 给定带权有向图 G =(V ,E ) ，其中每条边的权是⾮负实 数。另外，还给定 V 中的⼀个顶点，称为 源 。现在要计 算从源到所有其它各顶点的 最短路⻓度 。这⾥路的⻓ 度是指路上各边权之和。这个问题通常称为 单源最短 路径问题 。    1、算法基本思想 D i j ks t ra 算法是解单源最短路径问题的贪⼼算法。     0 4.5 单源最短路径 其 基本思想 是，设置顶点集合 S 并不断地作 贪⼼选择 来扩充这个集合。⼀个顶点属于集合 S 当且仅当从源到 该顶点的最短路径⻓度已知。 初始时， S 中仅含有源。设 u 是 G 的某⼀个顶点，把从 源到 u 且中间只经过 S 中顶点的路称为从源到 u 的特殊路 径，并⽤数组 di s t 记录当前每个顶点所对应的最短特殊 路径⻓度。 D i j ks t ra 算法每次从 V -S 中取出具有最短特殊 路⻓度的顶点 u ，将 u 添加到 S 中，同时对数组 di s t 作必 要的修改。⼀旦 S 包含了所有 V 中顶点， di s t 就记录了从 源到所有其它顶点之间的最短路径⻓度。 0 4.5 单源最短路径 例如 ，对右图中的有向 图，应⽤ D i j ks t ra 算法计 算从源顶点 1 到其它顶点 间最短路径的过程列在 下⻚的表中。 0 4.5 单源最短路径 603050105{1,2,4,3,5}4 603050103{1,2,4,3}3 903050104{1,2,4}2 1003060102{1,2}1 10030m a xi nt10-{1}初始 d i s t[5]d i s t[4]d i s t[3]d i s t[2]uS迭代 D i j ks t ra 算法的迭代过程： 0 4.5 单源最短路径 2 、算法的正确性和计算复杂性 (1)贪⼼选择性质 (2)最优⼦结构性质 (3)计算复杂性 对于具有 n 个顶点和 e 条边的带权有向图，如果⽤带权 邻接矩阵表示这个图，那么 D i j ks t ra 算法的主循环体需 要 时间。这个循环需要执⾏ n-1 次，所以完成循环需 要 时间。算法的其余部分所需要时间不超过 。 0 4.6 最⼩⽣成树 设 G =(V ,E ) 是⽆向连通带权图，即⼀个 ⽹络 。 E 中每 条边 (v ,w ) 的权为 c [v][w ] 。如果 G 的⼦图 G’ 是⼀棵包含 G 的所有顶点的树，则称 G’ 为 G 的⽣成树。⽣成树上各边 权的总和称为该⽣成树的 耗费 。在 G 的所有⽣成树中， 耗费最⼩的⽣成树称为 G 的 最⼩⽣成树 。 ⽹络的最⼩⽣成树在实际中有⼴泛应⽤。 例如 ，在设 计通信⽹络时，⽤图的顶点表示城市，⽤边 (v ,w ) 的 权 c [v][w ] 表示建⽴城市 v 和城市 w 之间的通信线路所需 的费⽤，则最⼩⽣成树就给出了建⽴通信⽹络的最经 济的⽅案。 0 4.6 最⼩⽣成树 1 、最⼩⽣成树性质 ⽤贪⼼算法设计策略可以设计出构造最⼩⽣成树的有 效算法。本节介绍的构造最⼩⽣成树的 Prim 算法 和 K r u s k al 算法 都可以看作是应⽤贪⼼算法设计策略的例 ⼦。尽管这 2 个算法做贪⼼选择的⽅式不同，它们都利 ⽤了下⾯的 最⼩⽣成树性质 ： 设 G =(V ,E ) 是连通带权图， U 是 V 的真⼦集。如果 (u,v) \u0000 E ，且 u \u0000 U ， v \u0000 V -U ，且在所有这样的边中， (u,v) 的权 c [u][v] 最⼩，那么⼀定存在 G 的⼀棵最⼩⽣成树， 它以 (u,v) 为其中⼀条边。这个性质有时也称为 MST 性 质 。 0 4.6 最⼩⽣成树 2 、 Prim算法 设 G =(V ,E ) 是连通带权图， V ={1,2,…,n} 。 构造 G 的最⼩⽣成树的 P ri m 算法的 基本思想 是：⾸先 置 S ={1} ，然后，只要 S 是 V 的真⼦集，就作如下的 贪 ⼼选择 ： 选取满⾜条件 i \u0000 S ， j \u0000 V -S ，且 c [i ][j ] 最⼩的 边，将顶点 j 添加到 S 中。这个过程⼀直进⾏到 S =V 时为 ⽌。 在这个过程中选取到的所有边恰好构成 G 的⼀棵 最⼩ ⽣成树 。 0 4.2 贪⼼算法的基本要素 对于 0-1 背包问题 ，贪⼼选择之所以不能得到最优解是因 为在这种情况下，它⽆法保证最终能将背包装满，部分闲 置的背包空间使每公⽄背包空间的价值降低了。事实上， 在考虑 0-1 背包问题时，应⽐较选择该物品和不选择该物 品所导致的最终⽅案，然后再作出最好选择。由此就导出 许多互相重叠的⼦问题。这正是该问题可⽤ 动态规划算法 求解的另⼀重要特征。 实际上也是如此，动态规划算法的确可以有效地解 0-1 背 包问题。 0 4.3 最优装载 有⼀批集装箱要装上⼀艘载重量为 c 的轮船。其中集 装箱 i 的重量为 Wi 。最优装载问题要求确定在装载体积 不受限制的情况下，将尽可能多的集装箱装上轮船。 1 、算法描述 最优装载问题可⽤贪⼼算法求解。采⽤重量最轻者先 装的贪⼼选择策略，可产⽣最优装载问题的最优解。 具体算法描述如下⻚。 0 4.3 最优装载 • publ i c s t a t i c fl oa t l oad i n g (fl oa t c , fl oa t [] w , i nt [] x) • { • i nt n=w .l e ngt h; • E l e m e nt [] d = ne w E l e m e nt [n]; • for ( i nt i = 0; i < n; i ++) • d[i ] = ne w E l e m e nt (w [i ],i ); • M e r ge S ort . m e r ge S ort (d); • fl oa t opt =0; • for ( i nt i = 0; i < n; i ++) x[i ] = 0; • for ( i nt i = 0; i < n & & d[i ].w <= c ; i ++) { • x[d[i ].i ] = 1; • opt +=d[i ].w ; • c -= d[i ].w ; • } • re t urn opt ; • } 其中 El e me n t 类说明为 参 ⻅本书 P 1 15 0 4.3 最优装载 2 、贪⼼选择性质 可以证明最优装载问题具有贪⼼选择性质 。 3 、最优⼦结构性质 最优装载问题具有最优⼦结构性质。 由最优装载问题的贪⼼选择性质和最优⼦结构性质， 容易证明算法 l oad i n g 的正确性。 算法 l oad i n g 的主要计算量在于将集装箱依其重量从 ⼩到⼤排序，故算法所需的计算时间为 O( n l ogn ) 。 0 4.4 哈夫曼编码 哈夫曼编码 是⼴泛地⽤于数据⽂件压缩的⼗分有效的 编码⽅法。其压缩率通常在 20% ～ 90% 之间。哈夫曼编 码算法⽤字符在⽂件中出现的频率表来建⽴⼀个 ⽤ 0 ， 1 串表示各字符的最优表示⽅式。 给出现频率⾼的字符较短的编码，出现频率较低的字 符以较⻓的编码，可以⼤⼤缩短总码⻓。 1 、前缀码 对每⼀个字符规定⼀个 0,1 串作为其代码，并要求任 ⼀字符的代码都不是其它字符代码的前缀。这种编码 称为 前缀码 。 0 4.4 哈夫曼编码 编码的前缀性质可以使译码⽅法⾮常简单。 表示 最优前缀码 的⼆叉树总是⼀棵 完全⼆叉树 ，即树 中任⼀结点都有 2 个⼉⼦结点。 平均码⻓ 定义为： 使平均码⻓达到最⼩的前缀码编码⽅案称为给定编码 字符集 C 的 最优前缀码 。 0 4.4 哈夫曼编码 2 、构造哈夫曼编码 哈夫曼提出构造最优前缀码的贪⼼算法，由此产⽣的 编码⽅案称为 哈夫曼编码 。 哈夫曼算法以⾃底向上的⽅式构造表示最优前缀码的 ⼆叉树 T 。 算法以 | C| 个叶结点开始，执⾏ | C| － 1 次的 “ 合并 ” 运算 后产⽣最终所要求的树 T 。 0 4.4 哈夫曼编码 在书上给出的算法 huf fm a nT re e 中，编码字符集中每 ⼀字符 c 的频率是 f(c ) 。 以 f 为键值的优先队列 Q ⽤在 贪 ⼼选择 时有效地确定算法当前要合并的 2 棵具有最⼩频 率的树。⼀旦 2 棵具有最⼩频率的树合并后，产⽣⼀棵 新的树，其频率为合并的 2 棵树的频率之和，并将新树 插⼊优先队列 Q 。经过 n － 1 次的合并后，优先队列中只 剩下⼀棵树，即所要求的树 T 。 算法 huf fm a nT re e ⽤最⼩堆实现优先队列 Q 。初始化优 先队列需要 O (n) 计算时间，由于最⼩堆的 re m ove M i n 和 put 运算均需 O( l ogn ) 时间， n － 1 次的合并总共需要 O( nl ogn ) 计算时间。因此，关于 n 个字符的哈夫曼算法 的 计算时间 为 O( nl ogn ) 。 0 4.4 哈夫曼编码 3 、哈夫曼算法的正确性 要证明哈夫曼算法的正确性，只要证明最优前缀码问 题具有 贪⼼选择性质 和 最优⼦结构性质 。        (1)贪⼼选择性质        (2)最优⼦结构性质   0 4.5 单源最短路径 给定带权有向图 G =(V ,E ) ，其中每条边的权是⾮负实 数。另外，还给定 V 中的⼀个顶点，称为 源 。现在要计 算从源到所有其它各顶点的 最短路⻓度 。这⾥路的⻓ 度是指路上各边权之和。这个问题通常称为 单源最短 路径问题 。    1、算法基本思想 D i j ks t ra 算法是解单源最短路径问题的贪⼼算法。     0 4.5 单源最短路径 其 基本思想 是，设置顶点集合 S 并不断地作 贪⼼选择 来扩充这个集合。⼀个顶点属于集合 S 当且仅当从源到 该顶点的最短路径⻓度已知。 初始时， S 中仅含有源。设 u 是 G 的某⼀个顶点，把从 源到 u 且中间只经过 S 中顶点的路称为从源到 u 的特殊路 径，并⽤数组 di s t 记录当前每个顶点所对应的最短特殊 路径⻓度。 D i j ks t ra 算法每次从 V -S 中取出具有最短特殊 路⻓度的顶点 u ，将 u 添加到 S 中，同时对数组 di s t 作必 要的修改。⼀旦 S 包含了所有 V 中顶点， di s t 就记录了从 源到所有其它顶点之间的最短路径⻓度。 0 4.5 单源最短路径 例如 ，对右图中的有向 图，应⽤ D i j ks t ra 算法计 算从源顶点 1 到其它顶点 间最短路径的过程列在 下⻚的表中。 0 4.5 单源最短路径 603050105{1,2,4,3,5}4 603050103{1,2,4,3}3 903050104{1,2,4}2 1003060102{1,2}1 10030m a xi nt10-{1}初始 d i s t[5]d i s t[4]d i s t[3]d i s t[2]uS迭代 D i j ks t ra 算法的迭代过程： 0 4.5 单源最短路径 2 、算法的正确性和计算复杂性 (1)贪⼼选择性质 (2)最优⼦结构性质 (3)计算复杂性 对于具有 n 个顶点和 e 条边的带权有向图，如果⽤带权 邻接矩阵表示这个图，那么 D i j ks t ra 算法的主循环体需 要 时间。这个循环需要执⾏ n-1 次，所以完成循环需 要 时间。算法的其余部分所需要时间不超过 。 0 4.6 最⼩⽣成树 设 G =(V ,E ) 是⽆向连通带权图，即⼀个 ⽹络 。 E 中每 条边 (v ,w ) 的权为 c [v][w ] 。如果 G 的⼦图 G’ 是⼀棵包含 G 的所有顶点的树，则称 G’ 为 G 的⽣成树。⽣成树上各边 权的总和称为该⽣成树的 耗费 。在 G 的所有⽣成树中， 耗费最⼩的⽣成树称为 G 的 最⼩⽣成树 。 ⽹络的最⼩⽣成树在实际中有⼴泛应⽤。 例如 ，在设 计通信⽹络时，⽤图的顶点表示城市，⽤边 (v ,w ) 的 权 c [v][w ] 表示建⽴城市 v 和城市 w 之间的通信线路所需 的费⽤，则最⼩⽣成树就给出了建⽴通信⽹络的最经 济的⽅案。 0 4.6 最⼩⽣成树 1 、最⼩⽣成树性质 ⽤贪⼼算法设计策略可以设计出构造最⼩⽣成树的有 效算法。本节介绍的构造最⼩⽣成树的 Prim 算法 和 K r u s k al 算法 都可以看作是应⽤贪⼼算法设计策略的例 ⼦。尽管这 2 个算法做贪⼼选择的⽅式不同，它们都利 ⽤了下⾯的 最⼩⽣成树性质 ： 设 G =(V ,E ) 是连通带权图， U 是 V 的真⼦集。如果 (u,v) \u0000 E ，且 u \u0000 U ， v \u0000 V -U ，且在所有这样的边中， (u,v) 的权 c [u][v] 最⼩，那么⼀定存在 G 的⼀棵最⼩⽣成树， 它以 (u,v) 为其中⼀条边。这个性质有时也称为 MST 性 质 。 0 4.6 最⼩⽣成树 2 、 Prim算法 设 G =(V ,E ) 是连通带权图， V ={1,2,…,n} 。 构造 G 的最⼩⽣成树的 P ri m 算法的 基本思想 是：⾸先 置 S ={1} ，然后，只要 S 是 V 的真⼦集，就作如下的 贪 ⼼选择 ： 选取满⾜条件 i \u0000 S ， j \u0000 V -S ，且 c [i ][j ] 最⼩的 边，将顶点 j 添加到 S 中。这个过程⼀直进⾏到 S =V 时为 ⽌。 在这个过程中选取到的所有边恰好构成 G 的⼀棵 最⼩ ⽣成树 。 0 4.2 贪⼼算法的基本要素 对于 0-1 背包问题 ，贪⼼选择之所以不能得到最优解是因 为在这种情况下，它⽆法保证最终能将背包装满，部分闲 置的背包空间使每公⽄背包空间的价值降低了。事实上， 在考虑 0-1 背包问题时，应⽐较选择该物品和不选择该物 品所导致的最终⽅案，然后再作出最好选择。由此就导出 许多互相重叠的⼦问题。这正是该问题可⽤ 动态规划算法 求解的另⼀重要特征。 实际上也是如此，动态规划算法的确可以有效地解 0-1 背 包问题。 0 4.3 最优装载 有⼀批集装箱要装上⼀艘载重量为 c 的轮船。其中集 装箱 i 的重量为 Wi 。最优装载问题要求确定在装载体积 不受限制的情况下，将尽可能多的集装箱装上轮船。 1 、算法描述 最优装载问题可⽤贪⼼算法求解。采⽤重量最轻者先 装的贪⼼选择策略，可产⽣最优装载问题的最优解。 具体算法描述如下⻚。 0 4.3 最优装载 • publ i c s t a t i c fl oa t l oad i n g (fl oa t c , fl oa t [] w , i nt [] x) • { • i nt n=w .l e ngt h; • E l e m e nt [] d = ne w E l e m e nt [n]; • for ( i nt i = 0; i < n; i ++) • d[i ] = ne w E l e m e nt (w [i ],i ); • M e r ge S ort . m e r ge S ort (d); • fl oa t opt =0; • for ( i nt i = 0; i < n; i ++) x[i ] = 0; • for ( i nt i = 0; i < n & & d[i ].w <= c ; i ++) { • x[d[i ].i ] = 1; • opt +=d[i ].w ; • c -= d[i ].w ; • } • re t urn opt ; • } 其中 El e me n t 类说明为 参 ⻅本书 P 1 15 0 4.3 最优装载 2 、贪⼼选择性质 可以证明最优装载问题具有贪⼼选择性质 。 3 、最优⼦结构性质 最优装载问题具有最优⼦结构性质。 由最优装载问题的贪⼼选择性质和最优⼦结构性质， 容易证明算法 l oad i n g 的正确性。 算法 l oad i n g 的主要计算量在于将集装箱依其重量从 ⼩到⼤排序，故算法所需的计算时间为 O( n l ogn ) 。 0 4.4 哈夫曼编码 哈夫曼编码 是⼴泛地⽤于数据⽂件压缩的⼗分有效的 编码⽅法。其压缩率通常在 20% ～ 90% 之间。哈夫曼编 码算法⽤字符在⽂件中出现的频率表来建⽴⼀个 ⽤ 0 ， 1 串表示各字符的最优表示⽅式。 给出现频率⾼的字符较短的编码，出现频率较低的字 符以较⻓的编码，可以⼤⼤缩短总码⻓。 1 、前缀码 对每⼀个字符规定⼀个 0,1 串作为其代码，并要求任 ⼀字符的代码都不是其它字符代码的前缀。这种编码 称为 前缀码 。 0 4.4 哈夫曼编码 编码的前缀性质可以使译码⽅法⾮常简单。 表示 最优前缀码 的⼆叉树总是⼀棵 完全⼆叉树 ，即树 中任⼀结点都有 2 个⼉⼦结点。 平均码⻓ 定义为： 使平均码⻓达到最⼩的前缀码编码⽅案称为给定编码 字符集 C 的 最优前缀码 。 0 4.4 哈夫曼编码 2 、构造哈夫曼编码 哈夫曼提出构造最优前缀码的贪⼼算法，由此产⽣的 编码⽅案称为 哈夫曼编码 。 哈夫曼算法以⾃底向上的⽅式构造表示最优前缀码的 ⼆叉树 T 。 算法以 | C| 个叶结点开始，执⾏ | C| － 1 次的 “ 合并 ” 运算 后产⽣最终所要求的树 T 。 0 4.4 哈夫曼编码 在书上给出的算法 huf fm a nT re e 中，编码字符集中每 ⼀字符 c 的频率是 f(c ) 。 以 f 为键值的优先队列 Q ⽤在 贪 ⼼选择 时有效地确定算法当前要合并的 2 棵具有最⼩频 率的树。⼀旦 2 棵具有最⼩频率的树合并后，产⽣⼀棵 新的树，其频率为合并的 2 棵树的频率之和，并将新树 插⼊优先队列 Q 。经过 n － 1 次的合并后，优先队列中只 剩下⼀棵树，即所要求的树 T 。 算法 huf fm a nT re e ⽤最⼩堆实现优先队列 Q 。初始化优 先队列需要 O (n) 计算时间，由于最⼩堆的 re m ove M i n 和 put 运算均需 O( l ogn ) 时间， n － 1 次的合并总共需要 O( nl ogn ) 计算时间。因此，关于 n 个字符的哈夫曼算法 的 计算时间 为 O( nl ogn ) 。 0 4.4 哈夫曼编码 3 、哈夫曼算法的正确性 要证明哈夫曼算法的正确性，只要证明最优前缀码问 题具有 贪⼼选择性质 和 最优⼦结构性质 。        (1)贪⼼选择性质        (2)最优⼦结构性质   0 4.5 单源最短路径 给定带权有向图 G =(V ,E ) ，其中每条边的权是⾮负实 数。另外，还给定 V 中的⼀个顶点，称为 源 。现在要计 算从源到所有其它各顶点的 最短路⻓度 。这⾥路的⻓ 度是指路上各边权之和。这个问题通常称为 单源最短 路径问题 。    1、算法基本思想 D i j ks t ra 算法是解单源最短路径问题的贪⼼算法。     0 4.5 单源最短路径 其 基本思想 是，设置顶点集合 S 并不断地作 贪⼼选择 来扩充这个集合。⼀个顶点属于集合 S 当且仅当从源到 该顶点的最短路径⻓度已知。 初始时， S 中仅含有源。设 u 是 G 的某⼀个顶点，把从 源到 u 且中间只经过 S 中顶点的路称为从源到 u 的特殊路 径，并⽤数组 di s t 记录当前每个顶点所对应的最短特殊 路径⻓度。 D i j ks t ra 算法每次从 V -S 中取出具有最短特殊 路⻓度的顶点 u ，将 u 添加到 S 中，同时对数组 di s t 作必 要的修改。⼀旦 S 包含了所有 V 中顶点， di s t 就记录了从 源到所有其它顶点之间的最短路径⻓度。 0 4.5 单源最短路径 例如 ，对右图中的有向 图，应⽤ D i j ks t ra 算法计 算从源顶点 1 到其它顶点 间最短路径的过程列在 下⻚的表中。 0 4.5 单源最短路径 603050105{1,2,4,3,5}4 603050103{1,2,4,3}3 903050104{1,2,4}2 1003060102{1,2}1 10030m a xi nt10-{1}初始 d i s t[5]d i s t[4]d i s t[3]d i s t[2]uS迭代 D i j ks t ra 算法的迭代过程： 0 4.5 单源最短路径 2 、算法的正确性和计算复杂性 (1)贪⼼选择性质 (2)最优⼦结构性质 (3)计算复杂性 对于具有 n 个顶点和 e 条边的带权有向图，如果⽤带权 邻接矩阵表示这个图，那么 D i j ks t ra 算法的主循环体需 要 时间。这个循环需要执⾏ n-1 次，所以完成循环需 要 时间。算法的其余部分所需要时间不超过 。 0 4.6 最⼩⽣成树 设 G =(V ,E ) 是⽆向连通带权图，即⼀个 ⽹络 。 E 中每 条边 (v ,w ) 的权为 c [v][w ] 。如果 G 的⼦图 G’ 是⼀棵包含 G 的所有顶点的树，则称 G’ 为 G 的⽣成树。⽣成树上各边 权的总和称为该⽣成树的 耗费 。在 G 的所有⽣成树中， 耗费最⼩的⽣成树称为 G 的 最⼩⽣成树 。 ⽹络的最⼩⽣成树在实际中有⼴泛应⽤。 例如 ，在设 计通信⽹络时，⽤图的顶点表示城市，⽤边 (v ,w ) 的 权 c [v][w ] 表示建⽴城市 v 和城市 w 之间的通信线路所需 的费⽤，则最⼩⽣成树就给出了建⽴通信⽹络的最经 济的⽅案。 0 4.6 最⼩⽣成树 1 、最⼩⽣成树性质 ⽤贪⼼算法设计策略可以设计出构造最⼩⽣成树的有 效算法。本节介绍的构造最⼩⽣成树的 Prim 算法 和 K r u s k al 算法 都可以看作是应⽤贪⼼算法设计策略的例 ⼦。尽管这 2 个算法做贪⼼选择的⽅式不同，它们都利 ⽤了下⾯的 最⼩⽣成树性质 ： 设 G =(V ,E ) 是连通带权图， U 是 V 的真⼦集。如果 (u,v) \u0000 E ，且 u \u0000 U ， v \u0000 V -U ，且在所有这样的边中， (u,v) 的权 c [u][v] 最⼩，那么⼀定存在 G 的⼀棵最⼩⽣成树， 它以 (u,v) 为其中⼀条边。这个性质有时也称为 MST 性 质 。 0 4.6 最⼩⽣成树 2 、 Prim算法 设 G =(V ,E ) 是连通带权图， V ={1,2,…,n} 。 构造 G 的最⼩⽣成树的 P ri m 算法的 基本思想 是：⾸先 置 S ={1} ，然后，只要 S 是 V 的真⼦集，就作如下的 贪 ⼼选择 ： 选取满⾜条件 i \u0000 S ， j \u0000 V -S ，且 c [i ][j ] 最⼩的 边，将顶点 j 添加到 S 中。这个过程⼀直进⾏到 S =V 时为 ⽌。 在这个过程中选取到的所有边恰好构成 G 的⼀棵 最⼩ ⽣成树 。 0 4.6 最⼩⽣成树 利⽤最⼩⽣成树性质和数 学归纳法容易证明，上述 算法中的 边集合 T 始终包 含 G 的某棵最⼩⽣成树中 的边 。因此，在算法结束 时， T 中的所有边构成 G 的 ⼀棵最⼩⽣成树。 例如 ，对于右图中的带权 图，按 Prim 算法 选取边的 过程如下⻚图所示。 0 4.6 最⼩⽣成树 0 4.6 最⼩⽣成树 在上述 P ri m 算法中，还应当考虑 如何有效地找出满⾜条 件 i \u0000\u0000 S ,j \u0000\u0000 V -S ，且权 c [i ][j] 最⼩的边 (i ,j) 。实现这个⽬的的 较简单的办法是设置 2 个数组 c l os e s t 和 l ow c os t 。 在 P ri m 算法执⾏过程中，先找出 V -S 中使 l ow c os t 值最⼩ 的顶点 j ，然后根据数组 c l os e s t 选取边 (j ,c l os e s t [j ］ ) ，最后 将 j 添加到 S 中，并对 c l os e s t 和 l ow c os t 作必要的修改。 ⽤这个办法实现的 P ri m 算法所需的 计算时间 为 0 4.6 最⼩⽣成树 3 、 Kruskal算法 K rus ka l 算法构造 G 的最⼩⽣成树的 基本思想 是，⾸ 先将 G 的 n 个顶点看成 n 个孤⽴的连通分⽀。将所有的边 按权从⼩到⼤排序。然后从第⼀条边开始，依边权递 增的顺序查看每⼀条边，并按下述⽅法连接 2 个不同的 连通分⽀：当查看到第 k 条边 (v ,w ) 时，如果端点 v 和 w 分别是当前 2 个不同的连通分⽀ T1 和 T2 中的顶点时，就 ⽤边 (v ,w ) 将 T1 和 T2 连接成⼀个连通分⽀，然后继续查 看第 k+1 条边；如果端点 v 和 w 在当前的同⼀个连通分⽀ 中，就直接再查看第 k+1 条边。这个过程⼀直进⾏到只 剩下⼀个连通分⽀时为⽌。 0 4.6 最⼩⽣成树 例如， 对前⾯的连通带权图，按 K rus ka l 算法顺序得到的最⼩ ⽣成树上的边如下图所示。 0 4.6 最⼩⽣成树 关于 集合的⼀些基本运算 可⽤于实现 K rus ka l 算法。 按权的递增顺序查看等价于对 优先队列 执 ⾏ r e move M i n 运算。可以⽤ 堆 实现这个优先队列。 对⼀个由连通分⽀组成的集合不断进⾏修改，需要⽤ 到抽象数据类型 并查集 U n i on F i n d 所⽀持的基本运算。 当图的边数为 e 时， K rus ka l 算法所需的 计算时间 是 。当 时， K rus ka l 算法⽐ P ri m 算法差，但当 时， K rus ka l 算法却⽐ P ri m 算法好得多。 0 4.7 多机调度问题 多机调度问题 要求给出⼀种作业调度⽅案，使所给的 n 个作业在尽可能短的时间内由 m 台机器加⼯处理完 成。 这个问题是 N P 完全问题 ，到⽬前为⽌还没有有效的 解法。对于这⼀类问题 , ⽤ 贪⼼选择策略 有时可以设计 出较好的近似算法。 约定，每个作业均可在任何⼀台机器上加⼯处理，但未完⼯ 前不允许中断处理。作业不能拆分成更⼩的⼦作业。 0 4.7 多机调度问题 采⽤ 最⻓处理时间作业优先 的贪⼼选择策略可以设计 出解多机调度问题的较好的近似算法。 按此策略，当 时，只要将机器 i 的 [0, ti ] 时间区间 分配给作业 i 即可，算法只需要 O (1) 时间。 当 时，⾸先将 n 个作业依其所需的处理时间从⼤ 到⼩排序。然后依此顺序将作业分配给空闲的处理 机。算法所需的计算时间为 O( n l ogn ) 。 0 4.7 多机调度问题 例如， 设 7 个独⽴作业 {1,2,3,4,5,6,7} 由 3 台机 器 M1 ， M2 和 M3 加⼯处理。各作业所需的处理时间 分别为 {2,14,4,16,6,5,3} 。按算法 gr e e d y 产⽣的作业调 度如下图所示，所需的加⼯时间为 17 。 0 4.8 贪⼼算法的理论基础 借助于 拟阵 ⼯具，可建⽴关于贪⼼算法的较⼀般的理 论。这个理论对 确定何时使⽤贪⼼算法 可以得到问题 的整体最优解⼗分有⽤。 1 、拟阵 拟阵 M 定义为满⾜下⾯ 3 个条件的有序对 (S ,I) ： (1)S 是⾮空有限集。 (2)I 是 S 的⼀类具有遗传性质的独⽴⼦集族，即若 B \u0000 I ， 则 B 是 S 的独⽴⼦集，且 B 的任意⼦集也都是 S 的独⽴⼦ 集。空集 \u0000 必为 I 的成员。 (3)I 满⾜交换性质，即若 A \u0000 I,B \u0000 I 且 | A | <| B| ，则存在某⼀ 元素 x \u0000 B-A ，使得 A ∪ {x} \u0000 I 。 0 4.8 贪⼼算法的理论基础 例如， 设 S 是⼀给定矩阵中⾏向量的集合， I 是 S 的线 性独⽴⼦集族，则由线性空间理论容易证明 (S ,I) 是⼀ 拟阵。拟阵的另⼀个例⼦是⽆向图 G =(V ,E ) 的图拟阵 。 给定拟阵 M =(S ,I) ，对于 I 中的独⽴⼦集 A \u0000 I ，若 S 有 ⼀元素 x \u0000 A ，使得将 x 加⼊ A 后仍保持独⽴性，即 A ∪ {x} \u0000 I, 则称 x 为 A 的 可扩展元素 。 当拟阵 M 中的独⽴⼦集 A 没有可扩展元素时，称 A 为 极⼤独⽴⼦集 。 0 4.8 贪⼼算法的理论基础 下⾯的关于 极⼤独⽴⼦集 的性质是很有⽤的。 定理 4.1 ： 拟阵 M 中所有极⼤独⽴⼦集⼤⼩相同。 这个定理可以⽤反证法证明。 若对拟阵 M =(S ,I) 中的 S 指定权函数 W ，使得对于任 意 x \u0000 S ，有 W (x)>0 ，则称拟阵 M 为 带权拟阵 。依此权 函数， S 的任⼀⼦集 A 的权定义为 。 2 、关于带权拟阵的贪⼼算法 许多可以⽤贪⼼算法求解的问题可以表示为求带权拟 阵的 最⼤权独⽴⼦集问题 。 0 4.8 贪⼼算法的理论基础 给定带权拟阵 M =(S ,I) ，确定 S 的独⽴⼦集 A \u0000 I 使得 W (A ) 达到最⼤。这种使 W (A ) 最⼤的独⽴⼦集 A 称为拟 阵 M 的 最优⼦集 。由于 S 中任⼀元素 x 的权 W (x) 是正 的，因此， 最优⼦集也⼀定是极⼤独⽴⼦集 。 例如， 在最⼩⽣成树问题可以表示为确定带权拟阵 的最优⼦集问题。求带权拟阵的最优⼦集 A 的算法可⽤ 于解最⼩⽣成树问题。 下⾯给出求 带权拟阵最优⼦集 的贪⼼算法。该算法以 具有正权函数 W 的带权拟阵 M =(S ,I) 作为输⼊，经计算 后输出 M 的最优⼦集 A 。 0 4.8 贪⼼算法的理论基础 • Set gr e e d y (M ,W ) • {A = \u0000 ; • 将 S 中元素依权值 W （⼤者优先）组成优先队列； • w hi l e (S != \u0000 ) { • S . re m ove M a x (x); • i f (A ∪ {x} \u0000 I) A =A ∪ {x}; • } • re t urn A • } 0 4.8 贪⼼算法的理论基础 算法 gr e e d y 的计算时间复杂性为 。 引理 4.2 ( 拟阵的贪⼼选择性质 ) 设 M =(S ,I) 是具有权函数 W 的带权拟阵，且 S 中元素依 权值从⼤到⼩排列。⼜设 x \u0000 S 是 S 中第⼀个使得 {x} 是 独⽴⼦集的元素，则存在 S 的最优⼦集 A 使得 x \u0000 A 。 算法 gr e e d y 在以贪⼼选择构造最优⼦集 A 时，⾸次选 ⼊集合 A 中的元素 x 是单元素独⽴集中具有最⼤权的元 素。此时可能已经舍弃了 S 中部分元素。可以证明这些 被舍弃的元素不可能⽤于构造最优⼦集。 0 4.8 贪⼼算法的理论基础 引理 4.3 ： 设 M =(S ,I) 是拟阵。若 S 中元素 x 不是空集 \u0000 的 可扩展元素，则 x 也不可能是 S 中任⼀独⽴⼦集 A 的可扩 展元素。 引理 4.4( 拟阵的最优⼦结构性质 ) 设 x 是求带权拟阵 M ＝ (S ， I) 的最优⼦集的贪⼼算法 gr e e d y 所选择的 S 中的第⼀个元素。那么，原问题可简 化为求带权拟阵 M ’=(S ’,I’) 的 最优⼦集 问题，其中： S ’={y| y \u0000 S 且 {x,y} \u0000 I} I’={B| B \u0000 S -{x} 且 B ∪ {x} \u0000 I} M ’ 的权函数是 M 的权函数在 S’ 上的限制 ( 称 M’ 为 M 关 0 4.8 贪⼼算法的理论基础 定理 4.5( 带权拟阵贪⼼算法的正确性 ) 设 M ＝ (S ,I) 是具有权函数 W 的带权拟阵，算法 gre e dy 返回 M 的最优⼦集。 3 、任务时间表问题 给定⼀个 单位时间任务 的有限集 S 。关于 S 的⼀个 时 间表 ⽤于描述 S 中单位时间任务的执⾏次序。时间表中 第 1 个任务从时间 0 开始执⾏直⾄时间 1 结束，第 2 个任 务从时间 1 开始执⾏⾄时间 2 结束， … ，第 n 个任务从时 间 n-1 开始执⾏直⾄时间 n 结束。   0 4.6 最⼩⽣成树 利⽤最⼩⽣成树性质和数 学归纳法容易证明，上述 算法中的 边集合 T 始终包 含 G 的某棵最⼩⽣成树中 的边 。因此，在算法结束 时， T 中的所有边构成 G 的 ⼀棵最⼩⽣成树。 例如 ，对于右图中的带权 图，按 Prim 算法 选取边的 过程如下⻚图所示。 0 4.6 最⼩⽣成树 0 4.6 最⼩⽣成树 在上述 P ri m 算法中，还应当考虑 如何有效地找出满⾜条 件 i \u0000\u0000 S ,j \u0000\u0000 V -S ，且权 c [i ][j] 最⼩的边 (i ,j) 。实现这个⽬的的 较简单的办法是设置 2 个数组 c l os e s t 和 l ow c os t 。 在 P ri m 算法执⾏过程中，先找出 V -S 中使 l ow c os t 值最⼩ 的顶点 j ，然后根据数组 c l os e s t 选取边 (j ,c l os e s t [j ］ ) ，最后 将 j 添加到 S 中，并对 c l os e s t 和 l ow c os t 作必要的修改。 ⽤这个办法实现的 P ri m 算法所需的 计算时间 为 0 4.6 最⼩⽣成树 3 、 Kruskal算法 K rus ka l 算法构造 G 的最⼩⽣成树的 基本思想 是，⾸ 先将 G 的 n 个顶点看成 n 个孤⽴的连通分⽀。将所有的边 按权从⼩到⼤排序。然后从第⼀条边开始，依边权递 增的顺序查看每⼀条边，并按下述⽅法连接 2 个不同的 连通分⽀：当查看到第 k 条边 (v ,w ) 时，如果端点 v 和 w 分别是当前 2 个不同的连通分⽀ T1 和 T2 中的顶点时，就 ⽤边 (v ,w ) 将 T1 和 T2 连接成⼀个连通分⽀，然后继续查 看第 k+1 条边；如果端点 v 和 w 在当前的同⼀个连通分⽀ 中，就直接再查看第 k+1 条边。这个过程⼀直进⾏到只 剩下⼀个连通分⽀时为⽌。 0 4.6 最⼩⽣成树 例如， 对前⾯的连通带权图，按 K rus ka l 算法顺序得到的最⼩ ⽣成树上的边如下图所示。 0 4.6 最⼩⽣成树 关于 集合的⼀些基本运算 可⽤于实现 K rus ka l 算法。 按权的递增顺序查看等价于对 优先队列 执 ⾏ r e move M i n 运算。可以⽤ 堆 实现这个优先队列。 对⼀个由连通分⽀组成的集合不断进⾏修改，需要⽤ 到抽象数据类型 并查集 U n i on F i n d 所⽀持的基本运算。 当图的边数为 e 时， K rus ka l 算法所需的 计算时间 是 。当 时， K rus ka l 算法⽐ P ri m 算法差，但当 时， K rus ka l 算法却⽐ P ri m 算法好得多。 0 4.7 多机调度问题 多机调度问题 要求给出⼀种作业调度⽅案，使所给的 n 个作业在尽可能短的时间内由 m 台机器加⼯处理完 成。 这个问题是 N P 完全问题 ，到⽬前为⽌还没有有效的 解法。对于这⼀类问题 , ⽤ 贪⼼选择策略 有时可以设计 出较好的近似算法。 约定，每个作业均可在任何⼀台机器上加⼯处理，但未完⼯ 前不允许中断处理。作业不能拆分成更⼩的⼦作业。 0 4.7 多机调度问题 采⽤ 最⻓处理时间作业优先 的贪⼼选择策略可以设计 出解多机调度问题的较好的近似算法。 按此策略，当 时，只要将机器 i 的 [0, ti ] 时间区间 分配给作业 i 即可，算法只需要 O (1) 时间。 当 时，⾸先将 n 个作业依其所需的处理时间从⼤ 到⼩排序。然后依此顺序将作业分配给空闲的处理 机。算法所需的计算时间为 O( n l ogn ) 。 0 4.7 多机调度问题 例如， 设 7 个独⽴作业 {1,2,3,4,5,6,7} 由 3 台机 器 M1 ， M2 和 M3 加⼯处理。各作业所需的处理时间 分别为 {2,14,4,16,6,5,3} 。按算法 gr e e d y 产⽣的作业调 度如下图所示，所需的加⼯时间为 17 。 0 4.8 贪⼼算法的理论基础 借助于 拟阵 ⼯具，可建⽴关于贪⼼算法的较⼀般的理 论。这个理论对 确定何时使⽤贪⼼算法 可以得到问题 的整体最优解⼗分有⽤。 1 、拟阵 拟阵 M 定义为满⾜下⾯ 3 个条件的有序对 (S ,I) ： (1)S 是⾮空有限集。 (2)I 是 S 的⼀类具有遗传性质的独⽴⼦集族，即若 B \u0000 I ， 则 B 是 S 的独⽴⼦集，且 B 的任意⼦集也都是 S 的独⽴⼦ 集。空集 \u0000 必为 I 的成员。 (3)I 满⾜交换性质，即若 A \u0000 I,B \u0000 I 且 | A | <| B| ，则存在某⼀ 元素 x \u0000 B-A ，使得 A ∪ {x} \u0000 I 。 0 4.8 贪⼼算法的理论基础 例如， 设 S 是⼀给定矩阵中⾏向量的集合， I 是 S 的线 性独⽴⼦集族，则由线性空间理论容易证明 (S ,I) 是⼀ 拟阵。拟阵的另⼀个例⼦是⽆向图 G =(V ,E ) 的图拟阵 。 给定拟阵 M =(S ,I) ，对于 I 中的独⽴⼦集 A \u0000 I ，若 S 有 ⼀元素 x \u0000 A ，使得将 x 加⼊ A 后仍保持独⽴性，即 A ∪ {x} \u0000 I, 则称 x 为 A 的 可扩展元素 。 当拟阵 M 中的独⽴⼦集 A 没有可扩展元素时，称 A 为 极⼤独⽴⼦集 。 0 4.8 贪⼼算法的理论基础 下⾯的关于 极⼤独⽴⼦集 的性质是很有⽤的。 定理 4.1 ： 拟阵 M 中所有极⼤独⽴⼦集⼤⼩相同。 这个定理可以⽤反证法证明。 若对拟阵 M =(S ,I) 中的 S 指定权函数 W ，使得对于任 意 x \u0000 S ，有 W (x)>0 ，则称拟阵 M 为 带权拟阵 。依此权 函数， S 的任⼀⼦集 A 的权定义为 。 2 、关于带权拟阵的贪⼼算法 许多可以⽤贪⼼算法求解的问题可以表示为求带权拟 阵的 最⼤权独⽴⼦集问题 。 0 4.8 贪⼼算法的理论基础 给定带权拟阵 M =(S ,I) ，确定 S 的独⽴⼦集 A \u0000 I 使得 W (A ) 达到最⼤。这种使 W (A ) 最⼤的独⽴⼦集 A 称为拟 阵 M 的 最优⼦集 。由于 S 中任⼀元素 x 的权 W (x) 是正 的，因此， 最优⼦集也⼀定是极⼤独⽴⼦集 。 例如， 在最⼩⽣成树问题可以表示为确定带权拟阵 的最优⼦集问题。求带权拟阵的最优⼦集 A 的算法可⽤ 于解最⼩⽣成树问题。 下⾯给出求 带权拟阵最优⼦集 的贪⼼算法。该算法以 具有正权函数 W 的带权拟阵 M =(S ,I) 作为输⼊，经计算 后输出 M 的最优⼦集 A 。 0 4.8 贪⼼算法的理论基础 • Set gr e e d y (M ,W ) • {A = \u0000 ; • 将 S 中元素依权值 W （⼤者优先）组成优先队列； • w hi l e (S != \u0000 ) { • S . re m ove M a x (x); • i f (A ∪ {x} \u0000 I) A =A ∪ {x}; • } • re t urn A • } 0 4.8 贪⼼算法的理论基础 算法 gr e e d y 的计算时间复杂性为 。 引理 4.2 ( 拟阵的贪⼼选择性质 ) 设 M =(S ,I) 是具有权函数 W 的带权拟阵，且 S 中元素依 权值从⼤到⼩排列。⼜设 x \u0000 S 是 S 中第⼀个使得 {x} 是 独⽴⼦集的元素，则存在 S 的最优⼦集 A 使得 x \u0000 A 。 算法 gr e e d y 在以贪⼼选择构造最优⼦集 A 时，⾸次选 ⼊集合 A 中的元素 x 是单元素独⽴集中具有最⼤权的元 素。此时可能已经舍弃了 S 中部分元素。可以证明这些 被舍弃的元素不可能⽤于构造最优⼦集。 0 4.8 贪⼼算法的理论基础 引理 4.3 ： 设 M =(S ,I) 是拟阵。若 S 中元素 x 不是空集 \u0000 的 可扩展元素，则 x 也不可能是 S 中任⼀独⽴⼦集 A 的可扩 展元素。 引理 4.4( 拟阵的最优⼦结构性质 ) 设 x 是求带权拟阵 M ＝ (S ， I) 的最优⼦集的贪⼼算法 gr e e d y 所选择的 S 中的第⼀个元素。那么，原问题可简 化为求带权拟阵 M ’=(S ’,I’) 的 最优⼦集 问题，其中： S ’={y| y \u0000 S 且 {x,y} \u0000 I} I’={B| B \u0000 S -{x} 且 B ∪ {x} \u0000 I} M ’ 的权函数是 M 的权函数在 S’ 上的限制 ( 称 M’ 为 M 关 0 4.8 贪⼼算法的理论基础 定理 4.5( 带权拟阵贪⼼算法的正确性 ) 设 M ＝ (S ,I) 是具有权函数 W 的带权拟阵，算法 gre e dy 返回 M 的最优⼦集。 3 、任务时间表问题 给定⼀个 单位时间任务 的有限集 S 。关于 S 的⼀个 时 间表 ⽤于描述 S 中单位时间任务的执⾏次序。时间表中 第 1 个任务从时间 0 开始执⾏直⾄时间 1 结束，第 2 个任 务从时间 1 开始执⾏⾄时间 2 结束， … ，第 n 个任务从时 间 n-1 开始执⾏直⾄时间 n 结束。   0 4.6 最⼩⽣成树 利⽤最⼩⽣成树性质和数 学归纳法容易证明，上述 算法中的 边集合 T 始终包 含 G 的某棵最⼩⽣成树中 的边 。因此，在算法结束 时， T 中的所有边构成 G 的 ⼀棵最⼩⽣成树。 例如 ，对于右图中的带权 图，按 Prim 算法 选取边的 过程如下⻚图所示。 0 4.6 最⼩⽣成树 0 4.6 最⼩⽣成树 在上述 P ri m 算法中，还应当考虑 如何有效地找出满⾜条 件 i \u0000\u0000 S ,j \u0000\u0000 V -S ，且权 c [i ][j] 最⼩的边 (i ,j) 。实现这个⽬的的 较简单的办法是设置 2 个数组 c l os e s t 和 l ow c os t 。 在 P ri m 算法执⾏过程中，先找出 V -S 中使 l ow c os t 值最⼩ 的顶点 j ，然后根据数组 c l os e s t 选取边 (j ,c l os e s t [j ］ ) ，最后 将 j 添加到 S 中，并对 c l os e s t 和 l ow c os t 作必要的修改。 ⽤这个办法实现的 P ri m 算法所需的 计算时间 为 0 4.6 最⼩⽣成树 3 、 Kruskal算法 K rus ka l 算法构造 G 的最⼩⽣成树的 基本思想 是，⾸ 先将 G 的 n 个顶点看成 n 个孤⽴的连通分⽀。将所有的边 按权从⼩到⼤排序。然后从第⼀条边开始，依边权递 增的顺序查看每⼀条边，并按下述⽅法连接 2 个不同的 连通分⽀：当查看到第 k 条边 (v ,w ) 时，如果端点 v 和 w 分别是当前 2 个不同的连通分⽀ T1 和 T2 中的顶点时，就 ⽤边 (v ,w ) 将 T1 和 T2 连接成⼀个连通分⽀，然后继续查 看第 k+1 条边；如果端点 v 和 w 在当前的同⼀个连通分⽀ 中，就直接再查看第 k+1 条边。这个过程⼀直进⾏到只 剩下⼀个连通分⽀时为⽌。 0 4.6 最⼩⽣成树 例如， 对前⾯的连通带权图，按 K rus ka l 算法顺序得到的最⼩ ⽣成树上的边如下图所示。 0 4.6 最⼩⽣成树 关于 集合的⼀些基本运算 可⽤于实现 K rus ka l 算法。 按权的递增顺序查看等价于对 优先队列 执 ⾏ r e move M i n 运算。可以⽤ 堆 实现这个优先队列。 对⼀个由连通分⽀组成的集合不断进⾏修改，需要⽤ 到抽象数据类型 并查集 U n i on F i n d 所⽀持的基本运算。 当图的边数为 e 时， K rus ka l 算法所需的 计算时间 是 。当 时， K rus ka l 算法⽐ P ri m 算法差，但当 时， K rus ka l 算法却⽐ P ri m 算法好得多。 0 4.7 多机调度问题 多机调度问题 要求给出⼀种作业调度⽅案，使所给的 n 个作业在尽可能短的时间内由 m 台机器加⼯处理完 成。 这个问题是 N P 完全问题 ，到⽬前为⽌还没有有效的 解法。对于这⼀类问题 , ⽤ 贪⼼选择策略 有时可以设计 出较好的近似算法。 约定，每个作业均可在任何⼀台机器上加⼯处理，但未完⼯ 前不允许中断处理。作业不能拆分成更⼩的⼦作业。 0 4.7 多机调度问题 采⽤ 最⻓处理时间作业优先 的贪⼼选择策略可以设计 出解多机调度问题的较好的近似算法。 按此策略，当 时，只要将机器 i 的 [0, ti ] 时间区间 分配给作业 i 即可，算法只需要 O (1) 时间。 当 时，⾸先将 n 个作业依其所需的处理时间从⼤ 到⼩排序。然后依此顺序将作业分配给空闲的处理 机。算法所需的计算时间为 O( n l ogn ) 。 0 4.7 多机调度问题 例如， 设 7 个独⽴作业 {1,2,3,4,5,6,7} 由 3 台机 器 M1 ， M2 和 M3 加⼯处理。各作业所需的处理时间 分别为 {2,14,4,16,6,5,3} 。按算法 gr e e d y 产⽣的作业调 度如下图所示，所需的加⼯时间为 17 。 0 4.8 贪⼼算法的理论基础 借助于 拟阵 ⼯具，可建⽴关于贪⼼算法的较⼀般的理 论。这个理论对 确定何时使⽤贪⼼算法 可以得到问题 的整体最优解⼗分有⽤。 1 、拟阵 拟阵 M 定义为满⾜下⾯ 3 个条件的有序对 (S ,I) ： (1)S 是⾮空有限集。 (2)I 是 S 的⼀类具有遗传性质的独⽴⼦集族，即若 B \u0000 I ， 则 B 是 S 的独⽴⼦集，且 B 的任意⼦集也都是 S 的独⽴⼦ 集。空集 \u0000 必为 I 的成员。 (3)I 满⾜交换性质，即若 A \u0000 I,B \u0000 I 且 | A | <| B| ，则存在某⼀ 元素 x \u0000 B-A ，使得 A ∪ {x} \u0000 I 。 0 4.8 贪⼼算法的理论基础 例如， 设 S 是⼀给定矩阵中⾏向量的集合， I 是 S 的线 性独⽴⼦集族，则由线性空间理论容易证明 (S ,I) 是⼀ 拟阵。拟阵的另⼀个例⼦是⽆向图 G =(V ,E ) 的图拟阵 。 给定拟阵 M =(S ,I) ，对于 I 中的独⽴⼦集 A \u0000 I ，若 S 有 ⼀元素 x \u0000 A ，使得将 x 加⼊ A 后仍保持独⽴性，即 A ∪ {x} \u0000 I, 则称 x 为 A 的 可扩展元素 。 当拟阵 M 中的独⽴⼦集 A 没有可扩展元素时，称 A 为 极⼤独⽴⼦集 。 0 4.8 贪⼼算法的理论基础 下⾯的关于 极⼤独⽴⼦集 的性质是很有⽤的。 定理 4.1 ： 拟阵 M 中所有极⼤独⽴⼦集⼤⼩相同。 这个定理可以⽤反证法证明。 若对拟阵 M =(S ,I) 中的 S 指定权函数 W ，使得对于任 意 x \u0000 S ，有 W (x)>0 ，则称拟阵 M 为 带权拟阵 。依此权 函数， S 的任⼀⼦集 A 的权定义为 。 2 、关于带权拟阵的贪⼼算法 许多可以⽤贪⼼算法求解的问题可以表示为求带权拟 阵的 最⼤权独⽴⼦集问题 。 0 4.8 贪⼼算法的理论基础 给定带权拟阵 M =(S ,I) ，确定 S 的独⽴⼦集 A \u0000 I 使得 W (A ) 达到最⼤。这种使 W (A ) 最⼤的独⽴⼦集 A 称为拟 阵 M 的 最优⼦集 。由于 S 中任⼀元素 x 的权 W (x) 是正 的，因此， 最优⼦集也⼀定是极⼤独⽴⼦集 。 例如， 在最⼩⽣成树问题可以表示为确定带权拟阵 的最优⼦集问题。求带权拟阵的最优⼦集 A 的算法可⽤ 于解最⼩⽣成树问题。 下⾯给出求 带权拟阵最优⼦集 的贪⼼算法。该算法以 具有正权函数 W 的带权拟阵 M =(S ,I) 作为输⼊，经计算 后输出 M 的最优⼦集 A 。 0 4.8 贪⼼算法的理论基础 • Set gr e e d y (M ,W ) • {A = \u0000 ; • 将 S 中元素依权值 W （⼤者优先）组成优先队列； • w hi l e (S != \u0000 ) { • S . re m ove M a x (x); • i f (A ∪ {x} \u0000 I) A =A ∪ {x}; • } • re t urn A • } 0 4.8 贪⼼算法的理论基础 算法 gr e e d y 的计算时间复杂性为 。 引理 4.2 ( 拟阵的贪⼼选择性质 ) 设 M =(S ,I) 是具有权函数 W 的带权拟阵，且 S 中元素依 权值从⼤到⼩排列。⼜设 x \u0000 S 是 S 中第⼀个使得 {x} 是 独⽴⼦集的元素，则存在 S 的最优⼦集 A 使得 x \u0000 A 。 算法 gr e e d y 在以贪⼼选择构造最优⼦集 A 时，⾸次选 ⼊集合 A 中的元素 x 是单元素独⽴集中具有最⼤权的元 素。此时可能已经舍弃了 S 中部分元素。可以证明这些 被舍弃的元素不可能⽤于构造最优⼦集。 0 4.8 贪⼼算法的理论基础 引理 4.3 ： 设 M =(S ,I) 是拟阵。若 S 中元素 x 不是空集 \u0000 的 可扩展元素，则 x 也不可能是 S 中任⼀独⽴⼦集 A 的可扩 展元素。 引理 4.4( 拟阵的最优⼦结构性质 ) 设 x 是求带权拟阵 M ＝ (S ， I) 的最优⼦集的贪⼼算法 gr e e d y 所选择的 S 中的第⼀个元素。那么，原问题可简 化为求带权拟阵 M ’=(S ’,I’) 的 最优⼦集 问题，其中： S ’={y| y \u0000 S 且 {x,y} \u0000 I} I’={B| B \u0000 S -{x} 且 B ∪ {x} \u0000 I} M ’ 的权函数是 M 的权函数在 S’ 上的限制 ( 称 M’ 为 M 关 0 4.8 贪⼼算法的理论基础 定理 4.5( 带权拟阵贪⼼算法的正确性 ) 设 M ＝ (S ,I) 是具有权函数 W 的带权拟阵，算法 gre e dy 返回 M 的最优⼦集。 3 、任务时间表问题 给定⼀个 单位时间任务 的有限集 S 。关于 S 的⼀个 时 间表 ⽤于描述 S 中单位时间任务的执⾏次序。时间表中 第 1 个任务从时间 0 开始执⾏直⾄时间 1 结束，第 2 个任 务从时间 1 开始执⾏⾄时间 2 结束， … ，第 n 个任务从时 间 n-1 开始执⾏直⾄时间 n 结束。   0 4.6 最⼩⽣成树 利⽤最⼩⽣成树性质和数 学归纳法容易证明，上述 算法中的 边集合 T 始终包 含 G 的某棵最⼩⽣成树中 的边 。因此，在算法结束 时， T 中的所有边构成 G 的 ⼀棵最⼩⽣成树。 例如 ，对于右图中的带权 图，按 Prim 算法 选取边的 过程如下⻚图所示。 0 4.6 最⼩⽣成树 0 4.6 最⼩⽣成树 在上述 P ri m 算法中，还应当考虑 如何有效地找出满⾜条 件 i \u0000\u0000 S ,j \u0000\u0000 V -S ，且权 c [i ][j] 最⼩的边 (i ,j) 。实现这个⽬的的 较简单的办法是设置 2 个数组 c l os e s t 和 l ow c os t 。 在 P ri m 算法执⾏过程中，先找出 V -S 中使 l ow c os t 值最⼩ 的顶点 j ，然后根据数组 c l os e s t 选取边 (j ,c l os e s t [j ］ ) ，最后 将 j 添加到 S 中，并对 c l os e s t 和 l ow c os t 作必要的修改。 ⽤这个办法实现的 P ri m 算法所需的 计算时间 为 0 4.6 最⼩⽣成树 3 、 Kruskal算法 K rus ka l 算法构造 G 的最⼩⽣成树的 基本思想 是，⾸ 先将 G 的 n 个顶点看成 n 个孤⽴的连通分⽀。将所有的边 按权从⼩到⼤排序。然后从第⼀条边开始，依边权递 增的顺序查看每⼀条边，并按下述⽅法连接 2 个不同的 连通分⽀：当查看到第 k 条边 (v ,w ) 时，如果端点 v 和 w 分别是当前 2 个不同的连通分⽀ T1 和 T2 中的顶点时，就 ⽤边 (v ,w ) 将 T1 和 T2 连接成⼀个连通分⽀，然后继续查 看第 k+1 条边；如果端点 v 和 w 在当前的同⼀个连通分⽀ 中，就直接再查看第 k+1 条边。这个过程⼀直进⾏到只 剩下⼀个连通分⽀时为⽌。 0 4.6 最⼩⽣成树 例如， 对前⾯的连通带权图，按 K rus ka l 算法顺序得到的最⼩ ⽣成树上的边如下图所示。 0 4.6 最⼩⽣成树 关于 集合的⼀些基本运算 可⽤于实现 K rus ka l 算法。 按权的递增顺序查看等价于对 优先队列 执 ⾏ r e move M i n 运算。可以⽤ 堆 实现这个优先队列。 对⼀个由连通分⽀组成的集合不断进⾏修改，需要⽤ 到抽象数据类型 并查集 U n i on F i n d 所⽀持的基本运算。 当图的边数为 e 时， K rus ka l 算法所需的 计算时间 是 。当 时， K rus ka l 算法⽐ P ri m 算法差，但当 时， K rus ka l 算法却⽐ P ri m 算法好得多。 0 4.7 多机调度问题 多机调度问题 要求给出⼀种作业调度⽅案，使所给的 n 个作业在尽可能短的时间内由 m 台机器加⼯处理完 成。 这个问题是 N P 完全问题 ，到⽬前为⽌还没有有效的 解法。对于这⼀类问题 , ⽤ 贪⼼选择策略 有时可以设计 出较好的近似算法。 约定，每个作业均可在任何⼀台机器上加⼯处理，但未完⼯ 前不允许中断处理。作业不能拆分成更⼩的⼦作业。 0 4.7 多机调度问题 采⽤ 最⻓处理时间作业优先 的贪⼼选择策略可以设计 出解多机调度问题的较好的近似算法。 按此策略，当 时，只要将机器 i 的 [0, ti ] 时间区间 分配给作业 i 即可，算法只需要 O (1) 时间。 当 时，⾸先将 n 个作业依其所需的处理时间从⼤ 到⼩排序。然后依此顺序将作业分配给空闲的处理 机。算法所需的计算时间为 O( n l ogn ) 。 0 4.7 多机调度问题 例如， 设 7 个独⽴作业 {1,2,3,4,5,6,7} 由 3 台机 器 M1 ， M2 和 M3 加⼯处理。各作业所需的处理时间 分别为 {2,14,4,16,6,5,3} 。按算法 gr e e d y 产⽣的作业调 度如下图所示，所需的加⼯时间为 17 。 0 4.8 贪⼼算法的理论基础 借助于 拟阵 ⼯具，可建⽴关于贪⼼算法的较⼀般的理 论。这个理论对 确定何时使⽤贪⼼算法 可以得到问题 的整体最优解⼗分有⽤。 1 、拟阵 拟阵 M 定义为满⾜下⾯ 3 个条件的有序对 (S ,I) ： (1)S 是⾮空有限集。 (2)I 是 S 的⼀类具有遗传性质的独⽴⼦集族，即若 B \u0000 I ， 则 B 是 S 的独⽴⼦集，且 B 的任意⼦集也都是 S 的独⽴⼦ 集。空集 \u0000 必为 I 的成员。 (3)I 满⾜交换性质，即若 A \u0000 I,B \u0000 I 且 | A | <| B| ，则存在某⼀ 元素 x \u0000 B-A ，使得 A ∪ {x} \u0000 I 。 0 4.8 贪⼼算法的理论基础 例如， 设 S 是⼀给定矩阵中⾏向量的集合， I 是 S 的线 性独⽴⼦集族，则由线性空间理论容易证明 (S ,I) 是⼀ 拟阵。拟阵的另⼀个例⼦是⽆向图 G =(V ,E ) 的图拟阵 。 给定拟阵 M =(S ,I) ，对于 I 中的独⽴⼦集 A \u0000 I ，若 S 有 ⼀元素 x \u0000 A ，使得将 x 加⼊ A 后仍保持独⽴性，即 A ∪ {x} \u0000 I, 则称 x 为 A 的 可扩展元素 。 当拟阵 M 中的独⽴⼦集 A 没有可扩展元素时，称 A 为 极⼤独⽴⼦集 。 0 4.8 贪⼼算法的理论基础 下⾯的关于 极⼤独⽴⼦集 的性质是很有⽤的。 定理 4.1 ： 拟阵 M 中所有极⼤独⽴⼦集⼤⼩相同。 这个定理可以⽤反证法证明。 若对拟阵 M =(S ,I) 中的 S 指定权函数 W ，使得对于任 意 x \u0000 S ，有 W (x)>0 ，则称拟阵 M 为 带权拟阵 。依此权 函数， S 的任⼀⼦集 A 的权定义为 。 2 、关于带权拟阵的贪⼼算法 许多可以⽤贪⼼算法求解的问题可以表示为求带权拟 阵的 最⼤权独⽴⼦集问题 。 0 4.8 贪⼼算法的理论基础 给定带权拟阵 M =(S ,I) ，确定 S 的独⽴⼦集 A \u0000 I 使得 W (A ) 达到最⼤。这种使 W (A ) 最⼤的独⽴⼦集 A 称为拟 阵 M 的 最优⼦集 。由于 S 中任⼀元素 x 的权 W (x) 是正 的，因此， 最优⼦集也⼀定是极⼤独⽴⼦集 。 例如， 在最⼩⽣成树问题可以表示为确定带权拟阵 的最优⼦集问题。求带权拟阵的最优⼦集 A 的算法可⽤ 于解最⼩⽣成树问题。 下⾯给出求 带权拟阵最优⼦集 的贪⼼算法。该算法以 具有正权函数 W 的带权拟阵 M =(S ,I) 作为输⼊，经计算 后输出 M 的最优⼦集 A 。 0 4.8 贪⼼算法的理论基础 • Set gr e e d y (M ,W ) • {A = \u0000 ; • 将 S 中元素依权值 W （⼤者优先）组成优先队列； • w hi l e (S != \u0000 ) { • S . re m ove M a x (x); • i f (A ∪ {x} \u0000 I) A =A ∪ {x}; • } • re t urn A • } 0 4.8 贪⼼算法的理论基础 算法 gr e e d y 的计算时间复杂性为 。 引理 4.2 ( 拟阵的贪⼼选择性质 ) 设 M =(S ,I) 是具有权函数 W 的带权拟阵，且 S 中元素依 权值从⼤到⼩排列。⼜设 x \u0000 S 是 S 中第⼀个使得 {x} 是 独⽴⼦集的元素，则存在 S 的最优⼦集 A 使得 x \u0000 A 。 算法 gr e e d y 在以贪⼼选择构造最优⼦集 A 时，⾸次选 ⼊集合 A 中的元素 x 是单元素独⽴集中具有最⼤权的元 素。此时可能已经舍弃了 S 中部分元素。可以证明这些 被舍弃的元素不可能⽤于构造最优⼦集。 0 4.8 贪⼼算法的理论基础 引理 4.3 ： 设 M =(S ,I) 是拟阵。若 S 中元素 x 不是空集 \u0000 的 可扩展元素，则 x 也不可能是 S 中任⼀独⽴⼦集 A 的可扩 展元素。 引理 4.4( 拟阵的最优⼦结构性质 ) 设 x 是求带权拟阵 M ＝ (S ， I) 的最优⼦集的贪⼼算法 gr e e d y 所选择的 S 中的第⼀个元素。那么，原问题可简 化为求带权拟阵 M ’=(S ’,I’) 的 最优⼦集 问题，其中： S ’={y| y \u0000 S 且 {x,y} \u0000 I} I’={B| B \u0000 S -{x} 且 B ∪ {x} \u0000 I} M ’ 的权函数是 M 的权函数在 S’ 上的限制 ( 称 M’ 为 M 关 0 4.8 贪⼼算法的理论基础 定理 4.5( 带权拟阵贪⼼算法的正确性 ) 设 M ＝ (S ,I) 是具有权函数 W 的带权拟阵，算法 gre e dy 返回 M 的最优⼦集。 3 、任务时间表问题 给定⼀个 单位时间任务 的有限集 S 。关于 S 的⼀个 时 间表 ⽤于描述 S 中单位时间任务的执⾏次序。时间表中 第 1 个任务从时间 0 开始执⾏直⾄时间 1 结束，第 2 个任 务从时间 1 开始执⾏⾄时间 2 结束， … ，第 n 个任务从时 间 n-1 开始执⾏直⾄时间 n 结束。   0 4.6 最⼩⽣成树 利⽤最⼩⽣成树性质和数 学归纳法容易证明，上述 算法中的 边集合 T 始终包 含 G 的某棵最⼩⽣成树中 的边 。因此，在算法结束 时， T 中的所有边构成 G 的 ⼀棵最⼩⽣成树。 例如 ，对于右图中的带权 图，按 Prim 算法 选取边的 过程如下⻚图所示。 0 4.6 最⼩⽣成树 0 4.6 最⼩⽣成树 在上述 P ri m 算法中，还应当考虑 如何有效地找出满⾜条 件 i \u0000\u0000 S ,j \u0000\u0000 V -S ，且权 c [i ][j] 最⼩的边 (i ,j) 。实现这个⽬的的 较简单的办法是设置 2 个数组 c l os e s t 和 l ow c os t 。 在 P ri m 算法执⾏过程中，先找出 V -S 中使 l ow c os t 值最⼩ 的顶点 j ，然后根据数组 c l os e s t 选取边 (j ,c l os e s t [j ］ ) ，最后 将 j 添加到 S 中，并对 c l os e s t 和 l ow c os t 作必要的修改。 ⽤这个办法实现的 P ri m 算法所需的 计算时间 为 0 4.6 最⼩⽣成树 3 、 Kruskal算法 K rus ka l 算法构造 G 的最⼩⽣成树的 基本思想 是，⾸ 先将 G 的 n 个顶点看成 n 个孤⽴的连通分⽀。将所有的边 按权从⼩到⼤排序。然后从第⼀条边开始，依边权递 增的顺序查看每⼀条边，并按下述⽅法连接 2 个不同的 连通分⽀：当查看到第 k 条边 (v ,w ) 时，如果端点 v 和 w 分别是当前 2 个不同的连通分⽀ T1 和 T2 中的顶点时，就 ⽤边 (v ,w ) 将 T1 和 T2 连接成⼀个连通分⽀，然后继续查 看第 k+1 条边；如果端点 v 和 w 在当前的同⼀个连通分⽀ 中，就直接再查看第 k+1 条边。这个过程⼀直进⾏到只 剩下⼀个连通分⽀时为⽌。 0 4.6 最⼩⽣成树 例如， 对前⾯的连通带权图，按 K rus ka l 算法顺序得到的最⼩ ⽣成树上的边如下图所示。 0 4.6 最⼩⽣成树 关于 集合的⼀些基本运算 可⽤于实现 K rus ka l 算法。 按权的递增顺序查看等价于对 优先队列 执 ⾏ r e move M i n 运算。可以⽤ 堆 实现这个优先队列。 对⼀个由连通分⽀组成的集合不断进⾏修改，需要⽤ 到抽象数据类型 并查集 U n i on F i n d 所⽀持的基本运算。 当图的边数为 e 时， K rus ka l 算法所需的 计算时间 是 。当 时， K rus ka l 算法⽐ P ri m 算法差，但当 时， K rus ka l 算法却⽐ P ri m 算法好得多。 0 4.7 多机调度问题 多机调度问题 要求给出⼀种作业调度⽅案，使所给的 n 个作业在尽可能短的时间内由 m 台机器加⼯处理完 成。 这个问题是 N P 完全问题 ，到⽬前为⽌还没有有效的 解法。对于这⼀类问题 , ⽤ 贪⼼选择策略 有时可以设计 出较好的近似算法。 约定，每个作业均可在任何⼀台机器上加⼯处理，但未完⼯ 前不允许中断处理。作业不能拆分成更⼩的⼦作业。 0 4.7 多机调度问题 采⽤ 最⻓处理时间作业优先 的贪⼼选择策略可以设计 出解多机调度问题的较好的近似算法。 按此策略，当 时，只要将机器 i 的 [0, ti ] 时间区间 分配给作业 i 即可，算法只需要 O (1) 时间。 当 时，⾸先将 n 个作业依其所需的处理时间从⼤ 到⼩排序。然后依此顺序将作业分配给空闲的处理 机。算法所需的计算时间为 O( n l ogn ) 。 0 4.7 多机调度问题 例如， 设 7 个独⽴作业 {1,2,3,4,5,6,7} 由 3 台机 器 M1 ， M2 和 M3 加⼯处理。各作业所需的处理时间 分别为 {2,14,4,16,6,5,3} 。按算法 gr e e d y 产⽣的作业调 度如下图所示，所需的加⼯时间为 17 。 0 4.8 贪⼼算法的理论基础 借助于 拟阵 ⼯具，可建⽴关于贪⼼算法的较⼀般的理 论。这个理论对 确定何时使⽤贪⼼算法 可以得到问题 的整体最优解⼗分有⽤。 1 、拟阵 拟阵 M 定义为满⾜下⾯ 3 个条件的有序对 (S ,I) ： (1)S 是⾮空有限集。 (2)I 是 S 的⼀类具有遗传性质的独⽴⼦集族，即若 B \u0000 I ， 则 B 是 S 的独⽴⼦集，且 B 的任意⼦集也都是 S 的独⽴⼦ 集。空集 \u0000 必为 I 的成员。 (3)I 满⾜交换性质，即若 A \u0000 I,B \u0000 I 且 | A | <| B| ，则存在某⼀ 元素 x \u0000 B-A ，使得 A ∪ {x} \u0000 I 。 0 4.8 贪⼼算法的理论基础 例如， 设 S 是⼀给定矩阵中⾏向量的集合， I 是 S 的线 性独⽴⼦集族，则由线性空间理论容易证明 (S ,I) 是⼀ 拟阵。拟阵的另⼀个例⼦是⽆向图 G =(V ,E ) 的图拟阵 。 给定拟阵 M =(S ,I) ，对于 I 中的独⽴⼦集 A \u0000 I ，若 S 有 ⼀元素 x \u0000 A ，使得将 x 加⼊ A 后仍保持独⽴性，即 A ∪ {x} \u0000 I, 则称 x 为 A 的 可扩展元素 。 当拟阵 M 中的独⽴⼦集 A 没有可扩展元素时，称 A 为 极⼤独⽴⼦集 。 0 4.8 贪⼼算法的理论基础 下⾯的关于 极⼤独⽴⼦集 的性质是很有⽤的。 定理 4.1 ： 拟阵 M 中所有极⼤独⽴⼦集⼤⼩相同。 这个定理可以⽤反证法证明。 若对拟阵 M =(S ,I) 中的 S 指定权函数 W ，使得对于任 意 x \u0000 S ，有 W (x)>0 ，则称拟阵 M 为 带权拟阵 。依此权 函数， S 的任⼀⼦集 A 的权定义为 。 2 、关于带权拟阵的贪⼼算法 许多可以⽤贪⼼算法求解的问题可以表示为求带权拟 阵的 最⼤权独⽴⼦集问题 。 0 4.8 贪⼼算法的理论基础 给定带权拟阵 M =(S ,I) ，确定 S 的独⽴⼦集 A \u0000 I 使得 W (A ) 达到最⼤。这种使 W (A ) 最⼤的独⽴⼦集 A 称为拟 阵 M 的 最优⼦集 。由于 S 中任⼀元素 x 的权 W (x) 是正 的，因此， 最优⼦集也⼀定是极⼤独⽴⼦集 。 例如， 在最⼩⽣成树问题可以表示为确定带权拟阵 的最优⼦集问题。求带权拟阵的最优⼦集 A 的算法可⽤ 于解最⼩⽣成树问题。 下⾯给出求 带权拟阵最优⼦集 的贪⼼算法。该算法以 具有正权函数 W 的带权拟阵 M =(S ,I) 作为输⼊，经计算 后输出 M 的最优⼦集 A 。 0 4.8 贪⼼算法的理论基础 • Set gr e e d y (M ,W ) • {A = \u0000 ; • 将 S 中元素依权值 W （⼤者优先）组成优先队列； • w hi l e (S != \u0000 ) { • S . re m ove M a x (x); • i f (A ∪ {x} \u0000 I) A =A ∪ {x}; • } • re t urn A • } 0 4.8 贪⼼算法的理论基础 算法 gr e e d y 的计算时间复杂性为 。 引理 4.2 ( 拟阵的贪⼼选择性质 ) 设 M =(S ,I) 是具有权函数 W 的带权拟阵，且 S 中元素依 权值从⼤到⼩排列。⼜设 x \u0000 S 是 S 中第⼀个使得 {x} 是 独⽴⼦集的元素，则存在 S 的最优⼦集 A 使得 x \u0000 A 。 算法 gr e e d y 在以贪⼼选择构造最优⼦集 A 时，⾸次选 ⼊集合 A 中的元素 x 是单元素独⽴集中具有最⼤权的元 素。此时可能已经舍弃了 S 中部分元素。可以证明这些 被舍弃的元素不可能⽤于构造最优⼦集。 0 4.8 贪⼼算法的理论基础 引理 4.3 ： 设 M =(S ,I) 是拟阵。若 S 中元素 x 不是空集 \u0000 的 可扩展元素，则 x 也不可能是 S 中任⼀独⽴⼦集 A 的可扩 展元素。 引理 4.4( 拟阵的最优⼦结构性质 ) 设 x 是求带权拟阵 M ＝ (S ， I) 的最优⼦集的贪⼼算法 gr e e d y 所选择的 S 中的第⼀个元素。那么，原问题可简 化为求带权拟阵 M ’=(S ’,I’) 的 最优⼦集 问题，其中： S ’={y| y \u0000 S 且 {x,y} \u0000 I} I’={B| B \u0000 S -{x} 且 B ∪ {x} \u0000 I} M ’ 的权函数是 M 的权函数在 S’ 上的限制 ( 称 M’ 为 M 关 0 4.8 贪⼼算法的理论基础 定理 4.5( 带权拟阵贪⼼算法的正确性 ) 设 M ＝ (S ,I) 是具有权函数 W 的带权拟阵，算法 gre e dy 返回 M 的最优⼦集。 3 、任务时间表问题 给定⼀个 单位时间任务 的有限集 S 。关于 S 的⼀个 时 间表 ⽤于描述 S 中单位时间任务的执⾏次序。时间表中 第 1 个任务从时间 0 开始执⾏直⾄时间 1 结束，第 2 个任 务从时间 1 开始执⾏⾄时间 2 结束， … ，第 n 个任务从时 间 n-1 开始执⾏直⾄时间 n 结束。   0 4.6 最⼩⽣成树 利⽤最⼩⽣成树性质和数 学归纳法容易证明，上述 算法中的 边集合 T 始终包 含 G 的某棵最⼩⽣成树中 的边 。因此，在算法结束 时， T 中的所有边构成 G 的 ⼀棵最⼩⽣成树。 例如 ，对于右图中的带权 图，按 Prim 算法 选取边的 过程如下⻚图所示。 0 4.6 最⼩⽣成树 0 4.6 最⼩⽣成树 在上述 P ri m 算法中，还应当考虑 如何有效地找出满⾜条 件 i \u0000\u0000 S ,j \u0000\u0000 V -S ，且权 c [i ][j] 最⼩的边 (i ,j) 。实现这个⽬的的 较简单的办法是设置 2 个数组 c l os e s t 和 l ow c os t 。 在 P ri m 算法执⾏过程中，先找出 V -S 中使 l ow c os t 值最⼩ 的顶点 j ，然后根据数组 c l os e s t 选取边 (j ,c l os e s t [j ］ ) ，最后 将 j 添加到 S 中，并对 c l os e s t 和 l ow c os t 作必要的修改。 ⽤这个办法实现的 P ri m 算法所需的 计算时间 为 0 4.6 最⼩⽣成树 3 、 Kruskal算法 K rus ka l 算法构造 G 的最⼩⽣成树的 基本思想 是，⾸ 先将 G 的 n 个顶点看成 n 个孤⽴的连通分⽀。将所有的边 按权从⼩到⼤排序。然后从第⼀条边开始，依边权递 增的顺序查看每⼀条边，并按下述⽅法连接 2 个不同的 连通分⽀：当查看到第 k 条边 (v ,w ) 时，如果端点 v 和 w 分别是当前 2 个不同的连通分⽀ T1 和 T2 中的顶点时，就 ⽤边 (v ,w ) 将 T1 和 T2 连接成⼀个连通分⽀，然后继续查 看第 k+1 条边；如果端点 v 和 w 在当前的同⼀个连通分⽀ 中，就直接再查看第 k+1 条边。这个过程⼀直进⾏到只 剩下⼀个连通分⽀时为⽌。 0 4.6 最⼩⽣成树 例如， 对前⾯的连通带权图，按 K rus ka l 算法顺序得到的最⼩ ⽣成树上的边如下图所示。 0 4.6 最⼩⽣成树 关于 集合的⼀些基本运算 可⽤于实现 K rus ka l 算法。 按权的递增顺序查看等价于对 优先队列 执 ⾏ r e move M i n 运算。可以⽤ 堆 实现这个优先队列。 对⼀个由连通分⽀组成的集合不断进⾏修改，需要⽤ 到抽象数据类型 并查集 U n i on F i n d 所⽀持的基本运算。 当图的边数为 e 时， K rus ka l 算法所需的 计算时间 是 。当 时， K rus ka l 算法⽐ P ri m 算法差，但当 时， K rus ka l 算法却⽐ P ri m 算法好得多。 0 4.7 多机调度问题 多机调度问题 要求给出⼀种作业调度⽅案，使所给的 n 个作业在尽可能短的时间内由 m 台机器加⼯处理完 成。 这个问题是 N P 完全问题 ，到⽬前为⽌还没有有效的 解法。对于这⼀类问题 , ⽤ 贪⼼选择策略 有时可以设计 出较好的近似算法。 约定，每个作业均可在任何⼀台机器上加⼯处理，但未完⼯ 前不允许中断处理。作业不能拆分成更⼩的⼦作业。 0 4.7 多机调度问题 采⽤ 最⻓处理时间作业优先 的贪⼼选择策略可以设计 出解多机调度问题的较好的近似算法。 按此策略，当 时，只要将机器 i 的 [0, ti ] 时间区间 分配给作业 i 即可，算法只需要 O (1) 时间。 当 时，⾸先将 n 个作业依其所需的处理时间从⼤ 到⼩排序。然后依此顺序将作业分配给空闲的处理 机。算法所需的计算时间为 O( n l ogn ) 。 0 4.7 多机调度问题 例如， 设 7 个独⽴作业 {1,2,3,4,5,6,7} 由 3 台机 器 M1 ， M2 和 M3 加⼯处理。各作业所需的处理时间 分别为 {2,14,4,16,6,5,3} 。按算法 gr e e d y 产⽣的作业调 度如下图所示，所需的加⼯时间为 17 。 0 4.8 贪⼼算法的理论基础 借助于 拟阵 ⼯具，可建⽴关于贪⼼算法的较⼀般的理 论。这个理论对 确定何时使⽤贪⼼算法 可以得到问题 的整体最优解⼗分有⽤。 1 、拟阵 拟阵 M 定义为满⾜下⾯ 3 个条件的有序对 (S ,I) ： (1)S 是⾮空有限集。 (2)I 是 S 的⼀类具有遗传性质的独⽴⼦集族，即若 B \u0000 I ， 则 B 是 S 的独⽴⼦集，且 B 的任意⼦集也都是 S 的独⽴⼦ 集。空集 \u0000 必为 I 的成员。 (3)I 满⾜交换性质，即若 A \u0000 I,B \u0000 I 且 | A | <| B| ，则存在某⼀ 元素 x \u0000 B-A ，使得 A ∪ {x} \u0000 I 。 0 4.8 贪⼼算法的理论基础 例如， 设 S 是⼀给定矩阵中⾏向量的集合， I 是 S 的线 性独⽴⼦集族，则由线性空间理论容易证明 (S ,I) 是⼀ 拟阵。拟阵的另⼀个例⼦是⽆向图 G =(V ,E ) 的图拟阵 。 给定拟阵 M =(S ,I) ，对于 I 中的独⽴⼦集 A \u0000 I ，若 S 有 ⼀元素 x \u0000 A ，使得将 x 加⼊ A 后仍保持独⽴性，即 A ∪ {x} \u0000 I, 则称 x 为 A 的 可扩展元素 。 当拟阵 M 中的独⽴⼦集 A 没有可扩展元素时，称 A 为 极⼤独⽴⼦集 。 0 4.8 贪⼼算法的理论基础 下⾯的关于 极⼤独⽴⼦集 的性质是很有⽤的。 定理 4.1 ： 拟阵 M 中所有极⼤独⽴⼦集⼤⼩相同。 这个定理可以⽤反证法证明。 若对拟阵 M =(S ,I) 中的 S 指定权函数 W ，使得对于任 意 x \u0000 S ，有 W (x)>0 ，则称拟阵 M 为 带权拟阵 。依此权 函数， S 的任⼀⼦集 A 的权定义为 。 2 、关于带权拟阵的贪⼼算法 许多可以⽤贪⼼算法求解的问题可以表示为求带权拟 阵的 最⼤权独⽴⼦集问题 。 0 4.8 贪⼼算法的理论基础 给定带权拟阵 M =(S ,I) ，确定 S 的独⽴⼦集 A \u0000 I 使得 W (A ) 达到最⼤。这种使 W (A ) 最⼤的独⽴⼦集 A 称为拟 阵 M 的 最优⼦集 。由于 S 中任⼀元素 x 的权 W (x) 是正 的，因此， 最优⼦集也⼀定是极⼤独⽴⼦集 。 例如， 在最⼩⽣成树问题可以表示为确定带权拟阵 的最优⼦集问题。求带权拟阵的最优⼦集 A 的算法可⽤ 于解最⼩⽣成树问题。 下⾯给出求 带权拟阵最优⼦集 的贪⼼算法。该算法以 具有正权函数 W 的带权拟阵 M =(S ,I) 作为输⼊，经计算 后输出 M 的最优⼦集 A 。 0 4.8 贪⼼算法的理论基础 • Set gr e e d y (M ,W ) • {A = \u0000 ; • 将 S 中元素依权值 W （⼤者优先）组成优先队列； • w hi l e (S != \u0000 ) { • S . re m ove M a x (x); • i f (A ∪ {x} \u0000 I) A =A ∪ {x}; • } • re t urn A • } 0 4.8 贪⼼算法的理论基础 算法 gr e e d y 的计算时间复杂性为 。 引理 4.2 ( 拟阵的贪⼼选择性质 ) 设 M =(S ,I) 是具有权函数 W 的带权拟阵，且 S 中元素依 权值从⼤到⼩排列。⼜设 x \u0000 S 是 S 中第⼀个使得 {x} 是 独⽴⼦集的元素，则存在 S 的最优⼦集 A 使得 x \u0000 A 。 算法 gr e e d y 在以贪⼼选择构造最优⼦集 A 时，⾸次选 ⼊集合 A 中的元素 x 是单元素独⽴集中具有最⼤权的元 素。此时可能已经舍弃了 S 中部分元素。可以证明这些 被舍弃的元素不可能⽤于构造最优⼦集。 0 4.8 贪⼼算法的理论基础 引理 4.3 ： 设 M =(S ,I) 是拟阵。若 S 中元素 x 不是空集 \u0000 的 可扩展元素，则 x 也不可能是 S 中任⼀独⽴⼦集 A 的可扩 展元素。 引理 4.4( 拟阵的最优⼦结构性质 ) 设 x 是求带权拟阵 M ＝ (S ， I) 的最优⼦集的贪⼼算法 gr e e d y 所选择的 S 中的第⼀个元素。那么，原问题可简 化为求带权拟阵 M ’=(S ’,I’) 的 最优⼦集 问题，其中： S ’={y| y \u0000 S 且 {x,y} \u0000 I} I’={B| B \u0000 S -{x} 且 B ∪ {x} \u0000 I} M ’ 的权函数是 M 的权函数在 S’ 上的限制 ( 称 M’ 为 M 关 0 4.8 贪⼼算法的理论基础 定理 4.5( 带权拟阵贪⼼算法的正确性 ) 设 M ＝ (S ,I) 是具有权函数 W 的带权拟阵，算法 gre e dy 返回 M 的最优⼦集。 3 、任务时间表问题 给定⼀个 单位时间任务 的有限集 S 。关于 S 的⼀个 时 间表 ⽤于描述 S 中单位时间任务的执⾏次序。时间表中 第 1 个任务从时间 0 开始执⾏直⾄时间 1 结束，第 2 个任 务从时间 1 开始执⾏⾄时间 2 结束， … ，第 n 个任务从时 间 n-1 开始执⾏直⾄时间 n 结束。   0 4.6 最⼩⽣成树 利⽤最⼩⽣成树性质和数 学归纳法容易证明，上述 算法中的 边集合 T 始终包 含 G 的某棵最⼩⽣成树中 的边 。因此，在算法结束 时， T 中的所有边构成 G 的 ⼀棵最⼩⽣成树。 例如 ，对于右图中的带权 图，按 Prim 算法 选取边的 过程如下⻚图所示。 0 4.6 最⼩⽣成树 0 4.6 最⼩⽣成树 在上述 P ri m 算法中，还应当考虑 如何有效地找出满⾜条 件 i \u0000\u0000 S ,j \u0000\u0000 V -S ，且权 c [i ][j] 最⼩的边 (i ,j) 。实现这个⽬的的 较简单的办法是设置 2 个数组 c l os e s t 和 l ow c os t 。 在 P ri m 算法执⾏过程中，先找出 V -S 中使 l ow c os t 值最⼩ 的顶点 j ，然后根据数组 c l os e s t 选取边 (j ,c l os e s t [j ］ ) ，最后 将 j 添加到 S 中，并对 c l os e s t 和 l ow c os t 作必要的修改。 ⽤这个办法实现的 P ri m 算法所需的 计算时间 为 0 4.6 最⼩⽣成树 3 、 Kruskal算法 K rus ka l 算法构造 G 的最⼩⽣成树的 基本思想 是，⾸ 先将 G 的 n 个顶点看成 n 个孤⽴的连通分⽀。将所有的边 按权从⼩到⼤排序。然后从第⼀条边开始，依边权递 增的顺序查看每⼀条边，并按下述⽅法连接 2 个不同的 连通分⽀：当查看到第 k 条边 (v ,w ) 时，如果端点 v 和 w 分别是当前 2 个不同的连通分⽀ T1 和 T2 中的顶点时，就 ⽤边 (v ,w ) 将 T1 和 T2 连接成⼀个连通分⽀，然后继续查 看第 k+1 条边；如果端点 v 和 w 在当前的同⼀个连通分⽀ 中，就直接再查看第 k+1 条边。这个过程⼀直进⾏到只 剩下⼀个连通分⽀时为⽌。 0 4.6 最⼩⽣成树 例如， 对前⾯的连通带权图，按 K rus ka l 算法顺序得到的最⼩ ⽣成树上的边如下图所示。 0 4.6 最⼩⽣成树 关于 集合的⼀些基本运算 可⽤于实现 K rus ka l 算法。 按权的递增顺序查看等价于对 优先队列 执 ⾏ r e move M i n 运算。可以⽤ 堆 实现这个优先队列。 对⼀个由连通分⽀组成的集合不断进⾏修改，需要⽤ 到抽象数据类型 并查集 U n i on F i n d 所⽀持的基本运算。 当图的边数为 e 时， K rus ka l 算法所需的 计算时间 是 。当 时， K rus ka l 算法⽐ P ri m 算法差，但当 时， K rus ka l 算法却⽐ P ri m 算法好得多。 0 4.7 多机调度问题 多机调度问题 要求给出⼀种作业调度⽅案，使所给的 n 个作业在尽可能短的时间内由 m 台机器加⼯处理完 成。 这个问题是 N P 完全问题 ，到⽬前为⽌还没有有效的 解法。对于这⼀类问题 , ⽤ 贪⼼选择策略 有时可以设计 出较好的近似算法。 约定，每个作业均可在任何⼀台机器上加⼯处理，但未完⼯ 前不允许中断处理。作业不能拆分成更⼩的⼦作业。 0 4.7 多机调度问题 采⽤ 最⻓处理时间作业优先 的贪⼼选择策略可以设计 出解多机调度问题的较好的近似算法。 按此策略，当 时，只要将机器 i 的 [0, ti ] 时间区间 分配给作业 i 即可，算法只需要 O (1) 时间。 当 时，⾸先将 n 个作业依其所需的处理时间从⼤ 到⼩排序。然后依此顺序将作业分配给空闲的处理 机。算法所需的计算时间为 O( n l ogn ) 。 0 4.7 多机调度问题 例如， 设 7 个独⽴作业 {1,2,3,4,5,6,7} 由 3 台机 器 M1 ， M2 和 M3 加⼯处理。各作业所需的处理时间 分别为 {2,14,4,16,6,5,3} 。按算法 gr e e d y 产⽣的作业调 度如下图所示，所需的加⼯时间为 17 。 0 4.8 贪⼼算法的理论基础 借助于 拟阵 ⼯具，可建⽴关于贪⼼算法的较⼀般的理 论。这个理论对 确定何时使⽤贪⼼算法 可以得到问题 的整体最优解⼗分有⽤。 1 、拟阵 拟阵 M 定义为满⾜下⾯ 3 个条件的有序对 (S ,I) ： (1)S 是⾮空有限集。 (2)I 是 S 的⼀类具有遗传性质的独⽴⼦集族，即若 B \u0000 I ， 则 B 是 S 的独⽴⼦集，且 B 的任意⼦集也都是 S 的独⽴⼦ 集。空集 \u0000 必为 I 的成员。 (3)I 满⾜交换性质，即若 A \u0000 I,B \u0000 I 且 | A | <| B| ，则存在某⼀ 元素 x \u0000 B-A ，使得 A ∪ {x} \u0000 I 。 0 4.8 贪⼼算法的理论基础 例如， 设 S 是⼀给定矩阵中⾏向量的集合， I 是 S 的线 性独⽴⼦集族，则由线性空间理论容易证明 (S ,I) 是⼀ 拟阵。拟阵的另⼀个例⼦是⽆向图 G =(V ,E ) 的图拟阵 。 给定拟阵 M =(S ,I) ，对于 I 中的独⽴⼦集 A \u0000 I ，若 S 有 ⼀元素 x \u0000 A ，使得将 x 加⼊ A 后仍保持独⽴性，即 A ∪ {x} \u0000 I, 则称 x 为 A 的 可扩展元素 。 当拟阵 M 中的独⽴⼦集 A 没有可扩展元素时，称 A 为 极⼤独⽴⼦集 。 0 4.8 贪⼼算法的理论基础 下⾯的关于 极⼤独⽴⼦集 的性质是很有⽤的。 定理 4.1 ： 拟阵 M 中所有极⼤独⽴⼦集⼤⼩相同。 这个定理可以⽤反证法证明。 若对拟阵 M =(S ,I) 中的 S 指定权函数 W ，使得对于任 意 x \u0000 S ，有 W (x)>0 ，则称拟阵 M 为 带权拟阵 。依此权 函数， S 的任⼀⼦集 A 的权定义为 。 2 、关于带权拟阵的贪⼼算法 许多可以⽤贪⼼算法求解的问题可以表示为求带权拟 阵的 最⼤权独⽴⼦集问题 。 0 4.8 贪⼼算法的理论基础 给定带权拟阵 M =(S ,I) ，确定 S 的独⽴⼦集 A \u0000 I 使得 W (A ) 达到最⼤。这种使 W (A ) 最⼤的独⽴⼦集 A 称为拟 阵 M 的 最优⼦集 。由于 S 中任⼀元素 x 的权 W (x) 是正 的，因此， 最优⼦集也⼀定是极⼤独⽴⼦集 。 例如， 在最⼩⽣成树问题可以表示为确定带权拟阵 的最优⼦集问题。求带权拟阵的最优⼦集 A 的算法可⽤ 于解最⼩⽣成树问题。 下⾯给出求 带权拟阵最优⼦集 的贪⼼算法。该算法以 具有正权函数 W 的带权拟阵 M =(S ,I) 作为输⼊，经计算 后输出 M 的最优⼦集 A 。 0 4.8 贪⼼算法的理论基础 • Set gr e e d y (M ,W ) • {A = \u0000 ; • 将 S 中元素依权值 W （⼤者优先）组成优先队列； • w hi l e (S != \u0000 ) { • S . re m ove M a x (x); • i f (A ∪ {x} \u0000 I) A =A ∪ {x}; • } • re t urn A • } 0 4.8 贪⼼算法的理论基础 算法 gr e e d y 的计算时间复杂性为 。 引理 4.2 ( 拟阵的贪⼼选择性质 ) 设 M =(S ,I) 是具有权函数 W 的带权拟阵，且 S 中元素依 权值从⼤到⼩排列。⼜设 x \u0000 S 是 S 中第⼀个使得 {x} 是 独⽴⼦集的元素，则存在 S 的最优⼦集 A 使得 x \u0000 A 。 算法 gr e e d y 在以贪⼼选择构造最优⼦集 A 时，⾸次选 ⼊集合 A 中的元素 x 是单元素独⽴集中具有最⼤权的元 素。此时可能已经舍弃了 S 中部分元素。可以证明这些 被舍弃的元素不可能⽤于构造最优⼦集。 0 4.8 贪⼼算法的理论基础 引理 4.3 ： 设 M =(S ,I) 是拟阵。若 S 中元素 x 不是空集 \u0000 的 可扩展元素，则 x 也不可能是 S 中任⼀独⽴⼦集 A 的可扩 展元素。 引理 4.4( 拟阵的最优⼦结构性质 ) 设 x 是求带权拟阵 M ＝ (S ， I) 的最优⼦集的贪⼼算法 gr e e d y 所选择的 S 中的第⼀个元素。那么，原问题可简 化为求带权拟阵 M ’=(S ’,I’) 的 最优⼦集 问题，其中： S ’={y| y \u0000 S 且 {x,y} \u0000 I} I’={B| B \u0000 S -{x} 且 B ∪ {x} \u0000 I} M ’ 的权函数是 M 的权函数在 S’ 上的限制 ( 称 M’ 为 M 关 0 4.8 贪⼼算法的理论基础 定理 4.5( 带权拟阵贪⼼算法的正确性 ) 设 M ＝ (S ,I) 是具有权函数 W 的带权拟阵，算法 gre e dy 返回 M 的最优⼦集。 3 、任务时间表问题 给定⼀个 单位时间任务 的有限集 S 。关于 S 的⼀个 时 间表 ⽤于描述 S 中单位时间任务的执⾏次序。时间表中 第 1 个任务从时间 0 开始执⾏直⾄时间 1 结束，第 2 个任 务从时间 1 开始执⾏⾄时间 2 结束， … ，第 n 个任务从时 间 n-1 开始执⾏直⾄时间 n 结束。   0 4.6 最⼩⽣成树 利⽤最⼩⽣成树性质和数 学归纳法容易证明，上述 算法中的 边集合 T 始终包 含 G 的某棵最⼩⽣成树中 的边 。因此，在算法结束 时， T 中的所有边构成 G 的 ⼀棵最⼩⽣成树。 例如 ，对于右图中的带权 图，按 Prim 算法 选取边的 过程如下⻚图所示。 0 4.6 最⼩⽣成树 0 4.6 最⼩⽣成树 在上述 P ri m 算法中，还应当考虑 如何有效地找出满⾜条 件 i \u0000\u0000 S ,j \u0000\u0000 V -S ，且权 c [i ][j] 最⼩的边 (i ,j) 。实现这个⽬的的 较简单的办法是设置 2 个数组 c l os e s t 和 l ow c os t 。 在 P ri m 算法执⾏过程中，先找出 V -S 中使 l ow c os t 值最⼩ 的顶点 j ，然后根据数组 c l os e s t 选取边 (j ,c l os e s t [j ］ ) ，最后 将 j 添加到 S 中，并对 c l os e s t 和 l ow c os t 作必要的修改。 ⽤这个办法实现的 P ri m 算法所需的 计算时间 为 0 4.6 最⼩⽣成树 3 、 Kruskal算法 K rus ka l 算法构造 G 的最⼩⽣成树的 基本思想 是，⾸ 先将 G 的 n 个顶点看成 n 个孤⽴的连通分⽀。将所有的边 按权从⼩到⼤排序。然后从第⼀条边开始，依边权递 增的顺序查看每⼀条边，并按下述⽅法连接 2 个不同的 连通分⽀：当查看到第 k 条边 (v ,w ) 时，如果端点 v 和 w 分别是当前 2 个不同的连通分⽀ T1 和 T2 中的顶点时，就 ⽤边 (v ,w ) 将 T1 和 T2 连接成⼀个连通分⽀，然后继续查 看第 k+1 条边；如果端点 v 和 w 在当前的同⼀个连通分⽀ 中，就直接再查看第 k+1 条边。这个过程⼀直进⾏到只 剩下⼀个连通分⽀时为⽌。 0 4.6 最⼩⽣成树 例如， 对前⾯的连通带权图，按 K rus ka l 算法顺序得到的最⼩ ⽣成树上的边如下图所示。 0 4.6 最⼩⽣成树 关于 集合的⼀些基本运算 可⽤于实现 K rus ka l 算法。 按权的递增顺序查看等价于对 优先队列 执 ⾏ r e move M i n 运算。可以⽤ 堆 实现这个优先队列。 对⼀个由连通分⽀组成的集合不断进⾏修改，需要⽤ 到抽象数据类型 并查集 U n i on F i n d 所⽀持的基本运算。 当图的边数为 e 时， K rus ka l 算法所需的 计算时间 是 。当 时， K rus ka l 算法⽐ P ri m 算法差，但当 时， K rus ka l 算法却⽐ P ri m 算法好得多。 0 4.7 多机调度问题 多机调度问题 要求给出⼀种作业调度⽅案，使所给的 n 个作业在尽可能短的时间内由 m 台机器加⼯处理完 成。 这个问题是 N P 完全问题 ，到⽬前为⽌还没有有效的 解法。对于这⼀类问题 , ⽤ 贪⼼选择策略 有时可以设计 出较好的近似算法。 约定，每个作业均可在任何⼀台机器上加⼯处理，但未完⼯ 前不允许中断处理。作业不能拆分成更⼩的⼦作业。 0 4.7 多机调度问题 采⽤ 最⻓处理时间作业优先 的贪⼼选择策略可以设计 出解多机调度问题的较好的近似算法。 按此策略，当 时，只要将机器 i 的 [0, ti ] 时间区间 分配给作业 i 即可，算法只需要 O (1) 时间。 当 时，⾸先将 n 个作业依其所需的处理时间从⼤ 到⼩排序。然后依此顺序将作业分配给空闲的处理 机。算法所需的计算时间为 O( n l ogn ) 。 0 4.7 多机调度问题 例如， 设 7 个独⽴作业 {1,2,3,4,5,6,7} 由 3 台机 器 M1 ， M2 和 M3 加⼯处理。各作业所需的处理时间 分别为 {2,14,4,16,6,5,3} 。按算法 gr e e d y 产⽣的作业调 度如下图所示，所需的加⼯时间为 17 。 0 4.8 贪⼼算法的理论基础 借助于 拟阵 ⼯具，可建⽴关于贪⼼算法的较⼀般的理 论。这个理论对 确定何时使⽤贪⼼算法 可以得到问题 的整体最优解⼗分有⽤。 1 、拟阵 拟阵 M 定义为满⾜下⾯ 3 个条件的有序对 (S ,I) ： (1)S 是⾮空有限集。 (2)I 是 S 的⼀类具有遗传性质的独⽴⼦集族，即若 B \u0000 I ， 则 B 是 S 的独⽴⼦集，且 B 的任意⼦集也都是 S 的独⽴⼦ 集。空集 \u0000 必为 I 的成员。 (3)I 满⾜交换性质，即若 A \u0000 I,B \u0000 I 且 | A | <| B| ，则存在某⼀ 元素 x \u0000 B-A ，使得 A ∪ {x} \u0000 I 。 0 4.8 贪⼼算法的理论基础 例如， 设 S 是⼀给定矩阵中⾏向量的集合， I 是 S 的线 性独⽴⼦集族，则由线性空间理论容易证明 (S ,I) 是⼀ 拟阵。拟阵的另⼀个例⼦是⽆向图 G =(V ,E ) 的图拟阵 。 给定拟阵 M =(S ,I) ，对于 I 中的独⽴⼦集 A \u0000 I ，若 S 有 ⼀元素 x \u0000 A ，使得将 x 加⼊ A 后仍保持独⽴性，即 A ∪ {x} \u0000 I, 则称 x 为 A 的 可扩展元素 。 当拟阵 M 中的独⽴⼦集 A 没有可扩展元素时，称 A 为 极⼤独⽴⼦集 。 0 4.8 贪⼼算法的理论基础 下⾯的关于 极⼤独⽴⼦集 的性质是很有⽤的。 定理 4.1 ： 拟阵 M 中所有极⼤独⽴⼦集⼤⼩相同。 这个定理可以⽤反证法证明。 若对拟阵 M =(S ,I) 中的 S 指定权函数 W ，使得对于任 意 x \u0000 S ，有 W (x)>0 ，则称拟阵 M 为 带权拟阵 。依此权 函数， S 的任⼀⼦集 A 的权定义为 。 2 、关于带权拟阵的贪⼼算法 许多可以⽤贪⼼算法求解的问题可以表示为求带权拟 阵的 最⼤权独⽴⼦集问题 。 0 4.8 贪⼼算法的理论基础 给定带权拟阵 M =(S ,I) ，确定 S 的独⽴⼦集 A \u0000 I 使得 W (A ) 达到最⼤。这种使 W (A ) 最⼤的独⽴⼦集 A 称为拟 阵 M 的 最优⼦集 。由于 S 中任⼀元素 x 的权 W (x) 是正 的，因此， 最优⼦集也⼀定是极⼤独⽴⼦集 。 例如， 在最⼩⽣成树问题可以表示为确定带权拟阵 的最优⼦集问题。求带权拟阵的最优⼦集 A 的算法可⽤ 于解最⼩⽣成树问题。 下⾯给出求 带权拟阵最优⼦集 的贪⼼算法。该算法以 具有正权函数 W 的带权拟阵 M =(S ,I) 作为输⼊，经计算 后输出 M 的最优⼦集 A 。 0 4.8 贪⼼算法的理论基础 • Set gr e e d y (M ,W ) • {A = \u0000 ; • 将 S 中元素依权值 W （⼤者优先）组成优先队列； • w hi l e (S != \u0000 ) { • S . re m ove M a x (x); • i f (A ∪ {x} \u0000 I) A =A ∪ {x}; • } • re t urn A • } 0 4.8 贪⼼算法的理论基础 算法 gr e e d y 的计算时间复杂性为 。 引理 4.2 ( 拟阵的贪⼼选择性质 ) 设 M =(S ,I) 是具有权函数 W 的带权拟阵，且 S 中元素依 权值从⼤到⼩排列。⼜设 x \u0000 S 是 S 中第⼀个使得 {x} 是 独⽴⼦集的元素，则存在 S 的最优⼦集 A 使得 x \u0000 A 。 算法 gr e e d y 在以贪⼼选择构造最优⼦集 A 时，⾸次选 ⼊集合 A 中的元素 x 是单元素独⽴集中具有最⼤权的元 素。此时可能已经舍弃了 S 中部分元素。可以证明这些 被舍弃的元素不可能⽤于构造最优⼦集。 0 4.8 贪⼼算法的理论基础 引理 4.3 ： 设 M =(S ,I) 是拟阵。若 S 中元素 x 不是空集 \u0000 的 可扩展元素，则 x 也不可能是 S 中任⼀独⽴⼦集 A 的可扩 展元素。 引理 4.4( 拟阵的最优⼦结构性质 ) 设 x 是求带权拟阵 M ＝ (S ， I) 的最优⼦集的贪⼼算法 gr e e d y 所选择的 S 中的第⼀个元素。那么，原问题可简 化为求带权拟阵 M ’=(S ’,I’) 的 最优⼦集 问题，其中： S ’={y| y \u0000 S 且 {x,y} \u0000 I} I’={B| B \u0000 S -{x} 且 B ∪ {x} \u0000 I} M ’ 的权函数是 M 的权函数在 S’ 上的限制 ( 称 M’ 为 M 关 0 4.8 贪⼼算法的理论基础 定理 4.5( 带权拟阵贪⼼算法的正确性 ) 设 M ＝ (S ,I) 是具有权函数 W 的带权拟阵，算法 gre e dy 返回 M 的最优⼦集。 3 、任务时间表问题 给定⼀个 单位时间任务 的有限集 S 。关于 S 的⼀个 时 间表 ⽤于描述 S 中单位时间任务的执⾏次序。时间表中 第 1 个任务从时间 0 开始执⾏直⾄时间 1 结束，第 2 个任 务从时间 1 开始执⾏⾄时间 2 结束， … ，第 n 个任务从时 间 n-1 开始执⾏直⾄时间 n 结束。   0 4.6 最⼩⽣成树 利⽤最⼩⽣成树性质和数 学归纳法容易证明，上述 算法中的 边集合 T 始终包 含 G 的某棵最⼩⽣成树中 的边 。因此，在算法结束 时， T 中的所有边构成 G 的 ⼀棵最⼩⽣成树。 例如 ，对于右图中的带权 图，按 Prim 算法 选取边的 过程如下⻚图所示。 0 4.6 最⼩⽣成树 0 4.6 最⼩⽣成树 在上述 P ri m 算法中，还应当考虑 如何有效地找出满⾜条 件 i \u0000\u0000 S ,j \u0000\u0000 V -S ，且权 c [i ][j] 最⼩的边 (i ,j) 。实现这个⽬的的 较简单的办法是设置 2 个数组 c l os e s t 和 l ow c os t 。 在 P ri m 算法执⾏过程中，先找出 V -S 中使 l ow c os t 值最⼩ 的顶点 j ，然后根据数组 c l os e s t 选取边 (j ,c l os e s t [j ］ ) ，最后 将 j 添加到 S 中，并对 c l os e s t 和 l ow c os t 作必要的修改。 ⽤这个办法实现的 P ri m 算法所需的 计算时间 为 0 4.6 最⼩⽣成树 3 、 Kruskal算法 K rus ka l 算法构造 G 的最⼩⽣成树的 基本思想 是，⾸ 先将 G 的 n 个顶点看成 n 个孤⽴的连通分⽀。将所有的边 按权从⼩到⼤排序。然后从第⼀条边开始，依边权递 增的顺序查看每⼀条边，并按下述⽅法连接 2 个不同的 连通分⽀：当查看到第 k 条边 (v ,w ) 时，如果端点 v 和 w 分别是当前 2 个不同的连通分⽀ T1 和 T2 中的顶点时，就 ⽤边 (v ,w ) 将 T1 和 T2 连接成⼀个连通分⽀，然后继续查 看第 k+1 条边；如果端点 v 和 w 在当前的同⼀个连通分⽀ 中，就直接再查看第 k+1 条边。这个过程⼀直进⾏到只 剩下⼀个连通分⽀时为⽌。 0 4.6 最⼩⽣成树 例如， 对前⾯的连通带权图，按 K rus ka l 算法顺序得到的最⼩ ⽣成树上的边如下图所示。 0 4.6 最⼩⽣成树 关于 集合的⼀些基本运算 可⽤于实现 K rus ka l 算法。 按权的递增顺序查看等价于对 优先队列 执 ⾏ r e move M i n 运算。可以⽤ 堆 实现这个优先队列。 对⼀个由连通分⽀组成的集合不断进⾏修改，需要⽤ 到抽象数据类型 并查集 U n i on F i n d 所⽀持的基本运算。 当图的边数为 e 时， K rus ka l 算法所需的 计算时间 是 。当 时， K rus ka l 算法⽐ P ri m 算法差，但当 时， K rus ka l 算法却⽐ P ri m 算法好得多。 0 4.7 多机调度问题 多机调度问题 要求给出⼀种作业调度⽅案，使所给的 n 个作业在尽可能短的时间内由 m 台机器加⼯处理完 成。 这个问题是 N P 完全问题 ，到⽬前为⽌还没有有效的 解法。对于这⼀类问题 , ⽤ 贪⼼选择策略 有时可以设计 出较好的近似算法。 约定，每个作业均可在任何⼀台机器上加⼯处理，但未完⼯ 前不允许中断处理。作业不能拆分成更⼩的⼦作业。 0 4.7 多机调度问题 采⽤ 最⻓处理时间作业优先 的贪⼼选择策略可以设计 出解多机调度问题的较好的近似算法。 按此策略，当 时，只要将机器 i 的 [0, ti ] 时间区间 分配给作业 i 即可，算法只需要 O (1) 时间。 当 时，⾸先将 n 个作业依其所需的处理时间从⼤ 到⼩排序。然后依此顺序将作业分配给空闲的处理 机。算法所需的计算时间为 O( n l ogn ) 。 0 4.7 多机调度问题 例如， 设 7 个独⽴作业 {1,2,3,4,5,6,7} 由 3 台机 器 M1 ， M2 和 M3 加⼯处理。各作业所需的处理时间 分别为 {2,14,4,16,6,5,3} 。按算法 gr e e d y 产⽣的作业调 度如下图所示，所需的加⼯时间为 17 。 0 4.8 贪⼼算法的理论基础 借助于 拟阵 ⼯具，可建⽴关于贪⼼算法的较⼀般的理 论。这个理论对 确定何时使⽤贪⼼算法 可以得到问题 的整体最优解⼗分有⽤。 1 、拟阵 拟阵 M 定义为满⾜下⾯ 3 个条件的有序对 (S ,I) ： (1)S 是⾮空有限集。 (2)I 是 S 的⼀类具有遗传性质的独⽴⼦集族，即若 B \u0000 I ， 则 B 是 S 的独⽴⼦集，且 B 的任意⼦集也都是 S 的独⽴⼦ 集。空集 \u0000 必为 I 的成员。 (3)I 满⾜交换性质，即若 A \u0000 I,B \u0000 I 且 | A | <| B| ，则存在某⼀ 元素 x \u0000 B-A ，使得 A ∪ {x} \u0000 I 。 0 4.8 贪⼼算法的理论基础 例如， 设 S 是⼀给定矩阵中⾏向量的集合， I 是 S 的线 性独⽴⼦集族，则由线性空间理论容易证明 (S ,I) 是⼀ 拟阵。拟阵的另⼀个例⼦是⽆向图 G =(V ,E ) 的图拟阵 。 给定拟阵 M =(S ,I) ，对于 I 中的独⽴⼦集 A \u0000 I ，若 S 有 ⼀元素 x \u0000 A ，使得将 x 加⼊ A 后仍保持独⽴性，即 A ∪ {x} \u0000 I, 则称 x 为 A 的 可扩展元素 。 当拟阵 M 中的独⽴⼦集 A 没有可扩展元素时，称 A 为 极⼤独⽴⼦集 。 0 4.8 贪⼼算法的理论基础 下⾯的关于 极⼤独⽴⼦集 的性质是很有⽤的。 定理 4.1 ： 拟阵 M 中所有极⼤独⽴⼦集⼤⼩相同。 这个定理可以⽤反证法证明。 若对拟阵 M =(S ,I) 中的 S 指定权函数 W ，使得对于任 意 x \u0000 S ，有 W (x)>0 ，则称拟阵 M 为 带权拟阵 。依此权 函数， S 的任⼀⼦集 A 的权定义为 。 2 、关于带权拟阵的贪⼼算法 许多可以⽤贪⼼算法求解的问题可以表示为求带权拟 阵的 最⼤权独⽴⼦集问题 。 0 4.8 贪⼼算法的理论基础 给定带权拟阵 M =(S ,I) ，确定 S 的独⽴⼦集 A \u0000 I 使得 W (A ) 达到最⼤。这种使 W (A ) 最⼤的独⽴⼦集 A 称为拟 阵 M 的 最优⼦集 。由于 S 中任⼀元素 x 的权 W (x) 是正 的，因此， 最优⼦集也⼀定是极⼤独⽴⼦集 。 例如， 在最⼩⽣成树问题可以表示为确定带权拟阵 的最优⼦集问题。求带权拟阵的最优⼦集 A 的算法可⽤ 于解最⼩⽣成树问题。 下⾯给出求 带权拟阵最优⼦集 的贪⼼算法。该算法以 具有正权函数 W 的带权拟阵 M =(S ,I) 作为输⼊，经计算 后输出 M 的最优⼦集 A 。 0 4.8 贪⼼算法的理论基础 • Set gr e e d y (M ,W ) • {A = \u0000 ; • 将 S 中元素依权值 W （⼤者优先）组成优先队列； • w hi l e (S != \u0000 ) { • S . re m ove M a x (x); • i f (A ∪ {x} \u0000 I) A =A ∪ {x}; • } • re t urn A • } 0 4.8 贪⼼算法的理论基础 算法 gr e e d y 的计算时间复杂性为 。 引理 4.2 ( 拟阵的贪⼼选择性质 ) 设 M =(S ,I) 是具有权函数 W 的带权拟阵，且 S 中元素依 权值从⼤到⼩排列。⼜设 x \u0000 S 是 S 中第⼀个使得 {x} 是 独⽴⼦集的元素，则存在 S 的最优⼦集 A 使得 x \u0000 A 。 算法 gr e e d y 在以贪⼼选择构造最优⼦集 A 时，⾸次选 ⼊集合 A 中的元素 x 是单元素独⽴集中具有最⼤权的元 素。此时可能已经舍弃了 S 中部分元素。可以证明这些 被舍弃的元素不可能⽤于构造最优⼦集。 0 4.8 贪⼼算法的理论基础 引理 4.3 ： 设 M =(S ,I) 是拟阵。若 S 中元素 x 不是空集 \u0000 的 可扩展元素，则 x 也不可能是 S 中任⼀独⽴⼦集 A 的可扩 展元素。 引理 4.4( 拟阵的最优⼦结构性质 ) 设 x 是求带权拟阵 M ＝ (S ， I) 的最优⼦集的贪⼼算法 gr e e d y 所选择的 S 中的第⼀个元素。那么，原问题可简 化为求带权拟阵 M ’=(S ’,I’) 的 最优⼦集 问题，其中： S ’={y| y \u0000 S 且 {x,y} \u0000 I} I’={B| B \u0000 S -{x} 且 B ∪ {x} \u0000 I} M ’ 的权函数是 M 的权函数在 S’ 上的限制 ( 称 M’ 为 M 关 0 4.8 贪⼼算法的理论基础 定理 4.5( 带权拟阵贪⼼算法的正确性 ) 设 M ＝ (S ,I) 是具有权函数 W 的带权拟阵，算法 gre e dy 返回 M 的最优⼦集。 3 、任务时间表问题 给定⼀个 单位时间任务 的有限集 S 。关于 S 的⼀个 时 间表 ⽤于描述 S 中单位时间任务的执⾏次序。时间表中 第 1 个任务从时间 0 开始执⾏直⾄时间 1 结束，第 2 个任 务从时间 1 开始执⾏⾄时间 2 结束， … ，第 n 个任务从时 间 n-1 开始执⾏直⾄时间 n 结束。   0 4.6 最⼩⽣成树 利⽤最⼩⽣成树性质和数 学归纳法容易证明，上述 算法中的 边集合 T 始终包 含 G 的某棵最⼩⽣成树中 的边 。因此，在算法结束 时， T 中的所有边构成 G 的 ⼀棵最⼩⽣成树。 例如 ，对于右图中的带权 图，按 Prim 算法 选取边的 过程如下⻚图所示。 0 4.6 最⼩⽣成树 0 4.6 最⼩⽣成树 在上述 P ri m 算法中，还应当考虑 如何有效地找出满⾜条 件 i \u0000\u0000 S ,j \u0000\u0000 V -S ，且权 c [i ][j] 最⼩的边 (i ,j) 。实现这个⽬的的 较简单的办法是设置 2 个数组 c l os e s t 和 l ow c os t 。 在 P ri m 算法执⾏过程中，先找出 V -S 中使 l ow c os t 值最⼩ 的顶点 j ，然后根据数组 c l os e s t 选取边 (j ,c l os e s t [j ］ ) ，最后 将 j 添加到 S 中，并对 c l os e s t 和 l ow c os t 作必要的修改。 ⽤这个办法实现的 P ri m 算法所需的 计算时间 为 0 4.6 最⼩⽣成树 3 、 Kruskal算法 K rus ka l 算法构造 G 的最⼩⽣成树的 基本思想 是，⾸ 先将 G 的 n 个顶点看成 n 个孤⽴的连通分⽀。将所有的边 按权从⼩到⼤排序。然后从第⼀条边开始，依边权递 增的顺序查看每⼀条边，并按下述⽅法连接 2 个不同的 连通分⽀：当查看到第 k 条边 (v ,w ) 时，如果端点 v 和 w 分别是当前 2 个不同的连通分⽀ T1 和 T2 中的顶点时，就 ⽤边 (v ,w ) 将 T1 和 T2 连接成⼀个连通分⽀，然后继续查 看第 k+1 条边；如果端点 v 和 w 在当前的同⼀个连通分⽀ 中，就直接再查看第 k+1 条边。这个过程⼀直进⾏到只 剩下⼀个连通分⽀时为⽌。 0 4.6 最⼩⽣成树 例如， 对前⾯的连通带权图，按 K rus ka l 算法顺序得到的最⼩ ⽣成树上的边如下图所示。 0 4.6 最⼩⽣成树 关于 集合的⼀些基本运算 可⽤于实现 K rus ka l 算法。 按权的递增顺序查看等价于对 优先队列 执 ⾏ r e move M i n 运算。可以⽤ 堆 实现这个优先队列。 对⼀个由连通分⽀组成的集合不断进⾏修改，需要⽤ 到抽象数据类型 并查集 U n i on F i n d 所⽀持的基本运算。 当图的边数为 e 时， K rus ka l 算法所需的 计算时间 是 。当 时， K rus ka l 算法⽐ P ri m 算法差，但当 时， K rus ka l 算法却⽐ P ri m 算法好得多。 0 4.7 多机调度问题 多机调度问题 要求给出⼀种作业调度⽅案，使所给的 n 个作业在尽可能短的时间内由 m 台机器加⼯处理完 成。 这个问题是 N P 完全问题 ，到⽬前为⽌还没有有效的 解法。对于这⼀类问题 , ⽤ 贪⼼选择策略 有时可以设计 出较好的近似算法。 约定，每个作业均可在任何⼀台机器上加⼯处理，但未完⼯ 前不允许中断处理。作业不能拆分成更⼩的⼦作业。 0 4.7 多机调度问题 采⽤ 最⻓处理时间作业优先 的贪⼼选择策略可以设计 出解多机调度问题的较好的近似算法。 按此策略，当 时，只要将机器 i 的 [0, ti ] 时间区间 分配给作业 i 即可，算法只需要 O (1) 时间。 当 时，⾸先将 n 个作业依其所需的处理时间从⼤ 到⼩排序。然后依此顺序将作业分配给空闲的处理 机。算法所需的计算时间为 O( n l ogn ) 。 0 4.7 多机调度问题 例如， 设 7 个独⽴作业 {1,2,3,4,5,6,7} 由 3 台机 器 M1 ， M2 和 M3 加⼯处理。各作业所需的处理时间 分别为 {2,14,4,16,6,5,3} 。按算法 gr e e d y 产⽣的作业调 度如下图所示，所需的加⼯时间为 17 。 0 4.8 贪⼼算法的理论基础 借助于 拟阵 ⼯具，可建⽴关于贪⼼算法的较⼀般的理 论。这个理论对 确定何时使⽤贪⼼算法 可以得到问题 的整体最优解⼗分有⽤。 1 、拟阵 拟阵 M 定义为满⾜下⾯ 3 个条件的有序对 (S ,I) ： (1)S 是⾮空有限集。 (2)I 是 S 的⼀类具有遗传性质的独⽴⼦集族，即若 B \u0000 I ， 则 B 是 S 的独⽴⼦集，且 B 的任意⼦集也都是 S 的独⽴⼦ 集。空集 \u0000 必为 I 的成员。 (3)I 满⾜交换性质，即若 A \u0000 I,B \u0000 I 且 | A | <| B| ，则存在某⼀ 元素 x \u0000 B-A ，使得 A ∪ {x} \u0000 I 。 0 4.8 贪⼼算法的理论基础 例如， 设 S 是⼀给定矩阵中⾏向量的集合， I 是 S 的线 性独⽴⼦集族，则由线性空间理论容易证明 (S ,I) 是⼀ 拟阵。拟阵的另⼀个例⼦是⽆向图 G =(V ,E ) 的图拟阵 。 给定拟阵 M =(S ,I) ，对于 I 中的独⽴⼦集 A \u0000 I ，若 S 有 ⼀元素 x \u0000 A ，使得将 x 加⼊ A 后仍保持独⽴性，即 A ∪ {x} \u0000 I, 则称 x 为 A 的 可扩展元素 。 当拟阵 M 中的独⽴⼦集 A 没有可扩展元素时，称 A 为 极⼤独⽴⼦集 。 0 4.8 贪⼼算法的理论基础 下⾯的关于 极⼤独⽴⼦集 的性质是很有⽤的。 定理 4.1 ： 拟阵 M 中所有极⼤独⽴⼦集⼤⼩相同。 这个定理可以⽤反证法证明。 若对拟阵 M =(S ,I) 中的 S 指定权函数 W ，使得对于任 意 x \u0000 S ，有 W (x)>0 ，则称拟阵 M 为 带权拟阵 。依此权 函数， S 的任⼀⼦集 A 的权定义为 。 2 、关于带权拟阵的贪⼼算法 许多可以⽤贪⼼算法求解的问题可以表示为求带权拟 阵的 最⼤权独⽴⼦集问题 。 0 4.8 贪⼼算法的理论基础 给定带权拟阵 M =(S ,I) ，确定 S 的独⽴⼦集 A \u0000 I 使得 W (A ) 达到最⼤。这种使 W (A ) 最⼤的独⽴⼦集 A 称为拟 阵 M 的 最优⼦集 。由于 S 中任⼀元素 x 的权 W (x) 是正 的，因此， 最优⼦集也⼀定是极⼤独⽴⼦集 。 例如， 在最⼩⽣成树问题可以表示为确定带权拟阵 的最优⼦集问题。求带权拟阵的最优⼦集 A 的算法可⽤ 于解最⼩⽣成树问题。 下⾯给出求 带权拟阵最优⼦集 的贪⼼算法。该算法以 具有正权函数 W 的带权拟阵 M =(S ,I) 作为输⼊，经计算 后输出 M 的最优⼦集 A 。 0 4.8 贪⼼算法的理论基础 • Set gr e e d y (M ,W ) • {A = \u0000 ; • 将 S 中元素依权值 W （⼤者优先）组成优先队列； • w hi l e (S != \u0000 ) { • S . re m ove M a x (x); • i f (A ∪ {x} \u0000 I) A =A ∪ {x}; • } • re t urn A • } 0 4.8 贪⼼算法的理论基础 算法 gr e e d y 的计算时间复杂性为 。 引理 4.2 ( 拟阵的贪⼼选择性质 ) 设 M =(S ,I) 是具有权函数 W 的带权拟阵，且 S 中元素依 权值从⼤到⼩排列。⼜设 x \u0000 S 是 S 中第⼀个使得 {x} 是 独⽴⼦集的元素，则存在 S 的最优⼦集 A 使得 x \u0000 A 。 算法 gr e e d y 在以贪⼼选择构造最优⼦集 A 时，⾸次选 ⼊集合 A 中的元素 x 是单元素独⽴集中具有最⼤权的元 素。此时可能已经舍弃了 S 中部分元素。可以证明这些 被舍弃的元素不可能⽤于构造最优⼦集。 0 4.8 贪⼼算法的理论基础 引理 4.3 ： 设 M =(S ,I) 是拟阵。若 S 中元素 x 不是空集 \u0000 的 可扩展元素，则 x 也不可能是 S 中任⼀独⽴⼦集 A 的可扩 展元素。 引理 4.4( 拟阵的最优⼦结构性质 ) 设 x 是求带权拟阵 M ＝ (S ， I) 的最优⼦集的贪⼼算法 gr e e d y 所选择的 S 中的第⼀个元素。那么，原问题可简 化为求带权拟阵 M ’=(S ’,I’) 的 最优⼦集 问题，其中： S ’={y| y \u0000 S 且 {x,y} \u0000 I} I’={B| B \u0000 S -{x} 且 B ∪ {x} \u0000 I} M ’ 的权函数是 M 的权函数在 S’ 上的限制 ( 称 M’ 为 M 关 0 4.8 贪⼼算法的理论基础 定理 4.5( 带权拟阵贪⼼算法的正确性 ) 设 M ＝ (S ,I) 是具有权函数 W 的带权拟阵，算法 gre e dy 返回 M 的最优⼦集。 3 、任务时间表问题 给定⼀个 单位时间任务 的有限集 S 。关于 S 的⼀个 时 间表 ⽤于描述 S 中单位时间任务的执⾏次序。时间表中 第 1 个任务从时间 0 开始执⾏直⾄时间 1 结束，第 2 个任 务从时间 1 开始执⾏⾄时间 2 结束， … ，第 n 个任务从时 间 n-1 开始执⾏直⾄时间 n 结束。   0 4.6 最⼩⽣成树 利⽤最⼩⽣成树性质和数 学归纳法容易证明，上述 算法中的 边集合 T 始终包 含 G 的某棵最⼩⽣成树中 的边 。因此，在算法结束 时， T 中的所有边构成 G 的 ⼀棵最⼩⽣成树。 例如 ，对于右图中的带权 图，按 Prim 算法 选取边的 过程如下⻚图所示。 0 4.6 最⼩⽣成树 0 4.6 最⼩⽣成树 在上述 P ri m 算法中，还应当考虑 如何有效地找出满⾜条 件 i \u0000\u0000 S ,j \u0000\u0000 V -S ，且权 c [i ][j] 最⼩的边 (i ,j) 。实现这个⽬的的 较简单的办法是设置 2 个数组 c l os e s t 和 l ow c os t 。 在 P ri m 算法执⾏过程中，先找出 V -S 中使 l ow c os t 值最⼩ 的顶点 j ，然后根据数组 c l os e s t 选取边 (j ,c l os e s t [j ］ ) ，最后 将 j 添加到 S 中，并对 c l os e s t 和 l ow c os t 作必要的修改。 ⽤这个办法实现的 P ri m 算法所需的 计算时间 为 0 4.6 最⼩⽣成树 3 、 Kruskal算法 K rus ka l 算法构造 G 的最⼩⽣成树的 基本思想 是，⾸ 先将 G 的 n 个顶点看成 n 个孤⽴的连通分⽀。将所有的边 按权从⼩到⼤排序。然后从第⼀条边开始，依边权递 增的顺序查看每⼀条边，并按下述⽅法连接 2 个不同的 连通分⽀：当查看到第 k 条边 (v ,w ) 时，如果端点 v 和 w 分别是当前 2 个不同的连通分⽀ T1 和 T2 中的顶点时，就 ⽤边 (v ,w ) 将 T1 和 T2 连接成⼀个连通分⽀，然后继续查 看第 k+1 条边；如果端点 v 和 w 在当前的同⼀个连通分⽀ 中，就直接再查看第 k+1 条边。这个过程⼀直进⾏到只 剩下⼀个连通分⽀时为⽌。 0 4.6 最⼩⽣成树 例如， 对前⾯的连通带权图，按 K rus ka l 算法顺序得到的最⼩ ⽣成树上的边如下图所示。 0 4.6 最⼩⽣成树 关于 集合的⼀些基本运算 可⽤于实现 K rus ka l 算法。 按权的递增顺序查看等价于对 优先队列 执 ⾏ r e move M i n 运算。可以⽤ 堆 实现这个优先队列。 对⼀个由连通分⽀组成的集合不断进⾏修改，需要⽤ 到抽象数据类型 并查集 U n i on F i n d 所⽀持的基本运算。 当图的边数为 e 时， K rus ka l 算法所需的 计算时间 是 。当 时， K rus ka l 算法⽐ P ri m 算法差，但当 时， K rus ka l 算法却⽐ P ri m 算法好得多。 0 4.7 多机调度问题 多机调度问题 要求给出⼀种作业调度⽅案，使所给的 n 个作业在尽可能短的时间内由 m 台机器加⼯处理完 成。 这个问题是 N P 完全问题 ，到⽬前为⽌还没有有效的 解法。对于这⼀类问题 , ⽤ 贪⼼选择策略 有时可以设计 出较好的近似算法。 约定，每个作业均可在任何⼀台机器上加⼯处理，但未完⼯ 前不允许中断处理。作业不能拆分成更⼩的⼦作业。 0 4.7 多机调度问题 采⽤ 最⻓处理时间作业优先 的贪⼼选择策略可以设计 出解多机调度问题的较好的近似算法。 按此策略，当 时，只要将机器 i 的 [0, ti ] 时间区间 分配给作业 i 即可，算法只需要 O (1) 时间。 当 时，⾸先将 n 个作业依其所需的处理时间从⼤ 到⼩排序。然后依此顺序将作业分配给空闲的处理 机。算法所需的计算时间为 O( n l ogn ) 。 0 4.7 多机调度问题 例如， 设 7 个独⽴作业 {1,2,3,4,5,6,7} 由 3 台机 器 M1 ， M2 和 M3 加⼯处理。各作业所需的处理时间 分别为 {2,14,4,16,6,5,3} 。按算法 gr e e d y 产⽣的作业调 度如下图所示，所需的加⼯时间为 17 。 0 4.8 贪⼼算法的理论基础 借助于 拟阵 ⼯具，可建⽴关于贪⼼算法的较⼀般的理 论。这个理论对 确定何时使⽤贪⼼算法 可以得到问题 的整体最优解⼗分有⽤。 1 、拟阵 拟阵 M 定义为满⾜下⾯ 3 个条件的有序对 (S ,I) ： (1)S 是⾮空有限集。 (2)I 是 S 的⼀类具有遗传性质的独⽴⼦集族，即若 B \u0000 I ， 则 B 是 S 的独⽴⼦集，且 B 的任意⼦集也都是 S 的独⽴⼦ 集。空集 \u0000 必为 I 的成员。 (3)I 满⾜交换性质，即若 A \u0000 I,B \u0000 I 且 | A | <| B| ，则存在某⼀ 元素 x \u0000 B-A ，使得 A ∪ {x} \u0000 I 。 0 4.8 贪⼼算法的理论基础 例如， 设 S 是⼀给定矩阵中⾏向量的集合， I 是 S 的线 性独⽴⼦集族，则由线性空间理论容易证明 (S ,I) 是⼀ 拟阵。拟阵的另⼀个例⼦是⽆向图 G =(V ,E ) 的图拟阵 。 给定拟阵 M =(S ,I) ，对于 I 中的独⽴⼦集 A \u0000 I ，若 S 有 ⼀元素 x \u0000 A ，使得将 x 加⼊ A 后仍保持独⽴性，即 A ∪ {x} \u0000 I, 则称 x 为 A 的 可扩展元素 。 当拟阵 M 中的独⽴⼦集 A 没有可扩展元素时，称 A 为 极⼤独⽴⼦集 。 0 4.8 贪⼼算法的理论基础 下⾯的关于 极⼤独⽴⼦集 的性质是很有⽤的。 定理 4.1 ： 拟阵 M 中所有极⼤独⽴⼦集⼤⼩相同。 这个定理可以⽤反证法证明。 若对拟阵 M =(S ,I) 中的 S 指定权函数 W ，使得对于任 意 x \u0000 S ，有 W (x)>0 ，则称拟阵 M 为 带权拟阵 。依此权 函数， S 的任⼀⼦集 A 的权定义为 。 2 、关于带权拟阵的贪⼼算法 许多可以⽤贪⼼算法求解的问题可以表示为求带权拟 阵的 最⼤权独⽴⼦集问题 。 0 4.8 贪⼼算法的理论基础 给定带权拟阵 M =(S ,I) ，确定 S 的独⽴⼦集 A \u0000 I 使得 W (A ) 达到最⼤。这种使 W (A ) 最⼤的独⽴⼦集 A 称为拟 阵 M 的 最优⼦集 。由于 S 中任⼀元素 x 的权 W (x) 是正 的，因此， 最优⼦集也⼀定是极⼤独⽴⼦集 。 例如， 在最⼩⽣成树问题可以表示为确定带权拟阵 的最优⼦集问题。求带权拟阵的最优⼦集 A 的算法可⽤ 于解最⼩⽣成树问题。 下⾯给出求 带权拟阵最优⼦集 的贪⼼算法。该算法以 具有正权函数 W 的带权拟阵 M =(S ,I) 作为输⼊，经计算 后输出 M 的最优⼦集 A 。 0 4.8 贪⼼算法的理论基础 • Set gr e e d y (M ,W ) • {A = \u0000 ; • 将 S 中元素依权值 W （⼤者优先）组成优先队列； • w hi l e (S != \u0000 ) { • S . re m ove M a x (x); • i f (A ∪ {x} \u0000 I) A =A ∪ {x}; • } • re t urn A • } 0 4.8 贪⼼算法的理论基础 算法 gr e e d y 的计算时间复杂性为 。 引理 4.2 ( 拟阵的贪⼼选择性质 ) 设 M =(S ,I) 是具有权函数 W 的带权拟阵，且 S 中元素依 权值从⼤到⼩排列。⼜设 x \u0000 S 是 S 中第⼀个使得 {x} 是 独⽴⼦集的元素，则存在 S 的最优⼦集 A 使得 x \u0000 A 。 算法 gr e e d y 在以贪⼼选择构造最优⼦集 A 时，⾸次选 ⼊集合 A 中的元素 x 是单元素独⽴集中具有最⼤权的元 素。此时可能已经舍弃了 S 中部分元素。可以证明这些 被舍弃的元素不可能⽤于构造最优⼦集。 0 4.8 贪⼼算法的理论基础 引理 4.3 ： 设 M =(S ,I) 是拟阵。若 S 中元素 x 不是空集 \u0000 的 可扩展元素，则 x 也不可能是 S 中任⼀独⽴⼦集 A 的可扩 展元素。 引理 4.4( 拟阵的最优⼦结构性质 ) 设 x 是求带权拟阵 M ＝ (S ， I) 的最优⼦集的贪⼼算法 gr e e d y 所选择的 S 中的第⼀个元素。那么，原问题可简 化为求带权拟阵 M ’=(S ’,I’) 的 最优⼦集 问题，其中： S ’={y| y \u0000 S 且 {x,y} \u0000 I} I’={B| B \u0000 S -{x} 且 B ∪ {x} \u0000 I} M ’ 的权函数是 M 的权函数在 S’ 上的限制 ( 称 M’ 为 M 关 0 4.8 贪⼼算法的理论基础 定理 4.5( 带权拟阵贪⼼算法的正确性 ) 设 M ＝ (S ,I) 是具有权函数 W 的带权拟阵，算法 gre e dy 返回 M 的最优⼦集。 3 、任务时间表问题 给定⼀个 单位时间任务 的有限集 S 。关于 S 的⼀个 时 间表 ⽤于描述 S 中单位时间任务的执⾏次序。时间表中 第 1 个任务从时间 0 开始执⾏直⾄时间 1 结束，第 2 个任 务从时间 1 开始执⾏⾄时间 2 结束， … ，第 n 个任务从时 间 n-1 开始执⾏直⾄时间 n 结束。   0 4.6 最⼩⽣成树 利⽤最⼩⽣成树性质和数 学归纳法容易证明，上述 算法中的 边集合 T 始终包 含 G 的某棵最⼩⽣成树中 的边 。因此，在算法结束 时， T 中的所有边构成 G 的 ⼀棵最⼩⽣成树。 例如 ，对于右图中的带权 图，按 Prim 算法 选取边的 过程如下⻚图所示。 0 4.6 最⼩⽣成树 0 4.6 最⼩⽣成树 在上述 P ri m 算法中，还应当考虑 如何有效地找出满⾜条 件 i \u0000\u0000 S ,j \u0000\u0000 V -S ，且权 c [i ][j] 最⼩的边 (i ,j) 。实现这个⽬的的 较简单的办法是设置 2 个数组 c l os e s t 和 l ow c os t 。 在 P ri m 算法执⾏过程中，先找出 V -S 中使 l ow c os t 值最⼩ 的顶点 j ，然后根据数组 c l os e s t 选取边 (j ,c l os e s t [j ］ ) ，最后 将 j 添加到 S 中，并对 c l os e s t 和 l ow c os t 作必要的修改。 ⽤这个办法实现的 P ri m 算法所需的 计算时间 为 0 4.6 最⼩⽣成树 3 、 Kruskal算法 K rus ka l 算法构造 G 的最⼩⽣成树的 基本思想 是，⾸ 先将 G 的 n 个顶点看成 n 个孤⽴的连通分⽀。将所有的边 按权从⼩到⼤排序。然后从第⼀条边开始，依边权递 增的顺序查看每⼀条边，并按下述⽅法连接 2 个不同的 连通分⽀：当查看到第 k 条边 (v ,w ) 时，如果端点 v 和 w 分别是当前 2 个不同的连通分⽀ T1 和 T2 中的顶点时，就 ⽤边 (v ,w ) 将 T1 和 T2 连接成⼀个连通分⽀，然后继续查 看第 k+1 条边；如果端点 v 和 w 在当前的同⼀个连通分⽀ 中，就直接再查看第 k+1 条边。这个过程⼀直进⾏到只 剩下⼀个连通分⽀时为⽌。 0 4.6 最⼩⽣成树 例如， 对前⾯的连通带权图，按 K rus ka l 算法顺序得到的最⼩ ⽣成树上的边如下图所示。 0 4.6 最⼩⽣成树 关于 集合的⼀些基本运算 可⽤于实现 K rus ka l 算法。 按权的递增顺序查看等价于对 优先队列 执 ⾏ r e move M i n 运算。可以⽤ 堆 实现这个优先队列。 对⼀个由连通分⽀组成的集合不断进⾏修改，需要⽤ 到抽象数据类型 并查集 U n i on F i n d 所⽀持的基本运算。 当图的边数为 e 时， K rus ka l 算法所需的 计算时间 是 。当 时， K rus ka l 算法⽐ P ri m 算法差，但当 时， K rus ka l 算法却⽐ P ri m 算法好得多。 0 4.7 多机调度问题 多机调度问题 要求给出⼀种作业调度⽅案，使所给的 n 个作业在尽可能短的时间内由 m 台机器加⼯处理完 成。 这个问题是 N P 完全问题 ，到⽬前为⽌还没有有效的 解法。对于这⼀类问题 , ⽤ 贪⼼选择策略 有时可以设计 出较好的近似算法。 约定，每个作业均可在任何⼀台机器上加⼯处理，但未完⼯ 前不允许中断处理。作业不能拆分成更⼩的⼦作业。 0 4.7 多机调度问题 采⽤ 最⻓处理时间作业优先 的贪⼼选择策略可以设计 出解多机调度问题的较好的近似算法。 按此策略，当 时，只要将机器 i 的 [0, ti ] 时间区间 分配给作业 i 即可，算法只需要 O (1) 时间。 当 时，⾸先将 n 个作业依其所需的处理时间从⼤ 到⼩排序。然后依此顺序将作业分配给空闲的处理 机。算法所需的计算时间为 O( n l ogn ) 。 0 4.7 多机调度问题 例如， 设 7 个独⽴作业 {1,2,3,4,5,6,7} 由 3 台机 器 M1 ， M2 和 M3 加⼯处理。各作业所需的处理时间 分别为 {2,14,4,16,6,5,3} 。按算法 gr e e d y 产⽣的作业调 度如下图所示，所需的加⼯时间为 17 。 0 4.8 贪⼼算法的理论基础 借助于 拟阵 ⼯具，可建⽴关于贪⼼算法的较⼀般的理 论。这个理论对 确定何时使⽤贪⼼算法 可以得到问题 的整体最优解⼗分有⽤。 1 、拟阵 拟阵 M 定义为满⾜下⾯ 3 个条件的有序对 (S ,I) ： (1)S 是⾮空有限集。 (2)I 是 S 的⼀类具有遗传性质的独⽴⼦集族，即若 B \u0000 I ， 则 B 是 S 的独⽴⼦集，且 B 的任意⼦集也都是 S 的独⽴⼦ 集。空集 \u0000 必为 I 的成员。 (3)I 满⾜交换性质，即若 A \u0000 I,B \u0000 I 且 | A | <| B| ，则存在某⼀ 元素 x \u0000 B-A ，使得 A ∪ {x} \u0000 I 。 0 4.8 贪⼼算法的理论基础 例如， 设 S 是⼀给定矩阵中⾏向量的集合， I 是 S 的线 性独⽴⼦集族，则由线性空间理论容易证明 (S ,I) 是⼀ 拟阵。拟阵的另⼀个例⼦是⽆向图 G =(V ,E ) 的图拟阵 。 给定拟阵 M =(S ,I) ，对于 I 中的独⽴⼦集 A \u0000 I ，若 S 有 ⼀元素 x \u0000 A ，使得将 x 加⼊ A 后仍保持独⽴性，即 A ∪ {x} \u0000 I, 则称 x 为 A 的 可扩展元素 。 当拟阵 M 中的独⽴⼦集 A 没有可扩展元素时，称 A 为 极⼤独⽴⼦集 。 0 4.8 贪⼼算法的理论基础 下⾯的关于 极⼤独⽴⼦集 的性质是很有⽤的。 定理 4.1 ： 拟阵 M 中所有极⼤独⽴⼦集⼤⼩相同。 这个定理可以⽤反证法证明。 若对拟阵 M =(S ,I) 中的 S 指定权函数 W ，使得对于任 意 x \u0000 S ，有 W (x)>0 ，则称拟阵 M 为 带权拟阵 。依此权 函数， S 的任⼀⼦集 A 的权定义为 。 2 、关于带权拟阵的贪⼼算法 许多可以⽤贪⼼算法求解的问题可以表示为求带权拟 阵的 最⼤权独⽴⼦集问题 。 0 4.8 贪⼼算法的理论基础 给定带权拟阵 M =(S ,I) ，确定 S 的独⽴⼦集 A \u0000 I 使得 W (A ) 达到最⼤。这种使 W (A ) 最⼤的独⽴⼦集 A 称为拟 阵 M 的 最优⼦集 。由于 S 中任⼀元素 x 的权 W (x) 是正 的，因此， 最优⼦集也⼀定是极⼤独⽴⼦集 。 例如， 在最⼩⽣成树问题可以表示为确定带权拟阵 的最优⼦集问题。求带权拟阵的最优⼦集 A 的算法可⽤ 于解最⼩⽣成树问题。 下⾯给出求 带权拟阵最优⼦集 的贪⼼算法。该算法以 具有正权函数 W 的带权拟阵 M =(S ,I) 作为输⼊，经计算 后输出 M 的最优⼦集 A 。 0 4.8 贪⼼算法的理论基础 • Set gr e e d y (M ,W ) • {A = \u0000 ; • 将 S 中元素依权值 W （⼤者优先）组成优先队列； • w hi l e (S != \u0000 ) { • S . re m ove M a x (x); • i f (A ∪ {x} \u0000 I) A =A ∪ {x}; • } • re t urn A • } 0 4.8 贪⼼算法的理论基础 算法 gr e e d y 的计算时间复杂性为 。 引理 4.2 ( 拟阵的贪⼼选择性质 ) 设 M =(S ,I) 是具有权函数 W 的带权拟阵，且 S 中元素依 权值从⼤到⼩排列。⼜设 x \u0000 S 是 S 中第⼀个使得 {x} 是 独⽴⼦集的元素，则存在 S 的最优⼦集 A 使得 x \u0000 A 。 算法 gr e e d y 在以贪⼼选择构造最优⼦集 A 时，⾸次选 ⼊集合 A 中的元素 x 是单元素独⽴集中具有最⼤权的元 素。此时可能已经舍弃了 S 中部分元素。可以证明这些 被舍弃的元素不可能⽤于构造最优⼦集。 0 4.8 贪⼼算法的理论基础 引理 4.3 ： 设 M =(S ,I) 是拟阵。若 S 中元素 x 不是空集 \u0000 的 可扩展元素，则 x 也不可能是 S 中任⼀独⽴⼦集 A 的可扩 展元素。 引理 4.4( 拟阵的最优⼦结构性质 ) 设 x 是求带权拟阵 M ＝ (S ， I) 的最优⼦集的贪⼼算法 gr e e d y 所选择的 S 中的第⼀个元素。那么，原问题可简 化为求带权拟阵 M ’=(S ’,I’) 的 最优⼦集 问题，其中： S ’={y| y \u0000 S 且 {x,y} \u0000 I} I’={B| B \u0000 S -{x} 且 B ∪ {x} \u0000 I} M ’ 的权函数是 M 的权函数在 S’ 上的限制 ( 称 M’ 为 M 关 0 4.8 贪⼼算法的理论基础 定理 4.5( 带权拟阵贪⼼算法的正确性 ) 设 M ＝ (S ,I) 是具有权函数 W 的带权拟阵，算法 gre e dy 返回 M 的最优⼦集。 3 、任务时间表问题 给定⼀个 单位时间任务 的有限集 S 。关于 S 的⼀个 时 间表 ⽤于描述 S 中单位时间任务的执⾏次序。时间表中 第 1 个任务从时间 0 开始执⾏直⾄时间 1 结束，第 2 个任 务从时间 1 开始执⾏⾄时间 2 结束， … ，第 n 个任务从时 间 n-1 开始执⾏直⾄时间 n 结束。   0 4.6 最⼩⽣成树 利⽤最⼩⽣成树性质和数 学归纳法容易证明，上述 算法中的 边集合 T 始终包 含 G 的某棵最⼩⽣成树中 的边 。因此，在算法结束 时， T 中的所有边构成 G 的 ⼀棵最⼩⽣成树。 例如 ，对于右图中的带权 图，按 Prim 算法 选取边的 过程如下⻚图所示。 0 4.6 最⼩⽣成树 0 4.6 最⼩⽣成树 在上述 P ri m 算法中，还应当考虑 如何有效地找出满⾜条 件 i \u0000\u0000 S ,j \u0000\u0000 V -S ，且权 c [i ][j] 最⼩的边 (i ,j) 。实现这个⽬的的 较简单的办法是设置 2 个数组 c l os e s t 和 l ow c os t 。 在 P ri m 算法执⾏过程中，先找出 V -S 中使 l ow c os t 值最⼩ 的顶点 j ，然后根据数组 c l os e s t 选取边 (j ,c l os e s t [j ］ ) ，最后 将 j 添加到 S 中，并对 c l os e s t 和 l ow c os t 作必要的修改。 ⽤这个办法实现的 P ri m 算法所需的 计算时间 为 0 4.6 最⼩⽣成树 3 、 Kruskal算法 K rus ka l 算法构造 G 的最⼩⽣成树的 基本思想 是，⾸ 先将 G 的 n 个顶点看成 n 个孤⽴的连通分⽀。将所有的边 按权从⼩到⼤排序。然后从第⼀条边开始，依边权递 增的顺序查看每⼀条边，并按下述⽅法连接 2 个不同的 连通分⽀：当查看到第 k 条边 (v ,w ) 时，如果端点 v 和 w 分别是当前 2 个不同的连通分⽀ T1 和 T2 中的顶点时，就 ⽤边 (v ,w ) 将 T1 和 T2 连接成⼀个连通分⽀，然后继续查 看第 k+1 条边；如果端点 v 和 w 在当前的同⼀个连通分⽀ 中，就直接再查看第 k+1 条边。这个过程⼀直进⾏到只 剩下⼀个连通分⽀时为⽌。 0 4.6 最⼩⽣成树 例如， 对前⾯的连通带权图，按 K rus ka l 算法顺序得到的最⼩ ⽣成树上的边如下图所示。 0 4.6 最⼩⽣成树 关于 集合的⼀些基本运算 可⽤于实现 K rus ka l 算法。 按权的递增顺序查看等价于对 优先队列 执 ⾏ r e move M i n 运算。可以⽤ 堆 实现这个优先队列。 对⼀个由连通分⽀组成的集合不断进⾏修改，需要⽤ 到抽象数据类型 并查集 U n i on F i n d 所⽀持的基本运算。 当图的边数为 e 时， K rus ka l 算法所需的 计算时间 是 。当 时， K rus ka l 算法⽐ P ri m 算法差，但当 时， K rus ka l 算法却⽐ P ri m 算法好得多。 0 4.7 多机调度问题 多机调度问题 要求给出⼀种作业调度⽅案，使所给的 n 个作业在尽可能短的时间内由 m 台机器加⼯处理完 成。 这个问题是 N P 完全问题 ，到⽬前为⽌还没有有效的 解法。对于这⼀类问题 , ⽤ 贪⼼选择策略 有时可以设计 出较好的近似算法。 约定，每个作业均可在任何⼀台机器上加⼯处理，但未完⼯ 前不允许中断处理。作业不能拆分成更⼩的⼦作业。 0 4.7 多机调度问题 采⽤ 最⻓处理时间作业优先 的贪⼼选择策略可以设计 出解多机调度问题的较好的近似算法。 按此策略，当 时，只要将机器 i 的 [0, ti ] 时间区间 分配给作业 i 即可，算法只需要 O (1) 时间。 当 时，⾸先将 n 个作业依其所需的处理时间从⼤ 到⼩排序。然后依此顺序将作业分配给空闲的处理 机。算法所需的计算时间为 O( n l ogn ) 。 0 4.7 多机调度问题 例如， 设 7 个独⽴作业 {1,2,3,4,5,6,7} 由 3 台机 器 M1 ， M2 和 M3 加⼯处理。各作业所需的处理时间 分别为 {2,14,4,16,6,5,3} 。按算法 gr e e d y 产⽣的作业调 度如下图所示，所需的加⼯时间为 17 。 0 4.8 贪⼼算法的理论基础 借助于 拟阵 ⼯具，可建⽴关于贪⼼算法的较⼀般的理 论。这个理论对 确定何时使⽤贪⼼算法 可以得到问题 的整体最优解⼗分有⽤。 1 、拟阵 拟阵 M 定义为满⾜下⾯ 3 个条件的有序对 (S ,I) ： (1)S 是⾮空有限集。 (2)I 是 S 的⼀类具有遗传性质的独⽴⼦集族，即若 B \u0000 I ， 则 B 是 S 的独⽴⼦集，且 B 的任意⼦集也都是 S 的独⽴⼦ 集。空集 \u0000 必为 I 的成员。 (3)I 满⾜交换性质，即若 A \u0000 I,B \u0000 I 且 | A | <| B| ，则存在某⼀ 元素 x \u0000 B-A ，使得 A ∪ {x} \u0000 I 。 0 4.8 贪⼼算法的理论基础 例如， 设 S 是⼀给定矩阵中⾏向量的集合， I 是 S 的线 性独⽴⼦集族，则由线性空间理论容易证明 (S ,I) 是⼀ 拟阵。拟阵的另⼀个例⼦是⽆向图 G =(V ,E ) 的图拟阵 。 给定拟阵 M =(S ,I) ，对于 I 中的独⽴⼦集 A \u0000 I ，若 S 有 ⼀元素 x \u0000 A ，使得将 x 加⼊ A 后仍保持独⽴性，即 A ∪ {x} \u0000 I, 则称 x 为 A 的 可扩展元素 。 当拟阵 M 中的独⽴⼦集 A 没有可扩展元素时，称 A 为 极⼤独⽴⼦集 。 0 4.8 贪⼼算法的理论基础 下⾯的关于 极⼤独⽴⼦集 的性质是很有⽤的。 定理 4.1 ： 拟阵 M 中所有极⼤独⽴⼦集⼤⼩相同。 这个定理可以⽤反证法证明。 若对拟阵 M =(S ,I) 中的 S 指定权函数 W ，使得对于任 意 x \u0000 S ，有 W (x)>0 ，则称拟阵 M 为 带权拟阵 。依此权 函数， S 的任⼀⼦集 A 的权定义为 。 2 、关于带权拟阵的贪⼼算法 许多可以⽤贪⼼算法求解的问题可以表示为求带权拟 阵的 最⼤权独⽴⼦集问题 。 0 4.8 贪⼼算法的理论基础 给定带权拟阵 M =(S ,I) ，确定 S 的独⽴⼦集 A \u0000 I 使得 W (A ) 达到最⼤。这种使 W (A ) 最⼤的独⽴⼦集 A 称为拟 阵 M 的 最优⼦集 。由于 S 中任⼀元素 x 的权 W (x) 是正 的，因此， 最优⼦集也⼀定是极⼤独⽴⼦集 。 例如， 在最⼩⽣成树问题可以表示为确定带权拟阵 的最优⼦集问题。求带权拟阵的最优⼦集 A 的算法可⽤ 于解最⼩⽣成树问题。 下⾯给出求 带权拟阵最优⼦集 的贪⼼算法。该算法以 具有正权函数 W 的带权拟阵 M =(S ,I) 作为输⼊，经计算 后输出 M 的最优⼦集 A 。 0 4.8 贪⼼算法的理论基础 • Set gr e e d y (M ,W ) • {A = \u0000 ; • 将 S 中元素依权值 W （⼤者优先）组成优先队列； • w hi l e (S != \u0000 ) { • S . re m ove M a x (x); • i f (A ∪ {x} \u0000 I) A =A ∪ {x}; • } • re t urn A • } 0 4.8 贪⼼算法的理论基础 算法 gr e e d y 的计算时间复杂性为 。 引理 4.2 ( 拟阵的贪⼼选择性质 ) 设 M =(S ,I) 是具有权函数 W 的带权拟阵，且 S 中元素依 权值从⼤到⼩排列。⼜设 x \u0000 S 是 S 中第⼀个使得 {x} 是 独⽴⼦集的元素，则存在 S 的最优⼦集 A 使得 x \u0000 A 。 算法 gr e e d y 在以贪⼼选择构造最优⼦集 A 时，⾸次选 ⼊集合 A 中的元素 x 是单元素独⽴集中具有最⼤权的元 素。此时可能已经舍弃了 S 中部分元素。可以证明这些 被舍弃的元素不可能⽤于构造最优⼦集。 0 4.8 贪⼼算法的理论基础 引理 4.3 ： 设 M =(S ,I) 是拟阵。若 S 中元素 x 不是空集 \u0000 的 可扩展元素，则 x 也不可能是 S 中任⼀独⽴⼦集 A 的可扩 展元素。 引理 4.4( 拟阵的最优⼦结构性质 ) 设 x 是求带权拟阵 M ＝ (S ， I) 的最优⼦集的贪⼼算法 gr e e d y 所选择的 S 中的第⼀个元素。那么，原问题可简 化为求带权拟阵 M ’=(S ’,I’) 的 最优⼦集 问题，其中： S ’={y| y \u0000 S 且 {x,y} \u0000 I} I’={B| B \u0000 S -{x} 且 B ∪ {x} \u0000 I} M ’ 的权函数是 M 的权函数在 S’ 上的限制 ( 称 M’ 为 M 关 0 4.8 贪⼼算法的理论基础 定理 4.5( 带权拟阵贪⼼算法的正确性 ) 设 M ＝ (S ,I) 是具有权函数 W 的带权拟阵，算法 gre e dy 返回 M 的最优⼦集。 3 、任务时间表问题 给定⼀个 单位时间任务 的有限集 S 。关于 S 的⼀个 时 间表 ⽤于描述 S 中单位时间任务的执⾏次序。时间表中 第 1 个任务从时间 0 开始执⾏直⾄时间 1 结束，第 2 个任 务从时间 1 开始执⾏⾄时间 2 结束， … ，第 n 个任务从时 间 n-1 开始执⾏直⾄时间 n 结束。   0 4.6 最⼩⽣成树 利⽤最⼩⽣成树性质和数 学归纳法容易证明，上述 算法中的 边集合 T 始终包 含 G 的某棵最⼩⽣成树中 的边 。因此，在算法结束 时， T 中的所有边构成 G 的 ⼀棵最⼩⽣成树。 例如 ，对于右图中的带权 图，按 Prim 算法 选取边的 过程如下⻚图所示。 0 4.6 最⼩⽣成树 0 4.6 最⼩⽣成树 在上述 P ri m 算法中，还应当考虑 如何有效地找出满⾜条 件 i \u0000\u0000 S ,j \u0000\u0000 V -S ，且权 c [i ][j] 最⼩的边 (i ,j) 。实现这个⽬的的 较简单的办法是设置 2 个数组 c l os e s t 和 l ow c os t 。 在 P ri m 算法执⾏过程中，先找出 V -S 中使 l ow c os t 值最⼩ 的顶点 j ，然后根据数组 c l os e s t 选取边 (j ,c l os e s t [j ］ ) ，最后 将 j 添加到 S 中，并对 c l os e s t 和 l ow c os t 作必要的修改。 ⽤这个办法实现的 P ri m 算法所需的 计算时间 为 0 4.6 最⼩⽣成树 3 、 Kruskal算法 K rus ka l 算法构造 G 的最⼩⽣成树的 基本思想 是，⾸ 先将 G 的 n 个顶点看成 n 个孤⽴的连通分⽀。将所有的边 按权从⼩到⼤排序。然后从第⼀条边开始，依边权递 增的顺序查看每⼀条边，并按下述⽅法连接 2 个不同的 连通分⽀：当查看到第 k 条边 (v ,w ) 时，如果端点 v 和 w 分别是当前 2 个不同的连通分⽀ T1 和 T2 中的顶点时，就 ⽤边 (v ,w ) 将 T1 和 T2 连接成⼀个连通分⽀，然后继续查 看第 k+1 条边；如果端点 v 和 w 在当前的同⼀个连通分⽀ 中，就直接再查看第 k+1 条边。这个过程⼀直进⾏到只 剩下⼀个连通分⽀时为⽌。 0 4.6 最⼩⽣成树 例如， 对前⾯的连通带权图，按 K rus ka l 算法顺序得到的最⼩ ⽣成树上的边如下图所示。 0 4.6 最⼩⽣成树 关于 集合的⼀些基本运算 可⽤于实现 K rus ka l 算法。 按权的递增顺序查看等价于对 优先队列 执 ⾏ r e move M i n 运算。可以⽤ 堆 实现这个优先队列。 对⼀个由连通分⽀组成的集合不断进⾏修改，需要⽤ 到抽象数据类型 并查集 U n i on F i n d 所⽀持的基本运算。 当图的边数为 e 时， K rus ka l 算法所需的 计算时间 是 。当 时， K rus ka l 算法⽐ P ri m 算法差，但当 时， K rus ka l 算法却⽐ P ri m 算法好得多。 0 4.7 多机调度问题 多机调度问题 要求给出⼀种作业调度⽅案，使所给的 n 个作业在尽可能短的时间内由 m 台机器加⼯处理完 成。 这个问题是 N P 完全问题 ，到⽬前为⽌还没有有效的 解法。对于这⼀类问题 , ⽤ 贪⼼选择策略 有时可以设计 出较好的近似算法。 约定，每个作业均可在任何⼀台机器上加⼯处理，但未完⼯ 前不允许中断处理。作业不能拆分成更⼩的⼦作业。 0 4.7 多机调度问题 采⽤ 最⻓处理时间作业优先 的贪⼼选择策略可以设计 出解多机调度问题的较好的近似算法。 按此策略，当 时，只要将机器 i 的 [0, ti ] 时间区间 分配给作业 i 即可，算法只需要 O (1) 时间。 当 时，⾸先将 n 个作业依其所需的处理时间从⼤ 到⼩排序。然后依此顺序将作业分配给空闲的处理 机。算法所需的计算时间为 O( n l ogn ) 。 0 4.7 多机调度问题 例如， 设 7 个独⽴作业 {1,2,3,4,5,6,7} 由 3 台机 器 M1 ， M2 和 M3 加⼯处理。各作业所需的处理时间 分别为 {2,14,4,16,6,5,3} 。按算法 gr e e d y 产⽣的作业调 度如下图所示，所需的加⼯时间为 17 。 0 4.8 贪⼼算法的理论基础 借助于 拟阵 ⼯具，可建⽴关于贪⼼算法的较⼀般的理 论。这个理论对 确定何时使⽤贪⼼算法 可以得到问题 的整体最优解⼗分有⽤。 1 、拟阵 拟阵 M 定义为满⾜下⾯ 3 个条件的有序对 (S ,I) ： (1)S 是⾮空有限集。 (2)I 是 S 的⼀类具有遗传性质的独⽴⼦集族，即若 B \u0000 I ， 则 B 是 S 的独⽴⼦集，且 B 的任意⼦集也都是 S 的独⽴⼦ 集。空集 \u0000 必为 I 的成员。 (3)I 满⾜交换性质，即若 A \u0000 I,B \u0000 I 且 | A | <| B| ，则存在某⼀ 元素 x \u0000 B-A ，使得 A ∪ {x} \u0000 I 。 0 4.8 贪⼼算法的理论基础 例如， 设 S 是⼀给定矩阵中⾏向量的集合， I 是 S 的线 性独⽴⼦集族，则由线性空间理论容易证明 (S ,I) 是⼀ 拟阵。拟阵的另⼀个例⼦是⽆向图 G =(V ,E ) 的图拟阵 。 给定拟阵 M =(S ,I) ，对于 I 中的独⽴⼦集 A \u0000 I ，若 S 有 ⼀元素 x \u0000 A ，使得将 x 加⼊ A 后仍保持独⽴性，即 A ∪ {x} \u0000 I, 则称 x 为 A 的 可扩展元素 。 当拟阵 M 中的独⽴⼦集 A 没有可扩展元素时，称 A 为 极⼤独⽴⼦集 。 0 4.8 贪⼼算法的理论基础 下⾯的关于 极⼤独⽴⼦集 的性质是很有⽤的。 定理 4.1 ： 拟阵 M 中所有极⼤独⽴⼦集⼤⼩相同。 这个定理可以⽤反证法证明。 若对拟阵 M =(S ,I) 中的 S 指定权函数 W ，使得对于任 意 x \u0000 S ，有 W (x)>0 ，则称拟阵 M 为 带权拟阵 。依此权 函数， S 的任⼀⼦集 A 的权定义为 。 2 、关于带权拟阵的贪⼼算法 许多可以⽤贪⼼算法求解的问题可以表示为求带权拟 阵的 最⼤权独⽴⼦集问题 。 0 4.8 贪⼼算法的理论基础 给定带权拟阵 M =(S ,I) ，确定 S 的独⽴⼦集 A \u0000 I 使得 W (A ) 达到最⼤。这种使 W (A ) 最⼤的独⽴⼦集 A 称为拟 阵 M 的 最优⼦集 。由于 S 中任⼀元素 x 的权 W (x) 是正 的，因此， 最优⼦集也⼀定是极⼤独⽴⼦集 。 例如， 在最⼩⽣成树问题可以表示为确定带权拟阵 的最优⼦集问题。求带权拟阵的最优⼦集 A 的算法可⽤ 于解最⼩⽣成树问题。 下⾯给出求 带权拟阵最优⼦集 的贪⼼算法。该算法以 具有正权函数 W 的带权拟阵 M =(S ,I) 作为输⼊，经计算 后输出 M 的最优⼦集 A 。 0 4.8 贪⼼算法的理论基础 • Set gr e e d y (M ,W ) • {A = \u0000 ; • 将 S 中元素依权值 W （⼤者优先）组成优先队列； • w hi l e (S != \u0000 ) { • S . re m ove M a x (x); • i f (A ∪ {x} \u0000 I) A =A ∪ {x}; • } • re t urn A • } 0 4.8 贪⼼算法的理论基础 算法 gr e e d y 的计算时间复杂性为 。 引理 4.2 ( 拟阵的贪⼼选择性质 ) 设 M =(S ,I) 是具有权函数 W 的带权拟阵，且 S 中元素依 权值从⼤到⼩排列。⼜设 x \u0000 S 是 S 中第⼀个使得 {x} 是 独⽴⼦集的元素，则存在 S 的最优⼦集 A 使得 x \u0000 A 。 算法 gr e e d y 在以贪⼼选择构造最优⼦集 A 时，⾸次选 ⼊集合 A 中的元素 x 是单元素独⽴集中具有最⼤权的元 素。此时可能已经舍弃了 S 中部分元素。可以证明这些 被舍弃的元素不可能⽤于构造最优⼦集。 0 4.8 贪⼼算法的理论基础 引理 4.3 ： 设 M =(S ,I) 是拟阵。若 S 中元素 x 不是空集 \u0000 的 可扩展元素，则 x 也不可能是 S 中任⼀独⽴⼦集 A 的可扩 展元素。 引理 4.4( 拟阵的最优⼦结构性质 ) 设 x 是求带权拟阵 M ＝ (S ， I) 的最优⼦集的贪⼼算法 gr e e d y 所选择的 S 中的第⼀个元素。那么，原问题可简 化为求带权拟阵 M ’=(S ’,I’) 的 最优⼦集 问题，其中： S ’={y| y \u0000 S 且 {x,y} \u0000 I} I’={B| B \u0000 S -{x} 且 B ∪ {x} \u0000 I} M ’ 的权函数是 M 的权函数在 S’ 上的限制 ( 称 M’ 为 M 关 0 4.8 贪⼼算法的理论基础 定理 4.5( 带权拟阵贪⼼算法的正确性 ) 设 M ＝ (S ,I) 是具有权函数 W 的带权拟阵，算法 gre e dy 返回 M 的最优⼦集。 3 、任务时间表问题 给定⼀个 单位时间任务 的有限集 S 。关于 S 的⼀个 时 间表 ⽤于描述 S 中单位时间任务的执⾏次序。时间表中 第 1 个任务从时间 0 开始执⾏直⾄时间 1 结束，第 2 个任 务从时间 1 开始执⾏⾄时间 2 结束， … ，第 n 个任务从时 间 n-1 开始执⾏直⾄时间 n 结束。   0 4.6 最⼩⽣成树 利⽤最⼩⽣成树性质和数 学归纳法容易证明，上述 算法中的 边集合 T 始终包 含 G 的某棵最⼩⽣成树中 的边 。因此，在算法结束 时， T 中的所有边构成 G 的 ⼀棵最⼩⽣成树。 例如 ，对于右图中的带权 图，按 Prim 算法 选取边的 过程如下⻚图所示。 0 4.6 最⼩⽣成树 0 4.6 最⼩⽣成树 在上述 P ri m 算法中，还应当考虑 如何有效地找出满⾜条 件 i \u0000\u0000 S ,j \u0000\u0000 V -S ，且权 c [i ][j] 最⼩的边 (i ,j) 。实现这个⽬的的 较简单的办法是设置 2 个数组 c l os e s t 和 l ow c os t 。 在 P ri m 算法执⾏过程中，先找出 V -S 中使 l ow c os t 值最⼩ 的顶点 j ，然后根据数组 c l os e s t 选取边 (j ,c l os e s t [j ］ ) ，最后 将 j 添加到 S 中，并对 c l os e s t 和 l ow c os t 作必要的修改。 ⽤这个办法实现的 P ri m 算法所需的 计算时间 为 0 4.6 最⼩⽣成树 3 、 Kruskal算法 K rus ka l 算法构造 G 的最⼩⽣成树的 基本思想 是，⾸ 先将 G 的 n 个顶点看成 n 个孤⽴的连通分⽀。将所有的边 按权从⼩到⼤排序。然后从第⼀条边开始，依边权递 增的顺序查看每⼀条边，并按下述⽅法连接 2 个不同的 连通分⽀：当查看到第 k 条边 (v ,w ) 时，如果端点 v 和 w 分别是当前 2 个不同的连通分⽀ T1 和 T2 中的顶点时，就 ⽤边 (v ,w ) 将 T1 和 T2 连接成⼀个连通分⽀，然后继续查 看第 k+1 条边；如果端点 v 和 w 在当前的同⼀个连通分⽀ 中，就直接再查看第 k+1 条边。这个过程⼀直进⾏到只 剩下⼀个连通分⽀时为⽌。 0 4.6 最⼩⽣成树 例如， 对前⾯的连通带权图，按 K rus ka l 算法顺序得到的最⼩ ⽣成树上的边如下图所示。 0 4.6 最⼩⽣成树 关于 集合的⼀些基本运算 可⽤于实现 K rus ka l 算法。 按权的递增顺序查看等价于对 优先队列 执 ⾏ r e move M i n 运算。可以⽤ 堆 实现这个优先队列。 对⼀个由连通分⽀组成的集合不断进⾏修改，需要⽤ 到抽象数据类型 并查集 U n i on F i n d 所⽀持的基本运算。 当图的边数为 e 时， K rus ka l 算法所需的 计算时间 是 。当 时， K rus ka l 算法⽐ P ri m 算法差，但当 时， K rus ka l 算法却⽐ P ri m 算法好得多。 0 4.7 多机调度问题 多机调度问题 要求给出⼀种作业调度⽅案，使所给的 n 个作业在尽可能短的时间内由 m 台机器加⼯处理完 成。 这个问题是 N P 完全问题 ，到⽬前为⽌还没有有效的 解法。对于这⼀类问题 , ⽤ 贪⼼选择策略 有时可以设计 出较好的近似算法。 约定，每个作业均可在任何⼀台机器上加⼯处理，但未完⼯ 前不允许中断处理。作业不能拆分成更⼩的⼦作业。 0 4.7 多机调度问题 采⽤ 最⻓处理时间作业优先 的贪⼼选择策略可以设计 出解多机调度问题的较好的近似算法。 按此策略，当 时，只要将机器 i 的 [0, ti ] 时间区间 分配给作业 i 即可，算法只需要 O (1) 时间。 当 时，⾸先将 n 个作业依其所需的处理时间从⼤ 到⼩排序。然后依此顺序将作业分配给空闲的处理 机。算法所需的计算时间为 O( n l ogn ) 。 0 4.7 多机调度问题 例如， 设 7 个独⽴作业 {1,2,3,4,5,6,7} 由 3 台机 器 M1 ， M2 和 M3 加⼯处理。各作业所需的处理时间 分别为 {2,14,4,16,6,5,3} 。按算法 gr e e d y 产⽣的作业调 度如下图所示，所需的加⼯时间为 17 。 0 4.8 贪⼼算法的理论基础 借助于 拟阵 ⼯具，可建⽴关于贪⼼算法的较⼀般的理 论。这个理论对 确定何时使⽤贪⼼算法 可以得到问题 的整体最优解⼗分有⽤。 1 、拟阵 拟阵 M 定义为满⾜下⾯ 3 个条件的有序对 (S ,I) ： (1)S 是⾮空有限集。 (2)I 是 S 的⼀类具有遗传性质的独⽴⼦集族，即若 B \u0000 I ， 则 B 是 S 的独⽴⼦集，且 B 的任意⼦集也都是 S 的独⽴⼦ 集。空集 \u0000 必为 I 的成员。 (3)I 满⾜交换性质，即若 A \u0000 I,B \u0000 I 且 | A | <| B| ，则存在某⼀ 元素 x \u0000 B-A ，使得 A ∪ {x} \u0000 I 。 0 4.8 贪⼼算法的理论基础 例如， 设 S 是⼀给定矩阵中⾏向量的集合， I 是 S 的线 性独⽴⼦集族，则由线性空间理论容易证明 (S ,I) 是⼀ 拟阵。拟阵的另⼀个例⼦是⽆向图 G =(V ,E ) 的图拟阵 。 给定拟阵 M =(S ,I) ，对于 I 中的独⽴⼦集 A \u0000 I ，若 S 有 ⼀元素 x \u0000 A ，使得将 x 加⼊ A 后仍保持独⽴性，即 A ∪ {x} \u0000 I, 则称 x 为 A 的 可扩展元素 。 当拟阵 M 中的独⽴⼦集 A 没有可扩展元素时，称 A 为 极⼤独⽴⼦集 。 0 4.8 贪⼼算法的理论基础 下⾯的关于 极⼤独⽴⼦集 的性质是很有⽤的。 定理 4.1 ： 拟阵 M 中所有极⼤独⽴⼦集⼤⼩相同。 这个定理可以⽤反证法证明。 若对拟阵 M =(S ,I) 中的 S 指定权函数 W ，使得对于任 意 x \u0000 S ，有 W (x)>0 ，则称拟阵 M 为 带权拟阵 。依此权 函数， S 的任⼀⼦集 A 的权定义为 。 2 、关于带权拟阵的贪⼼算法 许多可以⽤贪⼼算法求解的问题可以表示为求带权拟 阵的 最⼤权独⽴⼦集问题 。 0 4.8 贪⼼算法的理论基础 给定带权拟阵 M =(S ,I) ，确定 S 的独⽴⼦集 A \u0000 I 使得 W (A ) 达到最⼤。这种使 W (A ) 最⼤的独⽴⼦集 A 称为拟 阵 M 的 最优⼦集 。由于 S 中任⼀元素 x 的权 W (x) 是正 的，因此， 最优⼦集也⼀定是极⼤独⽴⼦集 。 例如， 在最⼩⽣成树问题可以表示为确定带权拟阵 的最优⼦集问题。求带权拟阵的最优⼦集 A 的算法可⽤ 于解最⼩⽣成树问题。 下⾯给出求 带权拟阵最优⼦集 的贪⼼算法。该算法以 具有正权函数 W 的带权拟阵 M =(S ,I) 作为输⼊，经计算 后输出 M 的最优⼦集 A 。 0 4.8 贪⼼算法的理论基础 • Set gr e e d y (M ,W ) • {A = \u0000 ; • 将 S 中元素依权值 W （⼤者优先）组成优先队列； • w hi l e (S != \u0000 ) { • S . re m ove M a x (x); • i f (A ∪ {x} \u0000 I) A =A ∪ {x}; • } • re t urn A • } 0 4.8 贪⼼算法的理论基础 算法 gr e e d y 的计算时间复杂性为 。 引理 4.2 ( 拟阵的贪⼼选择性质 ) 设 M =(S ,I) 是具有权函数 W 的带权拟阵，且 S 中元素依 权值从⼤到⼩排列。⼜设 x \u0000 S 是 S 中第⼀个使得 {x} 是 独⽴⼦集的元素，则存在 S 的最优⼦集 A 使得 x \u0000 A 。 算法 gr e e d y 在以贪⼼选择构造最优⼦集 A 时，⾸次选 ⼊集合 A 中的元素 x 是单元素独⽴集中具有最⼤权的元 素。此时可能已经舍弃了 S 中部分元素。可以证明这些 被舍弃的元素不可能⽤于构造最优⼦集。 0 4.8 贪⼼算法的理论基础 引理 4.3 ： 设 M =(S ,I) 是拟阵。若 S 中元素 x 不是空集 \u0000 的 可扩展元素，则 x 也不可能是 S 中任⼀独⽴⼦集 A 的可扩 展元素。 引理 4.4( 拟阵的最优⼦结构性质 ) 设 x 是求带权拟阵 M ＝ (S ， I) 的最优⼦集的贪⼼算法 gr e e d y 所选择的 S 中的第⼀个元素。那么，原问题可简 化为求带权拟阵 M ’=(S ’,I’) 的 最优⼦集 问题，其中： S ’={y| y \u0000 S 且 {x,y} \u0000 I} I’={B| B \u0000 S -{x} 且 B ∪ {x} \u0000 I} M ’ 的权函数是 M 的权函数在 S’ 上的限制 ( 称 M’ 为 M 关 0 4.8 贪⼼算法的理论基础 定理 4.5( 带权拟阵贪⼼算法的正确性 ) 设 M ＝ (S ,I) 是具有权函数 W 的带权拟阵，算法 gre e dy 返回 M 的最优⼦集。 3 、任务时间表问题 给定⼀个 单位时间任务 的有限集 S 。关于 S 的⼀个 时 间表 ⽤于描述 S 中单位时间任务的执⾏次序。时间表中 第 1 个任务从时间 0 开始执⾏直⾄时间 1 结束，第 2 个任 务从时间 1 开始执⾏⾄时间 2 结束， … ，第 n 个任务从时 间 n-1 开始执⾏直⾄时间 n 结束。   0 4.6 最⼩⽣成树 利⽤最⼩⽣成树性质和数 学归纳法容易证明，上述 算法中的 边集合 T 始终包 含 G 的某棵最⼩⽣成树中 的边 。因此，在算法结束 时， T 中的所有边构成 G 的 ⼀棵最⼩⽣成树。 例如 ，对于右图中的带权 图，按 Prim 算法 选取边的 过程如下⻚图所示。 0 4.6 最⼩⽣成树 0 4.6 最⼩⽣成树 在上述 P ri m 算法中，还应当考虑 如何有效地找出满⾜条 件 i \u0000\u0000 S ,j \u0000\u0000 V -S ，且权 c [i ][j] 最⼩的边 (i ,j) 。实现这个⽬的的 较简单的办法是设置 2 个数组 c l os e s t 和 l ow c os t 。 在 P ri m 算法执⾏过程中，先找出 V -S 中使 l ow c os t 值最⼩ 的顶点 j ，然后根据数组 c l os e s t 选取边 (j ,c l os e s t [j ］ ) ，最后 将 j 添加到 S 中，并对 c l os e s t 和 l ow c os t 作必要的修改。 ⽤这个办法实现的 P ri m 算法所需的 计算时间 为 0 4.6 最⼩⽣成树 3 、 Kruskal算法 K rus ka l 算法构造 G 的最⼩⽣成树的 基本思想 是，⾸ 先将 G 的 n 个顶点看成 n 个孤⽴的连通分⽀。将所有的边 按权从⼩到⼤排序。然后从第⼀条边开始，依边权递 增的顺序查看每⼀条边，并按下述⽅法连接 2 个不同的 连通分⽀：当查看到第 k 条边 (v ,w ) 时，如果端点 v 和 w 分别是当前 2 个不同的连通分⽀ T1 和 T2 中的顶点时，就 ⽤边 (v ,w ) 将 T1 和 T2 连接成⼀个连通分⽀，然后继续查 看第 k+1 条边；如果端点 v 和 w 在当前的同⼀个连通分⽀ 中，就直接再查看第 k+1 条边。这个过程⼀直进⾏到只 剩下⼀个连通分⽀时为⽌。 0 4.6 最⼩⽣成树 例如， 对前⾯的连通带权图，按 K rus ka l 算法顺序得到的最⼩ ⽣成树上的边如下图所示。 0 4.6 最⼩⽣成树 关于 集合的⼀些基本运算 可⽤于实现 K rus ka l 算法。 按权的递增顺序查看等价于对 优先队列 执 ⾏ r e move M i n 运算。可以⽤ 堆 实现这个优先队列。 对⼀个由连通分⽀组成的集合不断进⾏修改，需要⽤ 到抽象数据类型 并查集 U n i on F i n d 所⽀持的基本运算。 当图的边数为 e 时， K rus ka l 算法所需的 计算时间 是 。当 时， K rus ka l 算法⽐ P ri m 算法差，但当 时， K rus ka l 算法却⽐ P ri m 算法好得多。 0 4.7 多机调度问题 多机调度问题 要求给出⼀种作业调度⽅案，使所给的 n 个作业在尽可能短的时间内由 m 台机器加⼯处理完 成。 这个问题是 N P 完全问题 ，到⽬前为⽌还没有有效的 解法。对于这⼀类问题 , ⽤ 贪⼼选择策略 有时可以设计 出较好的近似算法。 约定，每个作业均可在任何⼀台机器上加⼯处理，但未完⼯ 前不允许中断处理。作业不能拆分成更⼩的⼦作业。 0 4.7 多机调度问题 采⽤ 最⻓处理时间作业优先 的贪⼼选择策略可以设计 出解多机调度问题的较好的近似算法。 按此策略，当 时，只要将机器 i 的 [0, ti ] 时间区间 分配给作业 i 即可，算法只需要 O (1) 时间。 当 时，⾸先将 n 个作业依其所需的处理时间从⼤ 到⼩排序。然后依此顺序将作业分配给空闲的处理 机。算法所需的计算时间为 O( n l ogn ) 。 0 4.7 多机调度问题 例如， 设 7 个独⽴作业 {1,2,3,4,5,6,7} 由 3 台机 器 M1 ， M2 和 M3 加⼯处理。各作业所需的处理时间 分别为 {2,14,4,16,6,5,3} 。按算法 gr e e d y 产⽣的作业调 度如下图所示，所需的加⼯时间为 17 。 0 4.8 贪⼼算法的理论基础 借助于 拟阵 ⼯具，可建⽴关于贪⼼算法的较⼀般的理 论。这个理论对 确定何时使⽤贪⼼算法 可以得到问题 的整体最优解⼗分有⽤。 1 、拟阵 拟阵 M 定义为满⾜下⾯ 3 个条件的有序对 (S ,I) ： (1)S 是⾮空有限集。 (2)I 是 S 的⼀类具有遗传性质的独⽴⼦集族，即若 B \u0000 I ， 则 B 是 S 的独⽴⼦集，且 B 的任意⼦集也都是 S 的独⽴⼦ 集。空集 \u0000 必为 I 的成员。 (3)I 满⾜交换性质，即若 A \u0000 I,B \u0000 I 且 | A | <| B| ，则存在某⼀ 元素 x \u0000 B-A ，使得 A ∪ {x} \u0000 I 。 0 4.8 贪⼼算法的理论基础 例如， 设 S 是⼀给定矩阵中⾏向量的集合， I 是 S 的线 性独⽴⼦集族，则由线性空间理论容易证明 (S ,I) 是⼀ 拟阵。拟阵的另⼀个例⼦是⽆向图 G =(V ,E ) 的图拟阵 。 给定拟阵 M =(S ,I) ，对于 I 中的独⽴⼦集 A \u0000 I ，若 S 有 ⼀元素 x \u0000 A ，使得将 x 加⼊ A 后仍保持独⽴性，即 A ∪ {x} \u0000 I, 则称 x 为 A 的 可扩展元素 。 当拟阵 M 中的独⽴⼦集 A 没有可扩展元素时，称 A 为 极⼤独⽴⼦集 。 0 4.8 贪⼼算法的理论基础 下⾯的关于 极⼤独⽴⼦集 的性质是很有⽤的。 定理 4.1 ： 拟阵 M 中所有极⼤独⽴⼦集⼤⼩相同。 这个定理可以⽤反证法证明。 若对拟阵 M =(S ,I) 中的 S 指定权函数 W ，使得对于任 意 x \u0000 S ，有 W (x)>0 ，则称拟阵 M 为 带权拟阵 。依此权 函数， S 的任⼀⼦集 A 的权定义为 。 2 、关于带权拟阵的贪⼼算法 许多可以⽤贪⼼算法求解的问题可以表示为求带权拟 阵的 最⼤权独⽴⼦集问题 。 0 4.8 贪⼼算法的理论基础 给定带权拟阵 M =(S ,I) ，确定 S 的独⽴⼦集 A \u0000 I 使得 W (A ) 达到最⼤。这种使 W (A ) 最⼤的独⽴⼦集 A 称为拟 阵 M 的 最优⼦集 。由于 S 中任⼀元素 x 的权 W (x) 是正 的，因此， 最优⼦集也⼀定是极⼤独⽴⼦集 。 例如， 在最⼩⽣成树问题可以表示为确定带权拟阵 的最优⼦集问题。求带权拟阵的最优⼦集 A 的算法可⽤ 于解最⼩⽣成树问题。 下⾯给出求 带权拟阵最优⼦集 的贪⼼算法。该算法以 具有正权函数 W 的带权拟阵 M =(S ,I) 作为输⼊，经计算 后输出 M 的最优⼦集 A 。 0 4.8 贪⼼算法的理论基础 • Set gr e e d y (M ,W ) • {A = \u0000 ; • 将 S 中元素依权值 W （⼤者优先）组成优先队列； • w hi l e (S != \u0000 ) { • S . re m ove M a x (x); • i f (A ∪ {x} \u0000 I) A =A ∪ {x}; • } • re t urn A • } 0 4.8 贪⼼算法的理论基础 算法 gr e e d y 的计算时间复杂性为 。 引理 4.2 ( 拟阵的贪⼼选择性质 ) 设 M =(S ,I) 是具有权函数 W 的带权拟阵，且 S 中元素依 权值从⼤到⼩排列。⼜设 x \u0000 S 是 S 中第⼀个使得 {x} 是 独⽴⼦集的元素，则存在 S 的最优⼦集 A 使得 x \u0000 A 。 算法 gr e e d y 在以贪⼼选择构造最优⼦集 A 时，⾸次选 ⼊集合 A 中的元素 x 是单元素独⽴集中具有最⼤权的元 素。此时可能已经舍弃了 S 中部分元素。可以证明这些 被舍弃的元素不可能⽤于构造最优⼦集。 0 4.8 贪⼼算法的理论基础 引理 4.3 ： 设 M =(S ,I) 是拟阵。若 S 中元素 x 不是空集 \u0000 的 可扩展元素，则 x 也不可能是 S 中任⼀独⽴⼦集 A 的可扩 展元素。 引理 4.4( 拟阵的最优⼦结构性质 ) 设 x 是求带权拟阵 M ＝ (S ， I) 的最优⼦集的贪⼼算法 gr e e d y 所选择的 S 中的第⼀个元素。那么，原问题可简 化为求带权拟阵 M ’=(S ’,I’) 的 最优⼦集 问题，其中： S ’={y| y \u0000 S 且 {x,y} \u0000 I} I’={B| B \u0000 S -{x} 且 B ∪ {x} \u0000 I} M ’ 的权函数是 M 的权函数在 S’ 上的限制 ( 称 M’ 为 M 关 0 4.8 贪⼼算法的理论基础 定理 4.5( 带权拟阵贪⼼算法的正确性 ) 设 M ＝ (S ,I) 是具有权函数 W 的带权拟阵，算法 gre e dy 返回 M 的最优⼦集。 3 、任务时间表问题 给定⼀个 单位时间任务 的有限集 S 。关于 S 的⼀个 时 间表 ⽤于描述 S 中单位时间任务的执⾏次序。时间表中 第 1 个任务从时间 0 开始执⾏直⾄时间 1 结束，第 2 个任 务从时间 1 开始执⾏⾄时间 2 结束， … ，第 n 个任务从时 间 n-1 开始执⾏直⾄时间 n 结束。   0 4.6 最⼩⽣成树 利⽤最⼩⽣成树性质和数 学归纳法容易证明，上述 算法中的 边集合 T 始终包 含 G 的某棵最⼩⽣成树中 的边 。因此，在算法结束 时， T 中的所有边构成 G 的 ⼀棵最⼩⽣成树。 例如 ，对于右图中的带权 图，按 Prim 算法 选取边的 过程如下⻚图所示。 0 4.6 最⼩⽣成树 0 4.6 最⼩⽣成树 在上述 P ri m 算法中，还应当考虑 如何有效地找出满⾜条 件 i \u0000\u0000 S ,j \u0000\u0000 V -S ，且权 c [i ][j] 最⼩的边 (i ,j) 。实现这个⽬的的 较简单的办法是设置 2 个数组 c l os e s t 和 l ow c os t 。 在 P ri m 算法执⾏过程中，先找出 V -S 中使 l ow c os t 值最⼩ 的顶点 j ，然后根据数组 c l os e s t 选取边 (j ,c l os e s t [j ］ ) ，最后 将 j 添加到 S 中，并对 c l os e s t 和 l ow c os t 作必要的修改。 ⽤这个办法实现的 P ri m 算法所需的 计算时间 为 0 4.6 最⼩⽣成树 3 、 Kruskal算法 K rus ka l 算法构造 G 的最⼩⽣成树的 基本思想 是，⾸ 先将 G 的 n 个顶点看成 n 个孤⽴的连通分⽀。将所有的边 按权从⼩到⼤排序。然后从第⼀条边开始，依边权递 增的顺序查看每⼀条边，并按下述⽅法连接 2 个不同的 连通分⽀：当查看到第 k 条边 (v ,w ) 时，如果端点 v 和 w 分别是当前 2 个不同的连通分⽀ T1 和 T2 中的顶点时，就 ⽤边 (v ,w ) 将 T1 和 T2 连接成⼀个连通分⽀，然后继续查 看第 k+1 条边；如果端点 v 和 w 在当前的同⼀个连通分⽀ 中，就直接再查看第 k+1 条边。这个过程⼀直进⾏到只 剩下⼀个连通分⽀时为⽌。 0 4.6 最⼩⽣成树 例如， 对前⾯的连通带权图，按 K rus ka l 算法顺序得到的最⼩ ⽣成树上的边如下图所示。 0 4.6 最⼩⽣成树 关于 集合的⼀些基本运算 可⽤于实现 K rus ka l 算法。 按权的递增顺序查看等价于对 优先队列 执 ⾏ r e move M i n 运算。可以⽤ 堆 实现这个优先队列。 对⼀个由连通分⽀组成的集合不断进⾏修改，需要⽤ 到抽象数据类型 并查集 U n i on F i n d 所⽀持的基本运算。 当图的边数为 e 时， K rus ka l 算法所需的 计算时间 是 。当 时， K rus ka l 算法⽐ P ri m 算法差，但当 时， K rus ka l 算法却⽐ P ri m 算法好得多。 0 4.7 多机调度问题 多机调度问题 要求给出⼀种作业调度⽅案，使所给的 n 个作业在尽可能短的时间内由 m 台机器加⼯处理完 成。 这个问题是 N P 完全问题 ，到⽬前为⽌还没有有效的 解法。对于这⼀类问题 , ⽤ 贪⼼选择策略 有时可以设计 出较好的近似算法。 约定，每个作业均可在任何⼀台机器上加⼯处理，但未完⼯ 前不允许中断处理。作业不能拆分成更⼩的⼦作业。 0 4.7 多机调度问题 采⽤ 最⻓处理时间作业优先 的贪⼼选择策略可以设计 出解多机调度问题的较好的近似算法。 按此策略，当 时，只要将机器 i 的 [0, ti ] 时间区间 分配给作业 i 即可，算法只需要 O (1) 时间。 当 时，⾸先将 n 个作业依其所需的处理时间从⼤ 到⼩排序。然后依此顺序将作业分配给空闲的处理 机。算法所需的计算时间为 O( n l ogn ) 。 0 4.7 多机调度问题 例如， 设 7 个独⽴作业 {1,2,3,4,5,6,7} 由 3 台机 器 M1 ， M2 和 M3 加⼯处理。各作业所需的处理时间 分别为 {2,14,4,16,6,5,3} 。按算法 gr e e d y 产⽣的作业调 度如下图所示，所需的加⼯时间为 17 。 0 4.8 贪⼼算法的理论基础 借助于 拟阵 ⼯具，可建⽴关于贪⼼算法的较⼀般的理 论。这个理论对 确定何时使⽤贪⼼算法 可以得到问题 的整体最优解⼗分有⽤。 1 、拟阵 拟阵 M 定义为满⾜下⾯ 3 个条件的有序对 (S ,I) ： (1)S 是⾮空有限集。 (2)I 是 S 的⼀类具有遗传性质的独⽴⼦集族，即若 B \u0000 I ， 则 B 是 S 的独⽴⼦集，且 B 的任意⼦集也都是 S 的独⽴⼦ 集。空集 \u0000 必为 I 的成员。 (3)I 满⾜交换性质，即若 A \u0000 I,B \u0000 I 且 | A | <| B| ，则存在某⼀ 元素 x \u0000 B-A ，使得 A ∪ {x} \u0000 I 。 0 4.8 贪⼼算法的理论基础 例如， 设 S 是⼀给定矩阵中⾏向量的集合， I 是 S 的线 性独⽴⼦集族，则由线性空间理论容易证明 (S ,I) 是⼀ 拟阵。拟阵的另⼀个例⼦是⽆向图 G =(V ,E ) 的图拟阵 。 给定拟阵 M =(S ,I) ，对于 I 中的独⽴⼦集 A \u0000 I ，若 S 有 ⼀元素 x \u0000 A ，使得将 x 加⼊ A 后仍保持独⽴性，即 A ∪ {x} \u0000 I, 则称 x 为 A 的 可扩展元素 。 当拟阵 M 中的独⽴⼦集 A 没有可扩展元素时，称 A 为 极⼤独⽴⼦集 。 0 4.8 贪⼼算法的理论基础 下⾯的关于 极⼤独⽴⼦集 的性质是很有⽤的。 定理 4.1 ： 拟阵 M 中所有极⼤独⽴⼦集⼤⼩相同。 这个定理可以⽤反证法证明。 若对拟阵 M =(S ,I) 中的 S 指定权函数 W ，使得对于任 意 x \u0000 S ，有 W (x)>0 ，则称拟阵 M 为 带权拟阵 。依此权 函数， S 的任⼀⼦集 A 的权定义为 。 2 、关于带权拟阵的贪⼼算法 许多可以⽤贪⼼算法求解的问题可以表示为求带权拟 阵的 最⼤权独⽴⼦集问题 。 0 4.8 贪⼼算法的理论基础 给定带权拟阵 M =(S ,I) ，确定 S 的独⽴⼦集 A \u0000 I 使得 W (A ) 达到最⼤。这种使 W (A ) 最⼤的独⽴⼦集 A 称为拟 阵 M 的 最优⼦集 。由于 S 中任⼀元素 x 的权 W (x) 是正 的，因此， 最优⼦集也⼀定是极⼤独⽴⼦集 。 例如， 在最⼩⽣成树问题可以表示为确定带权拟阵 的最优⼦集问题。求带权拟阵的最优⼦集 A 的算法可⽤ 于解最⼩⽣成树问题。 下⾯给出求 带权拟阵最优⼦集 的贪⼼算法。该算法以 具有正权函数 W 的带权拟阵 M =(S ,I) 作为输⼊，经计算 后输出 M 的最优⼦集 A 。 0 4.8 贪⼼算法的理论基础 • Set gr e e d y (M ,W ) • {A = \u0000 ; • 将 S 中元素依权值 W （⼤者优先）组成优先队列； • w hi l e (S != \u0000 ) { • S . re m ove M a x (x); • i f (A ∪ {x} \u0000 I) A =A ∪ {x}; • } • re t urn A • } 0 4.8 贪⼼算法的理论基础 算法 gr e e d y 的计算时间复杂性为 。 引理 4.2 ( 拟阵的贪⼼选择性质 ) 设 M =(S ,I) 是具有权函数 W 的带权拟阵，且 S 中元素依 权值从⼤到⼩排列。⼜设 x \u0000 S 是 S 中第⼀个使得 {x} 是 独⽴⼦集的元素，则存在 S 的最优⼦集 A 使得 x \u0000 A 。 算法 gr e e d y 在以贪⼼选择构造最优⼦集 A 时，⾸次选 ⼊集合 A 中的元素 x 是单元素独⽴集中具有最⼤权的元 素。此时可能已经舍弃了 S 中部分元素。可以证明这些 被舍弃的元素不可能⽤于构造最优⼦集。 0 4.8 贪⼼算法的理论基础 引理 4.3 ： 设 M =(S ,I) 是拟阵。若 S 中元素 x 不是空集 \u0000 的 可扩展元素，则 x 也不可能是 S 中任⼀独⽴⼦集 A 的可扩 展元素。 引理 4.4( 拟阵的最优⼦结构性质 ) 设 x 是求带权拟阵 M ＝ (S ， I) 的最优⼦集的贪⼼算法 gr e e d y 所选择的 S 中的第⼀个元素。那么，原问题可简 化为求带权拟阵 M ’=(S ’,I’) 的 最优⼦集 问题，其中： S ’={y| y \u0000 S 且 {x,y} \u0000 I} I’={B| B \u0000 S -{x} 且 B ∪ {x} \u0000 I} M ’ 的权函数是 M 的权函数在 S’ 上的限制 ( 称 M’ 为 M 关 0 4.8 贪⼼算法的理论基础 定理 4.5( 带权拟阵贪⼼算法的正确性 ) 设 M ＝ (S ,I) 是具有权函数 W 的带权拟阵，算法 gre e dy 返回 M 的最优⼦集。 3 、任务时间表问题 给定⼀个 单位时间任务 的有限集 S 。关于 S 的⼀个 时 间表 ⽤于描述 S 中单位时间任务的执⾏次序。时间表中 第 1 个任务从时间 0 开始执⾏直⾄时间 1 结束，第 2 个任 务从时间 1 开始执⾏⾄时间 2 结束， … ，第 n 个任务从时 间 n-1 开始执⾏直⾄时间 n 结束。   0 4.6 最⼩⽣成树 利⽤最⼩⽣成树性质和数 学归纳法容易证明，上述 算法中的 边集合 T 始终包 含 G 的某棵最⼩⽣成树中 的边 。因此，在算法结束 时， T 中的所有边构成 G 的 ⼀棵最⼩⽣成树。 例如 ，对于右图中的带权 图，按 Prim 算法 选取边的 过程如下⻚图所示。 0 4.6 最⼩⽣成树 0 4.6 最⼩⽣成树 在上述 P ri m 算法中，还应当考虑 如何有效地找出满⾜条 件 i \u0000\u0000 S ,j \u0000\u0000 V -S ，且权 c [i ][j] 最⼩的边 (i ,j) 。实现这个⽬的的 较简单的办法是设置 2 个数组 c l os e s t 和 l ow c os t 。 在 P ri m 算法执⾏过程中，先找出 V -S 中使 l ow c os t 值最⼩ 的顶点 j ，然后根据数组 c l os e s t 选取边 (j ,c l os e s t [j ］ ) ，最后 将 j 添加到 S 中，并对 c l os e s t 和 l ow c os t 作必要的修改。 ⽤这个办法实现的 P ri m 算法所需的 计算时间 为 0 4.6 最⼩⽣成树 3 、 Kruskal算法 K rus ka l 算法构造 G 的最⼩⽣成树的 基本思想 是，⾸ 先将 G 的 n 个顶点看成 n 个孤⽴的连通分⽀。将所有的边 按权从⼩到⼤排序。然后从第⼀条边开始，依边权递 增的顺序查看每⼀条边，并按下述⽅法连接 2 个不同的 连通分⽀：当查看到第 k 条边 (v ,w ) 时，如果端点 v 和 w 分别是当前 2 个不同的连通分⽀ T1 和 T2 中的顶点时，就 ⽤边 (v ,w ) 将 T1 和 T2 连接成⼀个连通分⽀，然后继续查 看第 k+1 条边；如果端点 v 和 w 在当前的同⼀个连通分⽀ 中，就直接再查看第 k+1 条边。这个过程⼀直进⾏到只 剩下⼀个连通分⽀时为⽌。 0 4.6 最⼩⽣成树 例如， 对前⾯的连通带权图，按 K rus ka l 算法顺序得到的最⼩ ⽣成树上的边如下图所示。 0 4.6 最⼩⽣成树 关于 集合的⼀些基本运算 可⽤于实现 K rus ka l 算法。 按权的递增顺序查看等价于对 优先队列 执 ⾏ r e move M i n 运算。可以⽤ 堆 实现这个优先队列。 对⼀个由连通分⽀组成的集合不断进⾏修改，需要⽤ 到抽象数据类型 并查集 U n i on F i n d 所⽀持的基本运算。 当图的边数为 e 时， K rus ka l 算法所需的 计算时间 是 。当 时， K rus ka l 算法⽐ P ri m 算法差，但当 时， K rus ka l 算法却⽐ P ri m 算法好得多。 0 4.7 多机调度问题 多机调度问题 要求给出⼀种作业调度⽅案，使所给的 n 个作业在尽可能短的时间内由 m 台机器加⼯处理完 成。 这个问题是 N P 完全问题 ，到⽬前为⽌还没有有效的 解法。对于这⼀类问题 , ⽤ 贪⼼选择策略 有时可以设计 出较好的近似算法。 约定，每个作业均可在任何⼀台机器上加⼯处理，但未完⼯ 前不允许中断处理。作业不能拆分成更⼩的⼦作业。 0 4.7 多机调度问题 采⽤ 最⻓处理时间作业优先 的贪⼼选择策略可以设计 出解多机调度问题的较好的近似算法。 按此策略，当 时，只要将机器 i 的 [0, ti ] 时间区间 分配给作业 i 即可，算法只需要 O (1) 时间。 当 时，⾸先将 n 个作业依其所需的处理时间从⼤ 到⼩排序。然后依此顺序将作业分配给空闲的处理 机。算法所需的计算时间为 O( n l ogn ) 。 0 4.7 多机调度问题 例如， 设 7 个独⽴作业 {1,2,3,4,5,6,7} 由 3 台机 器 M1 ， M2 和 M3 加⼯处理。各作业所需的处理时间 分别为 {2,14,4,16,6,5,3} 。按算法 gr e e d y 产⽣的作业调 度如下图所示，所需的加⼯时间为 17 。 0 4.8 贪⼼算法的理论基础 借助于 拟阵 ⼯具，可建⽴关于贪⼼算法的较⼀般的理 论。这个理论对 确定何时使⽤贪⼼算法 可以得到问题 的整体最优解⼗分有⽤。 1 、拟阵 拟阵 M 定义为满⾜下⾯ 3 个条件的有序对 (S ,I) ： (1)S 是⾮空有限集。 (2)I 是 S 的⼀类具有遗传性质的独⽴⼦集族，即若 B \u0000 I ， 则 B 是 S 的独⽴⼦集，且 B 的任意⼦集也都是 S 的独⽴⼦ 集。空集 \u0000 必为 I 的成员。 (3)I 满⾜交换性质，即若 A \u0000 I,B \u0000 I 且 | A | <| B| ，则存在某⼀ 元素 x \u0000 B-A ，使得 A ∪ {x} \u0000 I 。 0 4.8 贪⼼算法的理论基础 例如， 设 S 是⼀给定矩阵中⾏向量的集合， I 是 S 的线 性独⽴⼦集族，则由线性空间理论容易证明 (S ,I) 是⼀ 拟阵。拟阵的另⼀个例⼦是⽆向图 G =(V ,E ) 的图拟阵 。 给定拟阵 M =(S ,I) ，对于 I 中的独⽴⼦集 A \u0000 I ，若 S 有 ⼀元素 x \u0000 A ，使得将 x 加⼊ A 后仍保持独⽴性，即 A ∪ {x} \u0000 I, 则称 x 为 A 的 可扩展元素 。 当拟阵 M 中的独⽴⼦集 A 没有可扩展元素时，称 A 为 极⼤独⽴⼦集 。 0 4.8 贪⼼算法的理论基础 下⾯的关于 极⼤独⽴⼦集 的性质是很有⽤的。 定理 4.1 ： 拟阵 M 中所有极⼤独⽴⼦集⼤⼩相同。 这个定理可以⽤反证法证明。 若对拟阵 M =(S ,I) 中的 S 指定权函数 W ，使得对于任 意 x \u0000 S ，有 W (x)>0 ，则称拟阵 M 为 带权拟阵 。依此权 函数， S 的任⼀⼦集 A 的权定义为 。 2 、关于带权拟阵的贪⼼算法 许多可以⽤贪⼼算法求解的问题可以表示为求带权拟 阵的 最⼤权独⽴⼦集问题 。 0 4.8 贪⼼算法的理论基础 给定带权拟阵 M =(S ,I) ，确定 S 的独⽴⼦集 A \u0000 I 使得 W (A ) 达到最⼤。这种使 W (A ) 最⼤的独⽴⼦集 A 称为拟 阵 M 的 最优⼦集 。由于 S 中任⼀元素 x 的权 W (x) 是正 的，因此， 最优⼦集也⼀定是极⼤独⽴⼦集 。 例如， 在最⼩⽣成树问题可以表示为确定带权拟阵 的最优⼦集问题。求带权拟阵的最优⼦集 A 的算法可⽤ 于解最⼩⽣成树问题。 下⾯给出求 带权拟阵最优⼦集 的贪⼼算法。该算法以 具有正权函数 W 的带权拟阵 M =(S ,I) 作为输⼊，经计算 后输出 M 的最优⼦集 A 。 0 4.8 贪⼼算法的理论基础 • Set gr e e d y (M ,W ) • {A = \u0000 ; • 将 S 中元素依权值 W （⼤者优先）组成优先队列； • w hi l e (S != \u0000 ) { • S . re m ove M a x (x); • i f (A ∪ {x} \u0000 I) A =A ∪ {x}; • } • re t urn A • } 0 4.8 贪⼼算法的理论基础 算法 gr e e d y 的计算时间复杂性为 。 引理 4.2 ( 拟阵的贪⼼选择性质 ) 设 M =(S ,I) 是具有权函数 W 的带权拟阵，且 S 中元素依 权值从⼤到⼩排列。⼜设 x \u0000 S 是 S 中第⼀个使得 {x} 是 独⽴⼦集的元素，则存在 S 的最优⼦集 A 使得 x \u0000 A 。 算法 gr e e d y 在以贪⼼选择构造最优⼦集 A 时，⾸次选 ⼊集合 A 中的元素 x 是单元素独⽴集中具有最⼤权的元 素。此时可能已经舍弃了 S 中部分元素。可以证明这些 被舍弃的元素不可能⽤于构造最优⼦集。 0 4.8 贪⼼算法的理论基础 引理 4.3 ： 设 M =(S ,I) 是拟阵。若 S 中元素 x 不是空集 \u0000 的 可扩展元素，则 x 也不可能是 S 中任⼀独⽴⼦集 A 的可扩 展元素。 引理 4.4( 拟阵的最优⼦结构性质 ) 设 x 是求带权拟阵 M ＝ (S ， I) 的最优⼦集的贪⼼算法 gr e e d y 所选择的 S 中的第⼀个元素。那么，原问题可简 化为求带权拟阵 M ’=(S ’,I’) 的 最优⼦集 问题，其中： S ’={y| y \u0000 S 且 {x,y} \u0000 I} I’={B| B \u0000 S -{x} 且 B ∪ {x} \u0000 I} M ’ 的权函数是 M 的权函数在 S’ 上的限制 ( 称 M’ 为 M 关 0 4.8 贪⼼算法的理论基础 定理 4.5( 带权拟阵贪⼼算法的正确性 ) 设 M ＝ (S ,I) 是具有权函数 W 的带权拟阵，算法 gre e dy 返回 M 的最优⼦集。 3 、任务时间表问题 给定⼀个 单位时间任务 的有限集 S 。关于 S 的⼀个 时 间表 ⽤于描述 S 中单位时间任务的执⾏次序。时间表中 第 1 个任务从时间 0 开始执⾏直⾄时间 1 结束，第 2 个任 务从时间 1 开始执⾏⾄时间 2 结束， … ，第 n 个任务从时 间 n-1 开始执⾏直⾄时间 n 结束。   0 4.8 贪⼼算法的理论基础 具有 截⽌时间 和 误时惩罚 的单位时间任务时间表问题 可描述如下。 (1) n 个单位时间任务的集合 S ={1,2,…,n} ； (2) 任务 i 的截⽌时间 ,1 ≤ i ≤ n,1 ≤ ≤ n ，即要求任务 i 在时 间 之前结束； (3) 任务 i 的误时惩罚 ,1 ≤ i ≤ n, 即任务 i 未在时间 之前结 束将招致的 惩罚；若按时完成则⽆惩罚。 任务时间表问题 要求确定 S 的⼀个时间表（最优时间 表）使得总误时惩罚达到最⼩。 0 4.8 贪⼼算法的理论基础 这个问题看上去很复杂，然⽽借助于 拟阵 ，可以⽤ 带 权拟阵的贪⼼算法 有效求解。 对于⼀个给定的 S 的时间表，在截⽌时间之前完成的 任务称为 及时任务 ，在截⽌时间之后完成的任务称为 误时任务 。 S 的任⼀时间表可以调整成 及时优先形式 ，即其中所 有及时任务先于误时任务，⽽不影响原时间表中各任 务的及时或误时性质。 类似地，还可将 S 的任⼀时间表调整成为 规范形式 ， 其中及时任务先于误时任务，且及时任务依其截⽌时 间的⾮减序排列。 0 4.8 贪⼼算法的理论基础 ⾸先可将时间表调整为及时优先形式，然后再进⼀步 调整及时任务的次序。 任务时间表问题 等价于 确定最优时间表中 及时任务⼦ 集 A 的问题。⼀旦确定了及时任务⼦集 A ，将 A 中各任 务依其截⽌时间的⾮减序列出，然后再以任意次序列 出误时任务，即 S -A 中各任务，由此产⽣ S 的⼀个规范 的最优时间表。 对时间 t =1,2,…,n ， 设 (A ) 是任务⼦集 A 中所有截⽌时 间是 t 或更早的任务数。考察任务⼦集 A 的独⽴性。 0 4.8 贪⼼算法的理论基础 引理 4.6 ： 对于 S 的任⼀任务⼦集 A ，下⾯的各命题是等 价的。 (1) 任务⼦集 A 是独⽴⼦集。 (2) 对于 t =1,2,…,n ， (A ) ≤ t 。 (3) 若 A 中任务依其截⽌时间⾮减序排列，则 A 中所有任 务都是及时的。 任务时间表问题 要求使总误时惩罚达到最⼩，这等价 于使任务时间表中的及时任务的惩罚值之和达到最 ⼤。下⾯的 定理 表明可⽤带权拟阵的贪⼼算法解任务 时间表问题。 0 4.8 贪⼼算法的理论基础 定理 4.7 ： 设 S 是带有截⽌时间的单位时间任务集， I 是 S 的所有独⽴任务⼦集构成的集合。则有序对 (S ,I) 是拟阵。 由 定理 4.5 可知，⽤带权拟阵的贪⼼算法可以求得最⼤ 权 ( 惩罚 ) 独⽴任务⼦集 A ，以 A 作为最优时间表中的及时 任务⼦集，容易构造最优时间表。 任务时间表问题的贪⼼算法的 计算时间复杂性 是 。其中 f(n) 是⽤于检测任务⼦集 A 的独⽴性所需的时间。 ⽤引理 4.6 中性质 (2) 容易设计⼀个 时间算法来 检测任务⼦集的独⽴性。因此，整个算法的 计算时间 为 。具体算法 gr e e d yJob 可描述如 P 130 。 0 4.8 贪⼼算法的理论基础 ⽤抽象数据类型并查集 U n i on F i n d 可对上述算法作进 ⼀步改进。如果不计预处理的时间，改进后的算法 fas te r Job 所需的 计算时间 为 。 0 4.8 贪⼼算法的理论基础 具有 截⽌时间 和 误时惩罚 的单位时间任务时间表问题 可描述如下。 (1) n 个单位时间任务的集合 S ={1,2,…,n} ； (2) 任务 i 的截⽌时间 ,1 ≤ i ≤ n,1 ≤ ≤ n ，即要求任务 i 在时 间 之前结束； (3) 任务 i 的误时惩罚 ,1 ≤ i ≤ n, 即任务 i 未在时间 之前结 束将招致的 惩罚；若按时完成则⽆惩罚。 任务时间表问题 要求确定 S 的⼀个时间表（最优时间 表）使得总误时惩罚达到最⼩。 0 4.8 贪⼼算法的理论基础 这个问题看上去很复杂，然⽽借助于 拟阵 ，可以⽤ 带 权拟阵的贪⼼算法 有效求解。 对于⼀个给定的 S 的时间表，在截⽌时间之前完成的 任务称为 及时任务 ，在截⽌时间之后完成的任务称为 误时任务 。 S 的任⼀时间表可以调整成 及时优先形式 ，即其中所 有及时任务先于误时任务，⽽不影响原时间表中各任 务的及时或误时性质。 类似地，还可将 S 的任⼀时间表调整成为 规范形式 ， 其中及时任务先于误时任务，且及时任务依其截⽌时 间的⾮减序排列。 0 4.8 贪⼼算法的理论基础 ⾸先可将时间表调整为及时优先形式，然后再进⼀步 调整及时任务的次序。 任务时间表问题 等价于 确定最优时间表中 及时任务⼦ 集 A 的问题。⼀旦确定了及时任务⼦集 A ，将 A 中各任 务依其截⽌时间的⾮减序列出，然后再以任意次序列 出误时任务，即 S -A 中各任务，由此产⽣ S 的⼀个规范 的最优时间表。 对时间 t =1,2,…,n ， 设 (A ) 是任务⼦集 A 中所有截⽌时 间是 t 或更早的任务数。考察任务⼦集 A 的独⽴性。 0 4.8 贪⼼算法的理论基础 引理 4.6 ： 对于 S 的任⼀任务⼦集 A ，下⾯的各命题是等 价的。 (1) 任务⼦集 A 是独⽴⼦集。 (2) 对于 t =1,2,…,n ， (A ) ≤ t 。 (3) 若 A 中任务依其截⽌时间⾮减序排列，则 A 中所有任 务都是及时的。 任务时间表问题 要求使总误时惩罚达到最⼩，这等价 于使任务时间表中的及时任务的惩罚值之和达到最 ⼤。下⾯的 定理 表明可⽤带权拟阵的贪⼼算法解任务 时间表问题。 0 4.8 贪⼼算法的理论基础 定理 4.7 ： 设 S 是带有截⽌时间的单位时间任务集， I 是 S 的所有独⽴任务⼦集构成的集合。则有序对 (S ,I) 是拟阵。 由 定理 4.5 可知，⽤带权拟阵的贪⼼算法可以求得最⼤ 权 ( 惩罚 ) 独⽴任务⼦集 A ，以 A 作为最优时间表中的及时 任务⼦集，容易构造最优时间表。 任务时间表问题的贪⼼算法的 计算时间复杂性 是 。其中 f(n) 是⽤于检测任务⼦集 A 的独⽴性所需的时间。 ⽤引理 4.6 中性质 (2) 容易设计⼀个 时间算法来 检测任务⼦集的独⽴性。因此，整个算法的 计算时间 为 。具体算法 gr e e d yJob 可描述如 P 130 。 0 4.8 贪⼼算法的理论基础 ⽤抽象数据类型并查集 U n i on F i n d 可对上述算法作进 ⼀步改进。如果不计预处理的时间，改进后的算法 fas te r Job 所需的 计算时间 为 。 0 4.8 贪⼼算法的理论基础 具有 截⽌时间 和 误时惩罚 的单位时间任务时间表问题 可描述如下。 (1) n 个单位时间任务的集合 S ={1,2,…,n} ； (2) 任务 i 的截⽌时间 ,1 ≤ i ≤ n,1 ≤ ≤ n ，即要求任务 i 在时 间 之前结束； (3) 任务 i 的误时惩罚 ,1 ≤ i ≤ n, 即任务 i 未在时间 之前结 束将招致的 惩罚；若按时完成则⽆惩罚。 任务时间表问题 要求确定 S 的⼀个时间表（最优时间 表）使得总误时惩罚达到最⼩。 0 4.8 贪⼼算法的理论基础 这个问题看上去很复杂，然⽽借助于 拟阵 ，可以⽤ 带 权拟阵的贪⼼算法 有效求解。 对于⼀个给定的 S 的时间表，在截⽌时间之前完成的 任务称为 及时任务 ，在截⽌时间之后完成的任务称为 误时任务 。 S 的任⼀时间表可以调整成 及时优先形式 ，即其中所 有及时任务先于误时任务，⽽不影响原时间表中各任 务的及时或误时性质。 类似地，还可将 S 的任⼀时间表调整成为 规范形式 ， 其中及时任务先于误时任务，且及时任务依其截⽌时 间的⾮减序排列。 0 4.8 贪⼼算法的理论基础 ⾸先可将时间表调整为及时优先形式，然后再进⼀步 调整及时任务的次序。 任务时间表问题 等价于 确定最优时间表中 及时任务⼦ 集 A 的问题。⼀旦确定了及时任务⼦集 A ，将 A 中各任 务依其截⽌时间的⾮减序列出，然后再以任意次序列 出误时任务，即 S -A 中各任务，由此产⽣ S 的⼀个规范 的最优时间表。 对时间 t =1,2,…,n ， 设 (A ) 是任务⼦集 A 中所有截⽌时 间是 t 或更早的任务数。考察任务⼦集 A 的独⽴性。 0 4.8 贪⼼算法的理论基础 引理 4.6 ： 对于 S 的任⼀任务⼦集 A ，下⾯的各命题是等 价的。 (1) 任务⼦集 A 是独⽴⼦集。 (2) 对于 t =1,2,…,n ， (A ) ≤ t 。 (3) 若 A 中任务依其截⽌时间⾮减序排列，则 A 中所有任 务都是及时的。 任务时间表问题 要求使总误时惩罚达到最⼩，这等价 于使任务时间表中的及时任务的惩罚值之和达到最 ⼤。下⾯的 定理 表明可⽤带权拟阵的贪⼼算法解任务 时间表问题。 0 4.8 贪⼼算法的理论基础 定理 4.7 ： 设 S 是带有截⽌时间的单位时间任务集， I 是 S 的所有独⽴任务⼦集构成的集合。则有序对 (S ,I) 是拟阵。 由 定理 4.5 可知，⽤带权拟阵的贪⼼算法可以求得最⼤ 权 ( 惩罚 ) 独⽴任务⼦集 A ，以 A 作为最优时间表中的及时 任务⼦集，容易构造最优时间表。 任务时间表问题的贪⼼算法的 计算时间复杂性 是 。其中 f(n) 是⽤于检测任务⼦集 A 的独⽴性所需的时间。 ⽤引理 4.6 中性质 (2) 容易设计⼀个 时间算法来 检测任务⼦集的独⽴性。因此，整个算法的 计算时间 为 。具体算法 gr e e d yJob 可描述如 P 130 。 0 4.8 贪⼼算法的理论基础 ⽤抽象数据类型并查集 U n i on F i n d 可对上述算法作进 ⼀步改进。如果不计预处理的时间，改进后的算法 fas te r Job 所需的 计算时间 为 。 0 4.8 贪⼼算法的理论基础 具有 截⽌时间 和 误时惩罚 的单位时间任务时间表问题 可描述如下。 (1) n 个单位时间任务的集合 S ={1,2,…,n} ； (2) 任务 i 的截⽌时间 ,1 ≤ i ≤ n,1 ≤ ≤ n ，即要求任务 i 在时 间 之前结束； (3) 任务 i 的误时惩罚 ,1 ≤ i ≤ n, 即任务 i 未在时间 之前结 束将招致的 惩罚；若按时完成则⽆惩罚。 任务时间表问题 要求确定 S 的⼀个时间表（最优时间 表）使得总误时惩罚达到最⼩。 0 4.8 贪⼼算法的理论基础 这个问题看上去很复杂，然⽽借助于 拟阵 ，可以⽤ 带 权拟阵的贪⼼算法 有效求解。 对于⼀个给定的 S 的时间表，在截⽌时间之前完成的 任务称为 及时任务 ，在截⽌时间之后完成的任务称为 误时任务 。 S 的任⼀时间表可以调整成 及时优先形式 ，即其中所 有及时任务先于误时任务，⽽不影响原时间表中各任 务的及时或误时性质。 类似地，还可将 S 的任⼀时间表调整成为 规范形式 ， 其中及时任务先于误时任务，且及时任务依其截⽌时 间的⾮减序排列。 0 4.8 贪⼼算法的理论基础 ⾸先可将时间表调整为及时优先形式，然后再进⼀步 调整及时任务的次序。 任务时间表问题 等价于 确定最优时间表中 及时任务⼦ 集 A 的问题。⼀旦确定了及时任务⼦集 A ，将 A 中各任 务依其截⽌时间的⾮减序列出，然后再以任意次序列 出误时任务，即 S -A 中各任务，由此产⽣ S 的⼀个规范 的最优时间表。 对时间 t =1,2,…,n ， 设 (A ) 是任务⼦集 A 中所有截⽌时 间是 t 或更早的任务数。考察任务⼦集 A 的独⽴性。 0 4.8 贪⼼算法的理论基础 引理 4.6 ： 对于 S 的任⼀任务⼦集 A ，下⾯的各命题是等 价的。 (1) 任务⼦集 A 是独⽴⼦集。 (2) 对于 t =1,2,…,n ， (A ) ≤ t 。 (3) 若 A 中任务依其截⽌时间⾮减序排列，则 A 中所有任 务都是及时的。 任务时间表问题 要求使总误时惩罚达到最⼩，这等价 于使任务时间表中的及时任务的惩罚值之和达到最 ⼤。下⾯的 定理 表明可⽤带权拟阵的贪⼼算法解任务 时间表问题。 0 4.8 贪⼼算法的理论基础 定理 4.7 ： 设 S 是带有截⽌时间的单位时间任务集， I 是 S 的所有独⽴任务⼦集构成的集合。则有序对 (S ,I) 是拟阵。 由 定理 4.5 可知，⽤带权拟阵的贪⼼算法可以求得最⼤ 权 ( 惩罚 ) 独⽴任务⼦集 A ，以 A 作为最优时间表中的及时 任务⼦集，容易构造最优时间表。 任务时间表问题的贪⼼算法的 计算时间复杂性 是 。其中 f(n) 是⽤于检测任务⼦集 A 的独⽴性所需的时间。 ⽤引理 4.6 中性质 (2) 容易设计⼀个 时间算法来 检测任务⼦集的独⽴性。因此，整个算法的 计算时间 为 。具体算法 gr e e d yJob 可描述如 P 130 。 0 4.8 贪⼼算法的理论基础 ⽤抽象数据类型并查集 U n i on F i n d 可对上述算法作进 ⼀步改进。如果不计预处理的时间，改进后的算法 fas te r Job 所需的 计算时间 为 。 0 4.8 贪⼼算法的理论基础 具有 截⽌时间 和 误时惩罚 的单位时间任务时间表问题 可描述如下。 (1) n 个单位时间任务的集合 S ={1,2,…,n} ； (2) 任务 i 的截⽌时间 ,1 ≤ i ≤ n,1 ≤ ≤ n ，即要求任务 i 在时 间 之前结束； (3) 任务 i 的误时惩罚 ,1 ≤ i ≤ n, 即任务 i 未在时间 之前结 束将招致的 惩罚；若按时完成则⽆惩罚。 任务时间表问题 要求确定 S 的⼀个时间表（最优时间 表）使得总误时惩罚达到最⼩。 0 4.8 贪⼼算法的理论基础 这个问题看上去很复杂，然⽽借助于 拟阵 ，可以⽤ 带 权拟阵的贪⼼算法 有效求解。 对于⼀个给定的 S 的时间表，在截⽌时间之前完成的 任务称为 及时任务 ，在截⽌时间之后完成的任务称为 误时任务 。 S 的任⼀时间表可以调整成 及时优先形式 ，即其中所 有及时任务先于误时任务，⽽不影响原时间表中各任 务的及时或误时性质。 类似地，还可将 S 的任⼀时间表调整成为 规范形式 ， 其中及时任务先于误时任务，且及时任务依其截⽌时 间的⾮减序排列。 0 4.8 贪⼼算法的理论基础 ⾸先可将时间表调整为及时优先形式，然后再进⼀步 调整及时任务的次序。 任务时间表问题 等价于 确定最优时间表中 及时任务⼦ 集 A 的问题。⼀旦确定了及时任务⼦集 A ，将 A 中各任 务依其截⽌时间的⾮减序列出，然后再以任意次序列 出误时任务，即 S -A 中各任务，由此产⽣ S 的⼀个规范 的最优时间表。 对时间 t =1,2,…,n ， 设 (A ) 是任务⼦集 A 中所有截⽌时 间是 t 或更早的任务数。考察任务⼦集 A 的独⽴性。 0 4.8 贪⼼算法的理论基础 引理 4.6 ： 对于 S 的任⼀任务⼦集 A ，下⾯的各命题是等 价的。 (1) 任务⼦集 A 是独⽴⼦集。 (2) 对于 t =1,2,…,n ， (A ) ≤ t 。 (3) 若 A 中任务依其截⽌时间⾮减序排列，则 A 中所有任 务都是及时的。 任务时间表问题 要求使总误时惩罚达到最⼩，这等价 于使任务时间表中的及时任务的惩罚值之和达到最 ⼤。下⾯的 定理 表明可⽤带权拟阵的贪⼼算法解任务 时间表问题。 0 4.8 贪⼼算法的理论基础 定理 4.7 ： 设 S 是带有截⽌时间的单位时间任务集， I 是 S 的所有独⽴任务⼦集构成的集合。则有序对 (S ,I) 是拟阵。 由 定理 4.5 可知，⽤带权拟阵的贪⼼算法可以求得最⼤ 权 ( 惩罚 ) 独⽴任务⼦集 A ，以 A 作为最优时间表中的及时 任务⼦集，容易构造最优时间表。 任务时间表问题的贪⼼算法的 计算时间复杂性 是 。其中 f(n) 是⽤于检测任务⼦集 A 的独⽴性所需的时间。 ⽤引理 4.6 中性质 (2) 容易设计⼀个 时间算法来 检测任务⼦集的独⽴性。因此，整个算法的 计算时间 为 。具体算法 gr e e d yJob 可描述如 P 130 。 0 4.8 贪⼼算法的理论基础 ⽤抽象数据类型并查集 U n i on F i n d 可对上述算法作进 ⼀步改进。如果不计预处理的时间，改进后的算法 fas te r Job 所需的 计算时间 为 。 0 4.8 贪⼼算法的理论基础 具有 截⽌时间 和 误时惩罚 的单位时间任务时间表问题 可描述如下。 (1) n 个单位时间任务的集合 S ={1,2,…,n} ； (2) 任务 i 的截⽌时间 ,1 ≤ i ≤ n,1 ≤ ≤ n ，即要求任务 i 在时 间 之前结束； (3) 任务 i 的误时惩罚 ,1 ≤ i ≤ n, 即任务 i 未在时间 之前结 束将招致的 惩罚；若按时完成则⽆惩罚。 任务时间表问题 要求确定 S 的⼀个时间表（最优时间 表）使得总误时惩罚达到最⼩。 0 4.8 贪⼼算法的理论基础 这个问题看上去很复杂，然⽽借助于 拟阵 ，可以⽤ 带 权拟阵的贪⼼算法 有效求解。 对于⼀个给定的 S 的时间表，在截⽌时间之前完成的 任务称为 及时任务 ，在截⽌时间之后完成的任务称为 误时任务 。 S 的任⼀时间表可以调整成 及时优先形式 ，即其中所 有及时任务先于误时任务，⽽不影响原时间表中各任 务的及时或误时性质。 类似地，还可将 S 的任⼀时间表调整成为 规范形式 ， 其中及时任务先于误时任务，且及时任务依其截⽌时 间的⾮减序排列。 0 4.8 贪⼼算法的理论基础 ⾸先可将时间表调整为及时优先形式，然后再进⼀步 调整及时任务的次序。 任务时间表问题 等价于 确定最优时间表中 及时任务⼦ 集 A 的问题。⼀旦确定了及时任务⼦集 A ，将 A 中各任 务依其截⽌时间的⾮减序列出，然后再以任意次序列 出误时任务，即 S -A 中各任务，由此产⽣ S 的⼀个规范 的最优时间表。 对时间 t =1,2,…,n ， 设 (A ) 是任务⼦集 A 中所有截⽌时 间是 t 或更早的任务数。考察任务⼦集 A 的独⽴性。 0 4.8 贪⼼算法的理论基础 引理 4.6 ： 对于 S 的任⼀任务⼦集 A ，下⾯的各命题是等 价的。 (1) 任务⼦集 A 是独⽴⼦集。 (2) 对于 t =1,2,…,n ， (A ) ≤ t 。 (3) 若 A 中任务依其截⽌时间⾮减序排列，则 A 中所有任 务都是及时的。 任务时间表问题 要求使总误时惩罚达到最⼩，这等价 于使任务时间表中的及时任务的惩罚值之和达到最 ⼤。下⾯的 定理 表明可⽤带权拟阵的贪⼼算法解任务 时间表问题。 0 4.8 贪⼼算法的理论基础 定理 4.7 ： 设 S 是带有截⽌时间的单位时间任务集， I 是 S 的所有独⽴任务⼦集构成的集合。则有序对 (S ,I) 是拟阵。 由 定理 4.5 可知，⽤带权拟阵的贪⼼算法可以求得最⼤ 权 ( 惩罚 ) 独⽴任务⼦集 A ，以 A 作为最优时间表中的及时 任务⼦集，容易构造最优时间表。 任务时间表问题的贪⼼算法的 计算时间复杂性 是 。其中 f(n) 是⽤于检测任务⼦集 A 的独⽴性所需的时间。 ⽤引理 4.6 中性质 (2) 容易设计⼀个 时间算法来 检测任务⼦集的独⽴性。因此，整个算法的 计算时间 为 。具体算法 gr e e d yJob 可描述如 P 130 。 0 4.8 贪⼼算法的理论基础 ⽤抽象数据类型并查集 U n i on F i n d 可对上述算法作进 ⼀步改进。如果不计预处理的时间，改进后的算法 fas te r Job 所需的 计算时间 为 。","libVersion":"0.2.4","langs":""}